<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>browserless.io function runner</title>
    <script type="module">
    "use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js
  var init_dirname = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js"() {
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/buffer.js
  function dew$2() {
    if (_dewExec$2)
      return exports$3;
    _dewExec$2 = true;
    exports$3.byteLength = byteLength;
    exports$3.toByteArray = toByteArray;
    exports$3.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i7 = 0, len = code.length; i7 < len; ++i7) {
      lookup[i7] = code[i7];
      revLookup[code.charCodeAt(i7)] = i7;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i8;
      for (i8 = 0; i8 < len2; i8 += 4) {
        tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i8 = start; i8 < end; i8 += 3) {
        tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    return exports$3;
  }
  function dew$1() {
    if (_dewExec$1)
      return exports$2;
    _dewExec$1 = true;
    exports$2.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e9, m6;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i7 = isLE ? nBytes - 1 : 0;
      var d6 = isLE ? -1 : 1;
      var s6 = buffer2[offset + i7];
      i7 += d6;
      e9 = s6 & (1 << -nBits) - 1;
      s6 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e9 = e9 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
      }
      m6 = e9 & (1 << -nBits) - 1;
      e9 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
      }
      if (e9 === 0) {
        e9 = 1 - eBias;
      } else if (e9 === eMax) {
        return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
      } else {
        m6 = m6 + Math.pow(2, mLen);
        e9 = e9 - eBias;
      }
      return (s6 ? -1 : 1) * m6 * Math.pow(2, e9 - mLen);
    };
    exports$2.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e9, m6, c7;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i7 = isLE ? 0 : nBytes - 1;
      var d6 = isLE ? 1 : -1;
      var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m6 = isNaN(value) ? 1 : 0;
        e9 = eMax;
      } else {
        e9 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c7 = Math.pow(2, -e9)) < 1) {
          e9--;
          c7 *= 2;
        }
        if (e9 + eBias >= 1) {
          value += rt / c7;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c7 >= 2) {
          e9++;
          c7 /= 2;
        }
        if (e9 + eBias >= eMax) {
          m6 = 0;
          e9 = eMax;
        } else if (e9 + eBias >= 1) {
          m6 = (value * c7 - 1) * Math.pow(2, mLen);
          e9 = e9 + eBias;
        } else {
          m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e9 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
      }
      e9 = e9 << mLen | m6;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i7] = e9 & 255, i7 += d6, e9 /= 256, eLen -= 8) {
      }
      buffer2[offset + i7 - d6] |= s6 * 128;
    };
    return exports$2;
  }
  function dew() {
    if (_dewExec)
      return exports$1;
    _dewExec = true;
    const base64 = dew$2();
    const ieee754 = dew$1();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports$1.Buffer = Buffer3;
    exports$1.SlowBuffer = SlowBuffer;
    exports$1.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports$1.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e9) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from2(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from2(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b5 = fromObject(value);
      if (b5)
        return b5;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from2(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike2(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i7 = 0; i7 < length; i7 += 1) {
        buf[i7] = array[i7] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike2(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike2(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike2(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer3(b5) {
      return b5 != null && b5._isBuffer === true && b5 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a7, b5) {
      if (isInstance(a7, Uint8Array))
        a7 = Buffer3.from(a7, a7.offset, a7.byteLength);
      if (isInstance(b5, Uint8Array))
        b5 = Buffer3.from(b5, b5.offset, b5.byteLength);
      if (!Buffer3.isBuffer(a7) || !Buffer3.isBuffer(b5)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a7 === b5)
        return 0;
      let x4 = a7.length;
      let y6 = b5.length;
      for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
        if (a7[i7] !== b5[i7]) {
          x4 = a7[i7];
          y6 = b5[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i7;
      if (length === void 0) {
        length = 0;
        for (i7 = 0; i7 < list.length; ++i7) {
          length += list[i7].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        let buf = list[i7];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(buffer2, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b5, n8, m6) {
      const i7 = b5[n8];
      b5[n8] = b5[m6];
      b5[m6] = i7;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 2) {
        swap(this, i7, i7 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 4) {
        swap(this, i7, i7 + 3);
        swap(this, i7 + 1, i7 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 8) {
        swap(this, i7, i7 + 7);
        swap(this, i7 + 1, i7 + 6);
        swap(this, i7 + 2, i7 + 5);
        swap(this, i7 + 3, i7 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b5) {
      if (!Buffer3.isBuffer(b5))
        throw new TypeError("Argument must be a Buffer");
      if (this === b5)
        return true;
      return Buffer3.compare(this, b5) === 0;
    };
    Buffer3.prototype.inspect = function inspect3() {
      let str = "";
      const max = exports$1.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x4 = thisEnd - thisStart;
      let y6 = end - start;
      const len = Math.min(x4, y6);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i7 = 0; i7 < len; ++i7) {
        if (thisCopy[i7] !== targetCopy[i7]) {
          x4 = thisCopy[i7];
          y6 = targetCopy[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i8) {
        if (indexSize === 1) {
          return buf[i8];
        } else {
          return buf.readUInt16BE(i8 * indexSize);
        }
      }
      let i7;
      if (dir) {
        let foundIndex = -1;
        for (i7 = byteOffset; i7 < arrLength; i7++) {
          if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i7;
            if (i7 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i7 -= i7 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i7 = byteOffset; i7 >= 0; i7--) {
          let found = true;
          for (let j4 = 0; j4 < valLength; j4++) {
            if (read2(arr, i7 + j4) !== read2(val, j4)) {
              found = false;
              break;
            }
          }
          if (found)
            return i7;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        const parsed = parseInt(string.substr(i7 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i7;
        buf[offset + i7] = parsed;
      }
      return i7;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i7 = start;
      while (i7 < end) {
        const firstByte = buf[i7];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i7 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i7 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              fourthByte = buf[i7 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i7 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i7 = 0;
      while (i7 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i7 = start; i7 < end; ++i7) {
        out += hexSliceLookupTable[buf[i7]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
        res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i7 = byteLength2;
      let mul = 1;
      let val = this[offset + --i7];
      while (i7 > 0 && (mul *= 256)) {
        val += this[offset + --i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first2 << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i7 = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i7;
      if (typeof val === "number") {
        for (i7 = start; i7 < end; ++i7) {
          this[i7] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i7 = 0; i7 < end - start; ++i7) {
          this[i7 + start] = bytes[i7 % len];
        }
      }
      return this;
    };
    const errors = {};
    function E4(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E4("ERR_INVALID_ARG_TYPE", function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E4("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i7 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i7 >= start + 4; i7 -= 3) {
        res = `_${val.slice(i7 - 3, i7)}${res}`;
      }
      return `${val.slice(0, i7)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n8 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
          } else {
            range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
          }
        } else {
          range = `>= ${min}${n8} and <= ${max}${n8}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i7 = 0; i7 < length; ++i7) {
        codePoint = string.charCodeAt(i7);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i7 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        byteArray.push(str.charCodeAt(i7) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c7, hi, lo;
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        if ((units -= 2) < 0)
          break;
        c7 = str.charCodeAt(i7);
        hi = c7 >> 8;
        lo = c7 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        if (i7 + offset >= dst.length || i7 >= src.length)
          break;
        dst[i7 + offset] = src[i7];
      }
      return i7;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i7 = 0; i7 < 16; ++i7) {
        const i16 = i7 * 16;
        for (let j4 = 0; j4 < 16; ++j4) {
          table[i16 + j4] = alphabet[i7] + alphabet[j4];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    return exports$1;
  }
  var exports$3, _dewExec$2, exports$2, _dewExec$1, exports$1, _dewExec, exports, Buffer2, INSPECT_MAX_BYTES, kMaxLength;
  var init_buffer = __esm({
    "node_modules/@jspm/core/nodelibs/browser/buffer.js"() {
      init_dirname();
      init_buffer2();
      exports$3 = {};
      _dewExec$2 = false;
      exports$2 = {};
      _dewExec$1 = false;
      exports$1 = {};
      _dewExec = false;
      exports = dew();
      exports["Buffer"];
      exports["SlowBuffer"];
      exports["INSPECT_MAX_BYTES"];
      exports["kMaxLength"];
      Buffer2 = exports.Buffer;
      INSPECT_MAX_BYTES = exports.INSPECT_MAX_BYTES;
      kMaxLength = exports.kMaxLength;
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
  var init_buffer2 = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
      init_buffer();
    }
  });

  // node_modules/puppeteer-core/lib/esm/third_party/rxjs/rxjs.js
  function __extends(d6, b5) {
    if (typeof b5 !== "function" && b5 !== null)
      throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
    extendStatics(d6, b5);
    function __() {
      this.constructor = d6;
    }
    d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
  }
  function __awaiter(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve3) {
        resolve3(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve3, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _4 = { label: 0, sent: function() {
      if (t8[0] & 1)
        throw t8[1];
      return t8[1];
    }, trys: [], ops: [] }, f7, y6, t8, g5;
    return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
      return this;
    }), g5;
    function verb(n8) {
      return function(v6) {
        return step([n8, v6]);
      };
    }
    function step(op) {
      if (f7)
        throw new TypeError("Generator is already executing.");
      while (g5 && (g5 = 0, op[0] && (_4 = 0)), _4)
        try {
          if (f7 = 1, y6 && (t8 = op[0] & 2 ? y6["return"] : op[0] ? y6["throw"] || ((t8 = y6["return"]) && t8.call(y6), 0) : y6.next) && !(t8 = t8.call(y6, op[1])).done)
            return t8;
          if (y6 = 0, t8)
            op = [op[0] & 2, t8.value];
          switch (op[0]) {
            case 0:
            case 1:
              t8 = op;
              break;
            case 4:
              _4.label++;
              return { value: op[1], done: false };
            case 5:
              _4.label++;
              y6 = op[1];
              op = [0];
              continue;
            case 7:
              op = _4.ops.pop();
              _4.trys.pop();
              continue;
            default:
              if (!(t8 = _4.trys, t8 = t8.length > 0 && t8[t8.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _4 = 0;
                continue;
              }
              if (op[0] === 3 && (!t8 || op[1] > t8[0] && op[1] < t8[3])) {
                _4.label = op[1];
                break;
              }
              if (op[0] === 6 && _4.label < t8[1]) {
                _4.label = t8[1];
                t8 = op;
                break;
              }
              if (t8 && _4.label < t8[2]) {
                _4.label = t8[2];
                _4.ops.push(op);
                break;
              }
              if (t8[2])
                _4.ops.pop();
              _4.trys.pop();
              continue;
          }
          op = body.call(thisArg, _4);
        } catch (e9) {
          op = [6, e9];
          y6 = 0;
        } finally {
          f7 = t8 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o8) {
    var s6 = typeof Symbol === "function" && Symbol.iterator, m6 = s6 && o8[s6], i7 = 0;
    if (m6)
      return m6.call(o8);
    if (o8 && typeof o8.length === "number")
      return {
        next: function() {
          if (o8 && i7 >= o8.length)
            o8 = void 0;
          return { value: o8 && o8[i7++], done: !o8 };
        }
      };
    throw new TypeError(s6 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o8, n8) {
    var m6 = typeof Symbol === "function" && o8[Symbol.iterator];
    if (!m6)
      return o8;
    var i7 = m6.call(o8), r9, ar = [], e9;
    try {
      while ((n8 === void 0 || n8-- > 0) && !(r9 = i7.next()).done)
        ar.push(r9.value);
    } catch (error) {
      e9 = { error };
    } finally {
      try {
        if (r9 && !r9.done && (m6 = i7["return"]))
          m6.call(i7);
      } finally {
        if (e9)
          throw e9.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i7 = 0, l7 = from2.length, ar; i7 < l7; i7++) {
        if (ar || !(i7 in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i7);
          ar[i7] = from2[i7];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  function __await(v6) {
    return this instanceof __await ? (this.v = v6, this) : new __await(v6);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g5 = generator.apply(thisArg, _arguments || []), i7, q3 = [];
    return i7 = {}, verb("next"), verb("throw"), verb("return"), i7[Symbol.asyncIterator] = function() {
      return this;
    }, i7;
    function verb(n8) {
      if (g5[n8])
        i7[n8] = function(v6) {
          return new Promise(function(a7, b5) {
            q3.push([n8, v6, a7, b5]) > 1 || resume(n8, v6);
          });
        };
    }
    function resume(n8, v6) {
      try {
        step(g5[n8](v6));
      } catch (e9) {
        settle(q3[0][3], e9);
      }
    }
    function step(r9) {
      r9.value instanceof __await ? Promise.resolve(r9.value.v).then(fulfill, reject) : settle(q3[0][2], r9);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f7, v6) {
      if (f7(v6), q3.shift(), q3.length)
        resume(q3[0][0], q3[0][1]);
    }
  }
  function __asyncValues(o8) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m6 = o8[Symbol.asyncIterator], i7;
    return m6 ? m6.call(o8) : (o8 = typeof __values === "function" ? __values(o8) : o8[Symbol.iterator](), i7 = {}, verb("next"), verb("throw"), verb("return"), i7[Symbol.asyncIterator] = function() {
      return this;
    }, i7);
    function verb(n8) {
      i7[n8] = o8[n8] && function(v6) {
        return new Promise(function(resolve3, reject) {
          v6 = o8[n8](v6), settle(resolve3, reject, v6.done, v6.value);
        });
      };
    }
    function settle(resolve3, reject, d6, v6) {
      Promise.resolve(v6).then(function(v22) {
        resolve3({ value: v22, done: d6 });
      }, reject);
    }
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      var onUnhandledError = config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }
  function noop() {
  }
  function errorNotification(error) {
    return createNotification("E", void 0, error);
  }
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  function createNotification(kind, value, error) {
    return {
      kind,
      value,
      error
    };
  }
  function errorContext(cb) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context, errorThrown = _a.errorThrown, error = _a.error;
        context = null;
        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  }
  function captureError(err) {
    if (config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  }
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  function handleUnhandledError(error) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      captureError(error);
    } else {
      reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  function identity(x4) {
    return x4;
  }
  function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  }
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }
  function hasLift(source2) {
    return isFunction(source2 === null || source2 === void 0 ? void 0 : source2.lift);
  }
  function operate(init2) {
    return function(source2) {
      if (hasLift(source2)) {
        return source2.lift(function(liftedSource) {
          try {
            return init2(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  function isScheduler(value) {
    return value && isFunction(value.schedule);
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : void 0;
  }
  function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  }
  function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
  }
  function isInteropObservable(input) {
    return isFunction(input[observable]);
  }
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
  }
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            if (false)
              return [3, 8];
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done)
              return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function(subscriber) {
      var obs = obj[observable]();
      if (isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike(array) {
    return new Observable(function(subscriber) {
      for (var i7 = 0; i7 < array.length && !subscriber.closed; i7++) {
        subscriber.next(array[i7]);
      }
      subscriber.complete();
    });
  }
  function fromPromise(promise) {
    return new Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function(subscriber) {
      process2(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process2(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }
  function executeSchedule(parentSubscription, scheduler, work, delay2, repeat) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (repeat === void 0) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay2));
      } else {
        this.unsubscribe();
      }
    }, delay2);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }
  function observeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function(source2, subscriber) {
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay2);
      }, function() {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay2);
      }, function(err) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay2);
      }));
    });
  }
  function subscribeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function(source2, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source2.subscribe(subscriber);
      }, delay2));
    });
  }
  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }
  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var i7 = 0;
      return scheduler.schedule(function() {
        if (i7 === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i7++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }
  function scheduleIterable(input, scheduler) {
    return new Observable(function(subscriber) {
      var iterator2;
      executeSchedule(subscriber, scheduler, function() {
        iterator2 = input[iterator]();
        executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value;
          var done;
          try {
            _a = iterator2.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
      };
    });
  }
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      executeSchedule(subscriber, scheduler, function() {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function() {
          iterator2.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }
      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }
      if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      }
      if (isAsyncIterable(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }
  function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    return from(args, scheduler);
  }
  function lastValueFrom(source2, config2) {
    var hasConfig = typeof config2 === "object";
    return new Promise(function(resolve3, reject) {
      var _hasValue = false;
      var _value;
      source2.subscribe({
        next: function(value) {
          _value = value;
          _hasValue = true;
        },
        error: reject,
        complete: function() {
          if (_hasValue) {
            resolve3(_value);
          } else if (hasConfig) {
            resolve3(config2.defaultValue);
          } else {
            reject(new EmptyError());
          }
        }
      });
    });
  }
  function firstValueFrom(source2, config2) {
    var hasConfig = typeof config2 === "object";
    return new Promise(function(resolve3, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          resolve3(value);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          if (hasConfig) {
            resolve3(config2.defaultValue);
          } else {
            reject(new EmptyError());
          }
        }
      });
      source2.subscribe(subscriber);
    });
  }
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }
  function map(project, thisArg) {
    return operate(function(source2, subscriber) {
      var index = 0;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }
  function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
  }
  function mapOneOrManyArgs(fn) {
    return map(function(args) {
      return callOrApply(fn, args);
    });
  }
  function mergeInternals(source2, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer2 = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer2.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer2.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer2.shift();
              if (innerSubScheduler) {
                executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer2.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source2.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
  }
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction(resultSelector)) {
      return mergeMap(function(a7, i7) {
        return map(function(b5, ii) {
          return resultSelector(a7, b5, i7, ii);
        })(innerFrom(project(a7, i7)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return operate(function(source2, subscriber) {
      return mergeInternals(source2, subscriber, project, concurrent);
    });
  }
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap(identity, concurrent);
  }
  function concatAll() {
    return mergeAll(1);
  }
  function concat() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return concatAll()(from(args, popScheduler(args)));
  }
  function defer(observableFactory) {
    return new Observable(function(subscriber) {
      innerFrom(observableFactory()).subscribe(subscriber);
    });
  }
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
      resultSelector = options;
      options = void 0;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
    }
    var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
    if (!add) {
      if (isArrayLike(target)) {
        return mergeMap(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  }
  function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction(target.addListener) && isFunction(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction(target.on) && isFunction(target.off);
  }
  function isEventTarget(target) {
    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
  }
  function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === void 0) {
      dueTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable(function(subscriber) {
      var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n8 = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n8++);
          if (0 <= intervalDuration) {
            this.schedule(void 0, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  }
  function merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    var concurrent = popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
  }
  function argsOrArgArray(args) {
    return args.length === 1 && isArray3(args[0]) ? args[0] : args;
  }
  function filter(predicate, thisArg) {
    return operate(function(source2, subscriber) {
      var index = 0;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }
  function race() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    sources = argsOrArgArray(sources);
    return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
  }
  function raceInit(sources) {
    return function(subscriber) {
      var subscriptions = [];
      var _loop_1 = function(i22) {
        subscriptions.push(innerFrom(sources[i22]).subscribe(createOperatorSubscriber(subscriber, function(value) {
          if (subscriptions) {
            for (var s6 = 0; s6 < subscriptions.length; s6++) {
              s6 !== i22 && subscriptions[s6].unsubscribe();
            }
            subscriptions = null;
          }
          subscriber.next(value);
        })));
      };
      for (var i7 = 0; subscriptions && !subscriber.closed && i7 < sources.length; i7++) {
        _loop_1(i7);
      }
    };
  }
  function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) {
      startBufferEvery = null;
    }
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
    return operate(function(source2, subscriber) {
      var buffers = [];
      var count = 0;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a, e_2, _b;
        var toEmit = null;
        if (count++ % startBufferEvery === 0) {
          buffers.push([]);
        }
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer2 = buffers_1_1.value;
            buffer2.push(value);
            if (bufferSize <= buffer2.length) {
              toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
              toEmit.push(buffer2);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
              _a.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (toEmit) {
          try {
            for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
              var buffer2 = toEmit_1_1.value;
              arrRemove(buffers, buffer2);
              subscriber.next(buffer2);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                _b.call(toEmit_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      }, function() {
        var e_3, _a;
        try {
          for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
            var buffer2 = buffers_2_1.value;
            subscriber.next(buffer2);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
              _a.call(buffers_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        subscriber.complete();
      }, void 0, function() {
        buffers = null;
      }));
    });
  }
  function catchError(selector) {
    return operate(function(source2, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source2.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
        handledResult = innerFrom(selector(err, catchError(selector)(source2)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  }
  function concatMap(project, resultSelector) {
    return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
  }
  function defaultIfEmpty(defaultValue) {
    return operate(function(source2, subscriber) {
      var hasValue = false;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  }
  function take(count) {
    return count <= 0 ? function() {
      return EMPTY;
    } : operate(function(source2, subscriber) {
      var seen = 0;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }
  function ignoreElements() {
    return operate(function(source2, subscriber) {
      source2.subscribe(createOperatorSubscriber(subscriber, noop));
    });
  }
  function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
      errorFactory = defaultErrorFactory;
    }
    return operate(function(source2, subscriber) {
      var hasValue = false;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  function defaultErrorFactory() {
    return new EmptyError();
  }
  function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source2) {
      return source2.pipe(predicate ? filter(function(v6, i7) {
        return predicate(v6, i7, source2);
      }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
        return new EmptyError();
      }));
    };
  }
  function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return operate(function(source2, subscriber) {
      var state = seed;
      return mergeInternals(source2, subscriber, function(value, index) {
        return accumulator(state, value, index);
      }, concurrent, function(value) {
        state = value;
      }, false, void 0, function() {
        return state = null;
      });
    });
  }
  function raceWith() {
    var otherSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return !otherSources.length ? identity : operate(function(source2, subscriber) {
      raceInit(__spreadArray([source2], __read(otherSources)))(subscriber);
    });
  }
  function retry(configOrCount) {
    if (configOrCount === void 0) {
      configOrCount = Infinity;
    }
    var config2;
    if (configOrCount && typeof configOrCount === "object") {
      config2 = configOrCount;
    } else {
      config2 = {
        count: configOrCount
      };
    }
    var _a = config2.count, count = _a === void 0 ? Infinity : _a, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
    return count <= 0 ? identity : operate(function(source2, subscriber) {
      var soFar = 0;
      var innerSub;
      var subscribeForRetry = function() {
        var syncUnsub = false;
        innerSub = source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
          if (resetOnSuccess) {
            soFar = 0;
          }
          subscriber.next(value);
        }, void 0, function(err) {
          if (soFar++ < count) {
            var resub_1 = function() {
              if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
              } else {
                syncUnsub = true;
              }
            };
            if (delay2 != null) {
              var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(err, soFar));
              var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                resub_1();
              }, function() {
                subscriber.complete();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              resub_1();
            }
          } else {
            subscriber.error(err);
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          subscribeForRetry();
        }
      };
      subscribeForRetry();
    });
  }
  function startWith() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    var scheduler = popScheduler(values);
    return operate(function(source2, subscriber) {
      (scheduler ? concat(values, source2, scheduler) : concat(values, source2)).subscribe(subscriber);
    });
  }
  function switchMap(project, resultSelector) {
    return operate(function(source2, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  }
  function takeUntil(notifier) {
    return operate(function(source2, subscriber) {
      innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop));
      !subscriber.closed && source2.subscribe(subscriber);
    });
  }
  function tap(observerOrNext, error, complete) {
    var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? operate(function(source2, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      var isUnsub = true;
      source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
      }));
    }) : identity;
  }
  var extendStatics, UnsubscriptionError, Subscription, EMPTY_SUBSCRIPTION, config, timeoutProvider, COMPLETE_NOTIFICATION, context, Subscriber, _bind, ConsumerObserver, SafeSubscriber, EMPTY_OBSERVER, observable, Observable, OperatorSubscriber, ObjectUnsubscribedError, Subject, AnonymousSubject, dateTimestampProvider, ReplaySubject, Action, intervalProvider, AsyncAction, Scheduler, AsyncScheduler, asyncScheduler, async, EMPTY, isArrayLike, iterator, EmptyError, isArray, isArray2, objectProto, nodeEventEmitterMethods, eventTargetMethods, jqueryMethods, NEVER, isArray3;
  var init_rxjs = __esm({
    "node_modules/puppeteer-core/lib/esm/third_party/rxjs/rxjs.js"() {
      init_dirname();
      init_buffer2();
      extendStatics = function(d6, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d22, b22) {
          d22.__proto__ = b22;
        } || function(d22, b22) {
          for (var p7 in b22)
            if (Object.prototype.hasOwnProperty.call(b22, p7))
              d22[p7] = b22[p7];
        };
        return extendStatics(d6, b5);
      };
      UnsubscriptionError = createErrorClass(function(_super) {
        return function UnsubscriptionErrorImpl(errors) {
          _super(this);
          this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i7) {
            return i7 + 1 + ") " + err.toString();
          }).join("\n  ") : "";
          this.name = "UnsubscriptionError";
          this.errors = errors;
        };
      });
      Subscription = function() {
        function Subscription2(initialTeardown) {
          this.initialTeardown = initialTeardown;
          this.closed = false;
          this._parentage = null;
          this._finalizers = null;
        }
        Subscription2.prototype.unsubscribe = function() {
          var e_1, _a, e_2, _b;
          var errors;
          if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
              this._parentage = null;
              if (Array.isArray(_parentage)) {
                try {
                  for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                    var parent_1 = _parentage_1_1.value;
                    parent_1.remove(this);
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                      _a.call(_parentage_1);
                  } finally {
                    if (e_1)
                      throw e_1.error;
                  }
                }
              } else {
                _parentage.remove(this);
              }
            }
            var initialFinalizer = this.initialTeardown;
            if (isFunction(initialFinalizer)) {
              try {
                initialFinalizer();
              } catch (e9) {
                errors = e9 instanceof UnsubscriptionError ? e9.errors : [e9];
              }
            }
            var _finalizers = this._finalizers;
            if (_finalizers) {
              this._finalizers = null;
              try {
                for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                  var finalizer = _finalizers_1_1.value;
                  try {
                    execFinalizer(finalizer);
                  } catch (err) {
                    errors = errors !== null && errors !== void 0 ? errors : [];
                    if (err instanceof UnsubscriptionError) {
                      errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                    } else {
                      errors.push(err);
                    }
                  }
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                    _b.call(_finalizers_1);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
              }
            }
            if (errors) {
              throw new UnsubscriptionError(errors);
            }
          }
        };
        Subscription2.prototype.add = function(teardown) {
          var _a;
          if (teardown && teardown !== this) {
            if (this.closed) {
              execFinalizer(teardown);
            } else {
              if (teardown instanceof Subscription2) {
                if (teardown.closed || teardown._hasParent(this)) {
                  return;
                }
                teardown._addParent(this);
              }
              (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
          }
        };
        Subscription2.prototype._hasParent = function(parent) {
          var _parentage = this._parentage;
          return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
        };
        Subscription2.prototype._addParent = function(parent) {
          var _parentage = this._parentage;
          this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
        };
        Subscription2.prototype._removeParent = function(parent) {
          var _parentage = this._parentage;
          if (_parentage === parent) {
            this._parentage = null;
          } else if (Array.isArray(_parentage)) {
            arrRemove(_parentage, parent);
          }
        };
        Subscription2.prototype.remove = function(teardown) {
          var _finalizers = this._finalizers;
          _finalizers && arrRemove(_finalizers, teardown);
          if (teardown instanceof Subscription2) {
            teardown._removeParent(this);
          }
        };
        Subscription2.EMPTY = function() {
          var empty = new Subscription2();
          empty.closed = true;
          return empty;
        }();
        return Subscription2;
      }();
      EMPTY_SUBSCRIPTION = Subscription.EMPTY;
      config = {
        onUnhandledError: null,
        onStoppedNotification: null,
        Promise: void 0,
        useDeprecatedSynchronousErrorHandling: false,
        useDeprecatedNextContext: false
      };
      timeoutProvider = {
        setTimeout: function(handler, timeout2) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var delegate = timeoutProvider.delegate;
          if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
            return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
          }
          return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
        },
        clearTimeout: function(handle) {
          var delegate = timeoutProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
        },
        delegate: void 0
      };
      COMPLETE_NOTIFICATION = function() {
        return createNotification("C", void 0, void 0);
      }();
      context = null;
      Subscriber = function(_super) {
        __extends(Subscriber2, _super);
        function Subscriber2(destination) {
          var _this = _super.call(this) || this;
          _this.isStopped = false;
          if (destination) {
            _this.destination = destination;
            if (isSubscription(destination)) {
              destination.add(_this);
            }
          } else {
            _this.destination = EMPTY_OBSERVER;
          }
          return _this;
        }
        Subscriber2.create = function(next, error, complete) {
          return new SafeSubscriber(next, error, complete);
        };
        Subscriber2.prototype.next = function(value) {
          if (this.isStopped) {
            handleStoppedNotification(nextNotification(value), this);
          } else {
            this._next(value);
          }
        };
        Subscriber2.prototype.error = function(err) {
          if (this.isStopped) {
            handleStoppedNotification(errorNotification(err), this);
          } else {
            this.isStopped = true;
            this._error(err);
          }
        };
        Subscriber2.prototype.complete = function() {
          if (this.isStopped) {
            handleStoppedNotification(COMPLETE_NOTIFICATION, this);
          } else {
            this.isStopped = true;
            this._complete();
          }
        };
        Subscriber2.prototype.unsubscribe = function() {
          if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
          }
        };
        Subscriber2.prototype._next = function(value) {
          this.destination.next(value);
        };
        Subscriber2.prototype._error = function(err) {
          try {
            this.destination.error(err);
          } finally {
            this.unsubscribe();
          }
        };
        Subscriber2.prototype._complete = function() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        };
        return Subscriber2;
      }(Subscription);
      _bind = Function.prototype.bind;
      ConsumerObserver = function() {
        function ConsumerObserver2(partialObserver) {
          this.partialObserver = partialObserver;
        }
        ConsumerObserver2.prototype.next = function(value) {
          var partialObserver = this.partialObserver;
          if (partialObserver.next) {
            try {
              partialObserver.next(value);
            } catch (error) {
              handleUnhandledError(error);
            }
          }
        };
        ConsumerObserver2.prototype.error = function(err) {
          var partialObserver = this.partialObserver;
          if (partialObserver.error) {
            try {
              partialObserver.error(err);
            } catch (error) {
              handleUnhandledError(error);
            }
          } else {
            handleUnhandledError(err);
          }
        };
        ConsumerObserver2.prototype.complete = function() {
          var partialObserver = this.partialObserver;
          if (partialObserver.complete) {
            try {
              partialObserver.complete();
            } catch (error) {
              handleUnhandledError(error);
            }
          }
        };
        return ConsumerObserver2;
      }();
      SafeSubscriber = function(_super) {
        __extends(SafeSubscriber2, _super);
        function SafeSubscriber2(observerOrNext, error, complete) {
          var _this = _super.call(this) || this;
          var partialObserver;
          if (isFunction(observerOrNext) || !observerOrNext) {
            partialObserver = {
              next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
              error: error !== null && error !== void 0 ? error : void 0,
              complete: complete !== null && complete !== void 0 ? complete : void 0
            };
          } else {
            var context_1;
            if (_this && config.useDeprecatedNextContext) {
              context_1 = Object.create(observerOrNext);
              context_1.unsubscribe = function() {
                return _this.unsubscribe();
              };
              partialObserver = {
                next: observerOrNext.next && bind(observerOrNext.next, context_1),
                error: observerOrNext.error && bind(observerOrNext.error, context_1),
                complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
              };
            } else {
              partialObserver = observerOrNext;
            }
          }
          _this.destination = new ConsumerObserver(partialObserver);
          return _this;
        }
        return SafeSubscriber2;
      }(Subscriber);
      EMPTY_OBSERVER = {
        closed: true,
        next: noop,
        error: defaultErrorHandler,
        complete: noop
      };
      observable = function() {
        return typeof Symbol === "function" && Symbol.observable || "@@observable";
      }();
      Observable = function() {
        function Observable2(subscribe) {
          if (subscribe) {
            this._subscribe = subscribe;
          }
        }
        Observable2.prototype.lift = function(operator) {
          var observable2 = new Observable2();
          observable2.source = this;
          observable2.operator = operator;
          return observable2;
        };
        Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
          var _this = this;
          var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
          errorContext(function() {
            var _a = _this, operator = _a.operator, source2 = _a.source;
            subscriber.add(operator ? operator.call(subscriber, source2) : source2 ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
          });
          return subscriber;
        };
        Observable2.prototype._trySubscribe = function(sink) {
          try {
            return this._subscribe(sink);
          } catch (err) {
            sink.error(err);
          }
        };
        Observable2.prototype.forEach = function(next, promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function(resolve3, reject) {
            var subscriber = new SafeSubscriber({
              next: function(value) {
                try {
                  next(value);
                } catch (err) {
                  reject(err);
                  subscriber.unsubscribe();
                }
              },
              error: reject,
              complete: resolve3
            });
            _this.subscribe(subscriber);
          });
        };
        Observable2.prototype._subscribe = function(subscriber) {
          var _a;
          return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
        };
        Observable2.prototype[observable] = function() {
          return this;
        };
        Observable2.prototype.pipe = function() {
          var operations = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
          }
          return pipeFromArray(operations)(this);
        };
        Observable2.prototype.toPromise = function(promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function(resolve3, reject) {
            var value;
            _this.subscribe(function(x4) {
              return value = x4;
            }, function(err) {
              return reject(err);
            }, function() {
              return resolve3(value);
            });
          });
        };
        Observable2.create = function(subscribe) {
          return new Observable2(subscribe);
        };
        return Observable2;
      }();
      OperatorSubscriber = function(_super) {
        __extends(OperatorSubscriber2, _super);
        function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
          var _this = _super.call(this, destination) || this;
          _this.onFinalize = onFinalize;
          _this.shouldUnsubscribe = shouldUnsubscribe;
          _this._next = onNext ? function(value) {
            try {
              onNext(value);
            } catch (err) {
              destination.error(err);
            }
          } : _super.prototype._next;
          _this._error = onError ? function(err) {
            try {
              onError(err);
            } catch (err2) {
              destination.error(err2);
            } finally {
              this.unsubscribe();
            }
          } : _super.prototype._error;
          _this._complete = onComplete ? function() {
            try {
              onComplete();
            } catch (err) {
              destination.error(err);
            } finally {
              this.unsubscribe();
            }
          } : _super.prototype._complete;
          return _this;
        }
        OperatorSubscriber2.prototype.unsubscribe = function() {
          var _a;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var closed_1 = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
          }
        };
        return OperatorSubscriber2;
      }(Subscriber);
      ObjectUnsubscribedError = createErrorClass(function(_super) {
        return function ObjectUnsubscribedErrorImpl() {
          _super(this);
          this.name = "ObjectUnsubscribedError";
          this.message = "object unsubscribed";
        };
      });
      Subject = function(_super) {
        __extends(Subject2, _super);
        function Subject2() {
          var _this = _super.call(this) || this;
          _this.closed = false;
          _this.currentObservers = null;
          _this.observers = [];
          _this.isStopped = false;
          _this.hasError = false;
          _this.thrownError = null;
          return _this;
        }
        Subject2.prototype.lift = function(operator) {
          var subject = new AnonymousSubject(this, this);
          subject.operator = operator;
          return subject;
        };
        Subject2.prototype._throwIfClosed = function() {
          if (this.closed) {
            throw new ObjectUnsubscribedError();
          }
        };
        Subject2.prototype.next = function(value) {
          var _this = this;
          errorContext(function() {
            var e_1, _a;
            _this._throwIfClosed();
            if (!_this.isStopped) {
              if (!_this.currentObservers) {
                _this.currentObservers = Array.from(_this.observers);
              }
              try {
                for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var observer = _c.value;
                  observer.next(value);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            }
          });
        };
        Subject2.prototype.error = function(err) {
          var _this = this;
          errorContext(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
              _this.hasError = _this.isStopped = true;
              _this.thrownError = err;
              var observers = _this.observers;
              while (observers.length) {
                observers.shift().error(err);
              }
            }
          });
        };
        Subject2.prototype.complete = function() {
          var _this = this;
          errorContext(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
              _this.isStopped = true;
              var observers = _this.observers;
              while (observers.length) {
                observers.shift().complete();
              }
            }
          });
        };
        Subject2.prototype.unsubscribe = function() {
          this.isStopped = this.closed = true;
          this.observers = this.currentObservers = null;
        };
        Object.defineProperty(Subject2.prototype, "observed", {
          get: function() {
            var _a;
            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
          },
          enumerable: false,
          configurable: true
        });
        Subject2.prototype._trySubscribe = function(subscriber) {
          this._throwIfClosed();
          return _super.prototype._trySubscribe.call(this, subscriber);
        };
        Subject2.prototype._subscribe = function(subscriber) {
          this._throwIfClosed();
          this._checkFinalizedStatuses(subscriber);
          return this._innerSubscribe(subscriber);
        };
        Subject2.prototype._innerSubscribe = function(subscriber) {
          var _this = this;
          var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
          if (hasError || isStopped) {
            return EMPTY_SUBSCRIPTION;
          }
          this.currentObservers = null;
          observers.push(subscriber);
          return new Subscription(function() {
            _this.currentObservers = null;
            arrRemove(observers, subscriber);
          });
        };
        Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
          var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
          if (hasError) {
            subscriber.error(thrownError);
          } else if (isStopped) {
            subscriber.complete();
          }
        };
        Subject2.prototype.asObservable = function() {
          var observable2 = new Observable();
          observable2.source = this;
          return observable2;
        };
        Subject2.create = function(destination, source2) {
          return new AnonymousSubject(destination, source2);
        };
        return Subject2;
      }(Observable);
      AnonymousSubject = function(_super) {
        __extends(AnonymousSubject2, _super);
        function AnonymousSubject2(destination, source2) {
          var _this = _super.call(this) || this;
          _this.destination = destination;
          _this.source = source2;
          return _this;
        }
        AnonymousSubject2.prototype.next = function(value) {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        AnonymousSubject2.prototype.error = function(err) {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        AnonymousSubject2.prototype.complete = function() {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        AnonymousSubject2.prototype._subscribe = function(subscriber) {
          var _a, _b;
          return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
        };
        return AnonymousSubject2;
      }(Subject);
      dateTimestampProvider = {
        now: function() {
          return (dateTimestampProvider.delegate || Date).now();
        },
        delegate: void 0
      };
      ReplaySubject = function(_super) {
        __extends(ReplaySubject2, _super);
        function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
          if (_bufferSize === void 0) {
            _bufferSize = Infinity;
          }
          if (_windowTime === void 0) {
            _windowTime = Infinity;
          }
          if (_timestampProvider === void 0) {
            _timestampProvider = dateTimestampProvider;
          }
          var _this = _super.call(this) || this;
          _this._bufferSize = _bufferSize;
          _this._windowTime = _windowTime;
          _this._timestampProvider = _timestampProvider;
          _this._buffer = [];
          _this._infiniteTimeWindow = true;
          _this._infiniteTimeWindow = _windowTime === Infinity;
          _this._bufferSize = Math.max(1, _bufferSize);
          _this._windowTime = Math.max(1, _windowTime);
          return _this;
        }
        ReplaySubject2.prototype.next = function(value) {
          var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
          if (!isStopped) {
            _buffer.push(value);
            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
          }
          this._trimBuffer();
          _super.prototype.next.call(this, value);
        };
        ReplaySubject2.prototype._subscribe = function(subscriber) {
          this._throwIfClosed();
          this._trimBuffer();
          var subscription = this._innerSubscribe(subscriber);
          var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
          var copy = _buffer.slice();
          for (var i7 = 0; i7 < copy.length && !subscriber.closed; i7 += _infiniteTimeWindow ? 1 : 2) {
            subscriber.next(copy[i7]);
          }
          this._checkFinalizedStatuses(subscriber);
          return subscription;
        };
        ReplaySubject2.prototype._trimBuffer = function() {
          var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
          var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
          _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
          if (!_infiniteTimeWindow) {
            var now = _timestampProvider.now();
            var last2 = 0;
            for (var i7 = 1; i7 < _buffer.length && _buffer[i7] <= now; i7 += 2) {
              last2 = i7;
            }
            last2 && _buffer.splice(0, last2 + 1);
          }
        };
        return ReplaySubject2;
      }(Subject);
      Action = function(_super) {
        __extends(Action2, _super);
        function Action2(scheduler, work) {
          return _super.call(this) || this;
        }
        Action2.prototype.schedule = function(state, delay2) {
          if (delay2 === void 0) {
            delay2 = 0;
          }
          return this;
        };
        return Action2;
      }(Subscription);
      intervalProvider = {
        setInterval: function(handler, timeout2) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var delegate = intervalProvider.delegate;
          if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
            return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
          }
          return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
        },
        clearInterval: function(handle) {
          var delegate = intervalProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
        },
        delegate: void 0
      };
      AsyncAction = function(_super) {
        __extends(AsyncAction2, _super);
        function AsyncAction2(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          _this.pending = false;
          return _this;
        }
        AsyncAction2.prototype.schedule = function(state, delay2) {
          var _a;
          if (delay2 === void 0) {
            delay2 = 0;
          }
          if (this.closed) {
            return this;
          }
          this.state = state;
          var id = this.id;
          var scheduler = this.scheduler;
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay2);
          }
          this.pending = true;
          this.delay = delay2;
          this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
          return this;
        };
        AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
          if (delay2 === void 0) {
            delay2 = 0;
          }
          return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
        };
        AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
          if (delay2 === void 0) {
            delay2 = 0;
          }
          if (delay2 != null && this.delay === delay2 && this.pending === false) {
            return id;
          }
          if (id != null) {
            intervalProvider.clearInterval(id);
          }
          return void 0;
        };
        AsyncAction2.prototype.execute = function(state, delay2) {
          if (this.closed) {
            return new Error("executing a cancelled action");
          }
          this.pending = false;
          var error = this._execute(state, delay2);
          if (error) {
            return error;
          } else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
          }
        };
        AsyncAction2.prototype._execute = function(state, _delay) {
          var errored = false;
          var errorValue;
          try {
            this.work(state);
          } catch (e9) {
            errored = true;
            errorValue = e9 ? e9 : new Error("Scheduled action threw falsy error");
          }
          if (errored) {
            this.unsubscribe();
            return errorValue;
          }
        };
        AsyncAction2.prototype.unsubscribe = function() {
          if (!this.closed) {
            var _a = this, id = _a.id, scheduler = _a.scheduler;
            var actions = scheduler.actions;
            this.work = this.state = this.scheduler = null;
            this.pending = false;
            arrRemove(actions, this);
            if (id != null) {
              this.id = this.recycleAsyncId(scheduler, id, null);
            }
            this.delay = null;
            _super.prototype.unsubscribe.call(this);
          }
        };
        return AsyncAction2;
      }(Action);
      Scheduler = function() {
        function Scheduler2(schedulerActionCtor, now) {
          if (now === void 0) {
            now = Scheduler2.now;
          }
          this.schedulerActionCtor = schedulerActionCtor;
          this.now = now;
        }
        Scheduler2.prototype.schedule = function(work, delay2, state) {
          if (delay2 === void 0) {
            delay2 = 0;
          }
          return new this.schedulerActionCtor(this, work).schedule(state, delay2);
        };
        Scheduler2.now = dateTimestampProvider.now;
        return Scheduler2;
      }();
      AsyncScheduler = function(_super) {
        __extends(AsyncScheduler2, _super);
        function AsyncScheduler2(SchedulerAction, now) {
          if (now === void 0) {
            now = Scheduler.now;
          }
          var _this = _super.call(this, SchedulerAction, now) || this;
          _this.actions = [];
          _this._active = false;
          return _this;
        }
        AsyncScheduler2.prototype.flush = function(action) {
          var actions = this.actions;
          if (this._active) {
            actions.push(action);
            return;
          }
          var error;
          this._active = true;
          do {
            if (error = action.execute(action.state, action.delay)) {
              break;
            }
          } while (action = actions.shift());
          this._active = false;
          if (error) {
            while (action = actions.shift()) {
              action.unsubscribe();
            }
            throw error;
          }
        };
        return AsyncScheduler2;
      }(Scheduler);
      asyncScheduler = new AsyncScheduler(AsyncAction);
      async = asyncScheduler;
      EMPTY = new Observable(function(subscriber) {
        return subscriber.complete();
      });
      isArrayLike = function(x4) {
        return x4 && typeof x4.length === "number" && typeof x4 !== "function";
      };
      iterator = getSymbolIterator();
      EmptyError = createErrorClass(function(_super) {
        return function EmptyErrorImpl() {
          _super(this);
          this.name = "EmptyError";
          this.message = "no elements in sequence";
        };
      });
      isArray = Array.isArray;
      isArray2 = Array.isArray;
      objectProto = Object.prototype;
      nodeEventEmitterMethods = ["addListener", "removeListener"];
      eventTargetMethods = ["addEventListener", "removeEventListener"];
      jqueryMethods = ["on", "off"];
      NEVER = new Observable(noop);
      isArray3 = Array.isArray;
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js
  var assert;
  var init_assert = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js"() {
      init_dirname();
      init_buffer2();
      assert = (value, message) => {
        if (!value) {
          throw new Error(message);
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/environment.js
  var isNode;
  var init_environment = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/environment.js"() {
      init_dirname();
      init_buffer2();
      isNode = !!(typeof process !== "undefined" && process.version);
    }
  });

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports8, module) {
      init_dirname();
      init_buffer2();
      var s6 = 1e3;
      var m6 = s6 * 60;
      var h8 = m6 * 60;
      var d6 = h8 * 24;
      var w4 = d6 * 7;
      var y6 = d6 * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse3(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse3(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n8 = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n8 * y6;
          case "weeks":
          case "week":
          case "w":
            return n8 * w4;
          case "days":
          case "day":
          case "d":
            return n8 * d6;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n8 * h8;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n8 * m6;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n8 * s6;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n8;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d6) {
          return Math.round(ms / d6) + "d";
        }
        if (msAbs >= h8) {
          return Math.round(ms / h8) + "h";
        }
        if (msAbs >= m6) {
          return Math.round(ms / m6) + "m";
        }
        if (msAbs >= s6) {
          return Math.round(ms / s6) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d6) {
          return plural(ms, msAbs, d6, "day");
        }
        if (msAbs >= h8) {
          return plural(ms, msAbs, h8, "hour");
        }
        if (msAbs >= m6) {
          return plural(ms, msAbs, m6, "minute");
        }
        if (msAbs >= s6) {
          return plural(ms, msAbs, s6, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n8, name2) {
        var isPlural = msAbs >= n8 * 1.5;
        return Math.round(ms / n8) + " " + name2 + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/debug/src/common.js"(exports8, module) {
      init_dirname();
      init_buffer2();
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i7 = 0; i7 < namespace.length; i7++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i7);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug3(...args) {
            if (!debug3.enabled) {
              return;
            }
            const self2 = debug3;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format5) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format5];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug3.namespace = namespace;
          debug3.useColors = createDebug.useColors();
          debug3.color = createDebug.selectColor(namespace);
          debug3.extend = extend;
          debug3.destroy = createDebug.destroy;
          Object.defineProperty(debug3, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v6) => {
              enableOverride = v6;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug3);
          }
          return debug3;
        }
        function extend(namespace, delimiter2) {
          const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i7;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i7 = 0; i7 < len; i7++) {
            if (!split[i7]) {
              continue;
            }
            namespaces = split[i7].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name2) {
          if (name2[name2.length - 1] === "*") {
            return true;
          }
          let i7;
          let len;
          for (i7 = 0, len = createDebug.skips.length; i7 < len; i7++) {
            if (createDebug.skips[i7].test(name2)) {
              return false;
            }
          }
          for (i7 = 0, len = createDebug.names.length; i7 < len; i7++) {
            if (createDebug.names[i7].test(name2)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "node_modules/debug/src/browser.js"(exports8, module) {
      init_dirname();
      init_buffer2();
      exports8.formatArgs = formatArgs;
      exports8.save = save;
      exports8.load = load;
      exports8.useColors = useColors;
      exports8.storage = localstorage();
      exports8.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports8.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c7 = "color: " + this.color;
        args.splice(1, 0, c7, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c7);
      }
      exports8.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports8.storage.setItem("debug", namespaces);
          } else {
            exports8.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r9;
        try {
          r9 = exports8.storage.getItem("debug");
        } catch (error) {
        }
        if (!r9 && typeof process !== "undefined" && "env" in process) {
          r9 = process.env.DEBUG;
        }
        return r9;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports8);
      var { formatters } = module.exports;
      formatters.j = function(v6) {
        try {
          return JSON.stringify(v6);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js
  async function importDebug() {
    if (!debugModule) {
      debugModule = (await Promise.resolve().then(() => __toESM(require_browser(), 1))).default;
    }
    return debugModule;
  }
  var debugModule, debug, capturedLogs, captureLogs;
  var init_Debug = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js"() {
      init_dirname();
      init_buffer2();
      init_environment();
      debugModule = null;
      debug = (prefix) => {
        if (isNode) {
          return async (...logArgs) => {
            if (captureLogs) {
              capturedLogs.push(prefix + logArgs);
            }
            (await importDebug())(prefix)(logArgs);
          };
        }
        return (...logArgs) => {
          const debugLevel = globalThis.__PUPPETEER_DEBUG;
          if (!debugLevel) {
            return;
          }
          const everythingShouldBeLogged = debugLevel === "*";
          const prefixMatchesDebugLevel = everythingShouldBeLogged || /**
           * If the debug level is `foo*`, that means we match any prefix that
           * starts with `foo`. If the level is `foo`, we match only the prefix
           * `foo`.
           */
          (debugLevel.endsWith("*") ? prefix.startsWith(debugLevel) : prefix === debugLevel);
          if (!prefixMatchesDebugLevel) {
            return;
          }
          console.log(`${prefix}:`, ...logArgs);
        };
      };
      capturedLogs = [];
      captureLogs = false;
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js
  var PuppeteerError, TimeoutError, ProtocolError, UnsupportedOperation, TargetCloseError;
  var init_Errors = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js"() {
      init_dirname();
      init_buffer2();
      PuppeteerError = class extends Error {
        /**
         * @internal
         */
        constructor(message, options) {
          super(message, options);
          this.name = this.constructor.name;
        }
        /**
         * @internal
         */
        get [Symbol.toStringTag]() {
          return this.constructor.name;
        }
      };
      TimeoutError = class extends PuppeteerError {
      };
      ProtocolError = class extends PuppeteerError {
        #code;
        #originalMessage = "";
        set code(code) {
          this.#code = code;
        }
        /**
         * @readonly
         * @public
         */
        get code() {
          return this.#code;
        }
        set originalMessage(originalMessage) {
          this.#originalMessage = originalMessage;
        }
        /**
         * @readonly
         * @public
         */
        get originalMessage() {
          return this.#originalMessage;
        }
      };
      UnsupportedOperation = class extends PuppeteerError {
      };
      TargetCloseError = class extends ProtocolError {
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js
  var paperFormats;
  var init_PDFOptions = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js"() {
      init_dirname();
      init_buffer2();
      paperFormats = {
        letter: { width: 8.5, height: 11 },
        legal: { width: 8.5, height: 14 },
        tabloid: { width: 11, height: 17 },
        ledger: { width: 17, height: 11 },
        a0: { width: 33.1, height: 46.8 },
        a1: { width: 23.4, height: 33.1 },
        a2: { width: 16.54, height: 23.4 },
        a3: { width: 11.7, height: 16.54 },
        a4: { width: 8.27, height: 11.7 },
        a5: { width: 5.83, height: 8.27 },
        a6: { width: 4.13, height: 5.83 }
      };
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js
  function o() {
    o.init.call(this);
  }
  function u(e9) {
    if ("function" != typeof e9)
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e9);
  }
  function f(e9) {
    return void 0 === e9._maxListeners ? o.defaultMaxListeners : e9._maxListeners;
  }
  function v(e9, t8, n8, r9) {
    var i7, o8, s6, v6;
    if (u(n8), void 0 === (o8 = e9._events) ? (o8 = e9._events = /* @__PURE__ */ Object.create(null), e9._eventsCount = 0) : (void 0 !== o8.newListener && (e9.emit("newListener", t8, n8.listener ? n8.listener : n8), o8 = e9._events), s6 = o8[t8]), void 0 === s6)
      s6 = o8[t8] = n8, ++e9._eventsCount;
    else if ("function" == typeof s6 ? s6 = o8[t8] = r9 ? [n8, s6] : [s6, n8] : r9 ? s6.unshift(n8) : s6.push(n8), (i7 = f(e9)) > 0 && s6.length > i7 && !s6.warned) {
      s6.warned = true;
      var a7 = new Error("Possible EventEmitter memory leak detected. " + s6.length + " " + String(t8) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a7.name = "MaxListenersExceededWarning", a7.emitter = e9, a7.type = t8, a7.count = s6.length, v6 = a7, console && console.warn && console.warn(v6);
    }
    return e9;
  }
  function a() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function l(e9, t8, n8) {
    var r9 = { fired: false, wrapFn: void 0, target: e9, type: t8, listener: n8 }, i7 = a.bind(r9);
    return i7.listener = n8, r9.wrapFn = i7, i7;
  }
  function h(e9, t8, n8) {
    var r9 = e9._events;
    if (void 0 === r9)
      return [];
    var i7 = r9[t8];
    return void 0 === i7 ? [] : "function" == typeof i7 ? n8 ? [i7.listener || i7] : [i7] : n8 ? function(e10) {
      for (var t9 = new Array(e10.length), n9 = 0; n9 < t9.length; ++n9)
        t9[n9] = e10[n9].listener || e10[n9];
      return t9;
    }(i7) : c(i7, i7.length);
  }
  function p(e9) {
    var t8 = this._events;
    if (void 0 !== t8) {
      var n8 = t8[e9];
      if ("function" == typeof n8)
        return 1;
      if (void 0 !== n8)
        return n8.length;
    }
    return 0;
  }
  function c(e9, t8) {
    for (var n8 = new Array(t8), r9 = 0; r9 < t8; ++r9)
      n8[r9] = e9[r9];
    return n8;
  }
  var e, t, n, r, i, s, y;
  var init_chunk_4bd36a8f = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js"() {
      init_dirname();
      init_buffer2();
      n = "object" == typeof Reflect ? Reflect : null;
      r = n && "function" == typeof n.apply ? n.apply : function(e9, t8, n8) {
        return Function.prototype.apply.call(e9, t8, n8);
      };
      t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e9) {
        return Object.getOwnPropertyNames(e9).concat(Object.getOwnPropertySymbols(e9));
      } : function(e9) {
        return Object.getOwnPropertyNames(e9);
      };
      i = Number.isNaN || function(e9) {
        return e9 != e9;
      };
      e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
      s = 10;
      Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
        return s;
      }, set: function(e9) {
        if ("number" != typeof e9 || e9 < 0 || i(e9))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e9 + ".");
        s = e9;
      } }), o.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, o.prototype.setMaxListeners = function(e9) {
        if ("number" != typeof e9 || e9 < 0 || i(e9))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e9 + ".");
        return this._maxListeners = e9, this;
      }, o.prototype.getMaxListeners = function() {
        return f(this);
      }, o.prototype.emit = function(e9) {
        for (var t8 = [], n8 = 1; n8 < arguments.length; n8++)
          t8.push(arguments[n8]);
        var i7 = "error" === e9, o8 = this._events;
        if (void 0 !== o8)
          i7 = i7 && void 0 === o8.error;
        else if (!i7)
          return false;
        if (i7) {
          var s6;
          if (t8.length > 0 && (s6 = t8[0]), s6 instanceof Error)
            throw s6;
          var u7 = new Error("Unhandled error." + (s6 ? " (" + s6.message + ")" : ""));
          throw u7.context = s6, u7;
        }
        var f7 = o8[e9];
        if (void 0 === f7)
          return false;
        if ("function" == typeof f7)
          r(f7, this, t8);
        else {
          var v6 = f7.length, a7 = c(f7, v6);
          for (n8 = 0; n8 < v6; ++n8)
            r(a7[n8], this, t8);
        }
        return true;
      }, o.prototype.addListener = function(e9, t8) {
        return v(this, e9, t8, false);
      }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e9, t8) {
        return v(this, e9, t8, true);
      }, o.prototype.once = function(e9, t8) {
        return u(t8), this.on(e9, l(this, e9, t8)), this;
      }, o.prototype.prependOnceListener = function(e9, t8) {
        return u(t8), this.prependListener(e9, l(this, e9, t8)), this;
      }, o.prototype.removeListener = function(e9, t8) {
        var n8, r9, i7, o8, s6;
        if (u(t8), void 0 === (r9 = this._events))
          return this;
        if (void 0 === (n8 = r9[e9]))
          return this;
        if (n8 === t8 || n8.listener === t8)
          0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r9[e9], r9.removeListener && this.emit("removeListener", e9, n8.listener || t8));
        else if ("function" != typeof n8) {
          for (i7 = -1, o8 = n8.length - 1; o8 >= 0; o8--)
            if (n8[o8] === t8 || n8[o8].listener === t8) {
              s6 = n8[o8].listener, i7 = o8;
              break;
            }
          if (i7 < 0)
            return this;
          0 === i7 ? n8.shift() : !function(e10, t9) {
            for (; t9 + 1 < e10.length; t9++)
              e10[t9] = e10[t9 + 1];
            e10.pop();
          }(n8, i7), 1 === n8.length && (r9[e9] = n8[0]), void 0 !== r9.removeListener && this.emit("removeListener", e9, s6 || t8);
        }
        return this;
      }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e9) {
        var t8, n8, r9;
        if (void 0 === (n8 = this._events))
          return this;
        if (void 0 === n8.removeListener)
          return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n8[e9] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n8[e9]), this;
        if (0 === arguments.length) {
          var i7, o8 = Object.keys(n8);
          for (r9 = 0; r9 < o8.length; ++r9)
            "removeListener" !== (i7 = o8[r9]) && this.removeAllListeners(i7);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (t8 = n8[e9]))
          this.removeListener(e9, t8);
        else if (void 0 !== t8)
          for (r9 = t8.length - 1; r9 >= 0; r9--)
            this.removeListener(e9, t8[r9]);
        return this;
      }, o.prototype.listeners = function(e9) {
        return h(this, e9, true);
      }, o.prototype.rawListeners = function(e9) {
        return h(this, e9, false);
      }, o.listenerCount = function(e9, t8) {
        return "function" == typeof e9.listenerCount ? e9.listenerCount(t8) : p.call(e9, t8);
      }, o.prototype.listenerCount = p, o.prototype.eventNames = function() {
        return this._eventsCount > 0 ? t(this._events) : [];
      };
      y = e;
      y.EventEmitter;
      y.defaultMaxListeners;
      y.init;
      y.listenerCount;
      y.EventEmitter;
      y.defaultMaxListeners;
      y.init;
      y.listenerCount;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js
  function i2() {
    throw new Error("setTimeout has not been defined");
  }
  function u2() {
    throw new Error("clearTimeout has not been defined");
  }
  function c2(e9) {
    if (t2 === setTimeout)
      return setTimeout(e9, 0);
    if ((t2 === i2 || !t2) && setTimeout)
      return t2 = setTimeout, setTimeout(e9, 0);
    try {
      return t2(e9, 0);
    } catch (n8) {
      try {
        return t2.call(null, e9, 0);
      } catch (n9) {
        return t2.call(this || r2, e9, 0);
      }
    }
  }
  function h2() {
    f2 && l2 && (f2 = false, l2.length ? s2 = l2.concat(s2) : a2 = -1, s2.length && d());
  }
  function d() {
    if (!f2) {
      var e9 = c2(h2);
      f2 = true;
      for (var t8 = s2.length; t8; ) {
        for (l2 = s2, s2 = []; ++a2 < t8; )
          l2 && l2[a2].run();
        a2 = -1, t8 = s2.length;
      }
      l2 = null, f2 = false, function(e10) {
        if (n2 === clearTimeout)
          return clearTimeout(e10);
        if ((n2 === u2 || !n2) && clearTimeout)
          return n2 = clearTimeout, clearTimeout(e10);
        try {
          n2(e10);
        } catch (t9) {
          try {
            return n2.call(null, e10);
          } catch (t10) {
            return n2.call(this || r2, e10);
          }
        }
      }(e9);
    }
  }
  function m(e9, t8) {
    (this || r2).fun = e9, (this || r2).array = t8;
  }
  function p2() {
  }
  var e2, t2, n2, r2, o2, l2, s2, f2, a2, T;
  var init_chunk_5decc758 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js"() {
      init_dirname();
      init_buffer2();
      r2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
      o2 = e2 = {};
      !function() {
        try {
          t2 = "function" == typeof setTimeout ? setTimeout : i2;
        } catch (e9) {
          t2 = i2;
        }
        try {
          n2 = "function" == typeof clearTimeout ? clearTimeout : u2;
        } catch (e9) {
          n2 = u2;
        }
      }();
      s2 = [];
      f2 = false;
      a2 = -1;
      o2.nextTick = function(e9) {
        var t8 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n8 = 1; n8 < arguments.length; n8++)
            t8[n8 - 1] = arguments[n8];
        s2.push(new m(e9, t8)), 1 !== s2.length || f2 || c2(d);
      }, m.prototype.run = function() {
        (this || r2).fun.apply(null, (this || r2).array);
      }, o2.title = "browser", o2.browser = true, o2.env = {}, o2.argv = [], o2.version = "", o2.versions = {}, o2.on = p2, o2.addListener = p2, o2.once = p2, o2.off = p2, o2.removeListener = p2, o2.removeAllListeners = p2, o2.emit = p2, o2.prependListener = p2, o2.prependOnceListener = p2, o2.listeners = function(e9) {
        return [];
      }, o2.binding = function(e9) {
        throw new Error("process.binding is not supported");
      }, o2.cwd = function() {
        return "/";
      }, o2.chdir = function(e9) {
        throw new Error("process.chdir is not supported");
      }, o2.umask = function() {
        return 0;
      };
      T = e2;
      T.addListener;
      T.argv;
      T.binding;
      T.browser;
      T.chdir;
      T.cwd;
      T.emit;
      T.env;
      T.listeners;
      T.nextTick;
      T.off;
      T.on;
      T.once;
      T.prependListener;
      T.prependOnceListener;
      T.removeAllListeners;
      T.removeListener;
      T.title;
      T.umask;
      T.version;
      T.versions;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js
  function c$1(e9) {
    return e9.call.bind(e9);
  }
  function O(e9, t8) {
    if ("object" != typeof e9)
      return false;
    try {
      return t8(e9), true;
    } catch (e10) {
      return false;
    }
  }
  function S(e9) {
    return l$1 && y2 ? void 0 !== b(e9) : B(e9) || k(e9) || E(e9) || D(e9) || U(e9) || P(e9) || x(e9) || I(e9) || M(e9) || z(e9) || F(e9);
  }
  function B(e9) {
    return l$1 && y2 ? "Uint8Array" === b(e9) : "[object Uint8Array]" === m2(e9) || u$1(e9) && void 0 !== e9.buffer;
  }
  function k(e9) {
    return l$1 && y2 ? "Uint8ClampedArray" === b(e9) : "[object Uint8ClampedArray]" === m2(e9);
  }
  function E(e9) {
    return l$1 && y2 ? "Uint16Array" === b(e9) : "[object Uint16Array]" === m2(e9);
  }
  function D(e9) {
    return l$1 && y2 ? "Uint32Array" === b(e9) : "[object Uint32Array]" === m2(e9);
  }
  function U(e9) {
    return l$1 && y2 ? "Int8Array" === b(e9) : "[object Int8Array]" === m2(e9);
  }
  function P(e9) {
    return l$1 && y2 ? "Int16Array" === b(e9) : "[object Int16Array]" === m2(e9);
  }
  function x(e9) {
    return l$1 && y2 ? "Int32Array" === b(e9) : "[object Int32Array]" === m2(e9);
  }
  function I(e9) {
    return l$1 && y2 ? "Float32Array" === b(e9) : "[object Float32Array]" === m2(e9);
  }
  function M(e9) {
    return l$1 && y2 ? "Float64Array" === b(e9) : "[object Float64Array]" === m2(e9);
  }
  function z(e9) {
    return l$1 && y2 ? "BigInt64Array" === b(e9) : "[object BigInt64Array]" === m2(e9);
  }
  function F(e9) {
    return l$1 && y2 ? "BigUint64Array" === b(e9) : "[object BigUint64Array]" === m2(e9);
  }
  function T2(e9) {
    return "[object Map]" === m2(e9);
  }
  function N(e9) {
    return "[object Set]" === m2(e9);
  }
  function W(e9) {
    return "[object WeakMap]" === m2(e9);
  }
  function $(e9) {
    return "[object WeakSet]" === m2(e9);
  }
  function C(e9) {
    return "[object ArrayBuffer]" === m2(e9);
  }
  function V(e9) {
    return "undefined" != typeof ArrayBuffer && (C.working ? C(e9) : e9 instanceof ArrayBuffer);
  }
  function G(e9) {
    return "[object DataView]" === m2(e9);
  }
  function R(e9) {
    return "undefined" != typeof DataView && (G.working ? G(e9) : e9 instanceof DataView);
  }
  function J(e9) {
    return "[object SharedArrayBuffer]" === m2(e9);
  }
  function _(e9) {
    return "undefined" != typeof SharedArrayBuffer && (J.working ? J(e9) : e9 instanceof SharedArrayBuffer);
  }
  function H(e9) {
    return O(e9, h3);
  }
  function Z(e9) {
    return O(e9, j);
  }
  function q(e9) {
    return O(e9, A);
  }
  function K(e9) {
    return s3 && O(e9, w);
  }
  function L(e9) {
    return p3 && O(e9, v2);
  }
  function oe(e9, t8) {
    var r9 = { seen: [], stylize: fe };
    return arguments.length >= 3 && (r9.depth = arguments[2]), arguments.length >= 4 && (r9.colors = arguments[3]), ye(t8) ? r9.showHidden = t8 : t8 && X._extend(r9, t8), be(r9.showHidden) && (r9.showHidden = false), be(r9.depth) && (r9.depth = 2), be(r9.colors) && (r9.colors = false), be(r9.customInspect) && (r9.customInspect = true), r9.colors && (r9.stylize = ue), ae(r9, e9, r9.depth);
  }
  function ue(e9, t8) {
    var r9 = oe.styles[t8];
    return r9 ? "\x1B[" + oe.colors[r9][0] + "m" + e9 + "\x1B[" + oe.colors[r9][1] + "m" : e9;
  }
  function fe(e9, t8) {
    return e9;
  }
  function ae(e9, t8, r9) {
    if (e9.customInspect && t8 && we(t8.inspect) && t8.inspect !== X.inspect && (!t8.constructor || t8.constructor.prototype !== t8)) {
      var n8 = t8.inspect(r9, e9);
      return ge(n8) || (n8 = ae(e9, n8, r9)), n8;
    }
    var i7 = function(e10, t9) {
      if (be(t9))
        return e10.stylize("undefined", "undefined");
      if (ge(t9)) {
        var r10 = "'" + JSON.stringify(t9).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e10.stylize(r10, "string");
      }
      if (de(t9))
        return e10.stylize("" + t9, "number");
      if (ye(t9))
        return e10.stylize("" + t9, "boolean");
      if (le(t9))
        return e10.stylize("null", "null");
    }(e9, t8);
    if (i7)
      return i7;
    var o8 = Object.keys(t8), u7 = function(e10) {
      var t9 = {};
      return e10.forEach(function(e11, r10) {
        t9[e11] = true;
      }), t9;
    }(o8);
    if (e9.showHidden && (o8 = Object.getOwnPropertyNames(t8)), Ae(t8) && (o8.indexOf("message") >= 0 || o8.indexOf("description") >= 0))
      return ce(t8);
    if (0 === o8.length) {
      if (we(t8)) {
        var f7 = t8.name ? ": " + t8.name : "";
        return e9.stylize("[Function" + f7 + "]", "special");
      }
      if (me(t8))
        return e9.stylize(RegExp.prototype.toString.call(t8), "regexp");
      if (je(t8))
        return e9.stylize(Date.prototype.toString.call(t8), "date");
      if (Ae(t8))
        return ce(t8);
    }
    var a7, c7 = "", s6 = false, p7 = ["{", "}"];
    (pe(t8) && (s6 = true, p7 = ["[", "]"]), we(t8)) && (c7 = " [Function" + (t8.name ? ": " + t8.name : "") + "]");
    return me(t8) && (c7 = " " + RegExp.prototype.toString.call(t8)), je(t8) && (c7 = " " + Date.prototype.toUTCString.call(t8)), Ae(t8) && (c7 = " " + ce(t8)), 0 !== o8.length || s6 && 0 != t8.length ? r9 < 0 ? me(t8) ? e9.stylize(RegExp.prototype.toString.call(t8), "regexp") : e9.stylize("[Object]", "special") : (e9.seen.push(t8), a7 = s6 ? function(e10, t9, r10, n9, i8) {
      for (var o9 = [], u8 = 0, f8 = t9.length; u8 < f8; ++u8)
        ke(t9, String(u8)) ? o9.push(se(e10, t9, r10, n9, String(u8), true)) : o9.push("");
      return i8.forEach(function(i9) {
        i9.match(/^\d+$/) || o9.push(se(e10, t9, r10, n9, i9, true));
      }), o9;
    }(e9, t8, r9, u7, o8) : o8.map(function(n9) {
      return se(e9, t8, r9, u7, n9, s6);
    }), e9.seen.pop(), function(e10, t9, r10) {
      var n9 = 0;
      if (e10.reduce(function(e11, t10) {
        return n9++, t10.indexOf("\n") >= 0 && n9++, e11 + t10.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60)
        return r10[0] + ("" === t9 ? "" : t9 + "\n ") + " " + e10.join(",\n  ") + " " + r10[1];
      return r10[0] + t9 + " " + e10.join(", ") + " " + r10[1];
    }(a7, c7, p7)) : p7[0] + c7 + p7[1];
  }
  function ce(e9) {
    return "[" + Error.prototype.toString.call(e9) + "]";
  }
  function se(e9, t8, r9, n8, i7, o8) {
    var u7, f7, a7;
    if ((a7 = Object.getOwnPropertyDescriptor(t8, i7) || { value: t8[i7] }).get ? f7 = a7.set ? e9.stylize("[Getter/Setter]", "special") : e9.stylize("[Getter]", "special") : a7.set && (f7 = e9.stylize("[Setter]", "special")), ke(n8, i7) || (u7 = "[" + i7 + "]"), f7 || (e9.seen.indexOf(a7.value) < 0 ? (f7 = le(r9) ? ae(e9, a7.value, null) : ae(e9, a7.value, r9 - 1)).indexOf("\n") > -1 && (f7 = o8 ? f7.split("\n").map(function(e10) {
      return "  " + e10;
    }).join("\n").substr(2) : "\n" + f7.split("\n").map(function(e10) {
      return "   " + e10;
    }).join("\n")) : f7 = e9.stylize("[Circular]", "special")), be(u7)) {
      if (o8 && i7.match(/^\d+$/))
        return f7;
      (u7 = JSON.stringify("" + i7)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u7 = u7.substr(1, u7.length - 2), u7 = e9.stylize(u7, "name")) : (u7 = u7.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u7 = e9.stylize(u7, "string"));
    }
    return u7 + ": " + f7;
  }
  function pe(e9) {
    return Array.isArray(e9);
  }
  function ye(e9) {
    return "boolean" == typeof e9;
  }
  function le(e9) {
    return null === e9;
  }
  function de(e9) {
    return "number" == typeof e9;
  }
  function ge(e9) {
    return "string" == typeof e9;
  }
  function be(e9) {
    return void 0 === e9;
  }
  function me(e9) {
    return he(e9) && "[object RegExp]" === ve(e9);
  }
  function he(e9) {
    return "object" == typeof e9 && null !== e9;
  }
  function je(e9) {
    return he(e9) && "[object Date]" === ve(e9);
  }
  function Ae(e9) {
    return he(e9) && ("[object Error]" === ve(e9) || e9 instanceof Error);
  }
  function we(e9) {
    return "function" == typeof e9;
  }
  function ve(e9) {
    return Object.prototype.toString.call(e9);
  }
  function Oe(e9) {
    return e9 < 10 ? "0" + e9.toString(10) : e9.toString(10);
  }
  function Be() {
    var e9 = /* @__PURE__ */ new Date(), t8 = [Oe(e9.getHours()), Oe(e9.getMinutes()), Oe(e9.getSeconds())].join(":");
    return [e9.getDate(), Se[e9.getMonth()], t8].join(" ");
  }
  function ke(e9, t8) {
    return Object.prototype.hasOwnProperty.call(e9, t8);
  }
  function De(e9, t8) {
    if (!e9) {
      var r9 = new Error("Promise was rejected with a falsy value");
      r9.reason = e9, e9 = r9;
    }
    return t8(e9);
  }
  var t3, e3, o3, n3, r3, l3, t$1, o$1, n$1, e$1, r$1, c3, u3, i3, t$2, i$1, o$2, u$1, f3, a3, s3, p3, y2, l$1, d2, m2, h3, j, A, Q, X, Y, ee, te, re, ne, ie, Se, Ee;
  var init_chunk_b4205b57 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js"() {
      init_dirname();
      init_buffer2();
      init_chunk_5decc758();
      t3 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
      e3 = Object.prototype.toString;
      o3 = function(o8) {
        return !(t3 && o8 && "object" == typeof o8 && Symbol.toStringTag in o8) && "[object Arguments]" === e3.call(o8);
      };
      n3 = function(t8) {
        return !!o3(t8) || null !== t8 && "object" == typeof t8 && "number" == typeof t8.length && t8.length >= 0 && "[object Array]" !== e3.call(t8) && "[object Function]" === e3.call(t8.callee);
      };
      r3 = function() {
        return o3(arguments);
      }();
      o3.isLegacyArguments = n3;
      l3 = r3 ? o3 : n3;
      t$1 = Object.prototype.toString;
      o$1 = Function.prototype.toString;
      n$1 = /^\s*(?:function)?\*/;
      e$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
      r$1 = Object.getPrototypeOf;
      c3 = function() {
        if (!e$1)
          return false;
        try {
          return Function("return function*() {}")();
        } catch (t8) {
        }
      }();
      u3 = c3 ? r$1(c3) : {};
      i3 = function(c7) {
        return "function" == typeof c7 && (!!n$1.test(o$1.call(c7)) || (e$1 ? r$1(c7) === u3 : "[object GeneratorFunction]" === t$1.call(c7)));
      };
      t$2 = "function" == typeof Object.create ? function(t8, e9) {
        e9 && (t8.super_ = e9, t8.prototype = Object.create(e9.prototype, { constructor: { value: t8, enumerable: false, writable: true, configurable: true } }));
      } : function(t8, e9) {
        if (e9) {
          t8.super_ = e9;
          var o8 = function() {
          };
          o8.prototype = e9.prototype, t8.prototype = new o8(), t8.prototype.constructor = t8;
        }
      };
      i$1 = function(e9) {
        return e9 && "object" == typeof e9 && "function" == typeof e9.copy && "function" == typeof e9.fill && "function" == typeof e9.readUInt8;
      };
      o$2 = {};
      u$1 = i$1;
      f3 = l3;
      a3 = i3;
      s3 = "undefined" != typeof BigInt;
      p3 = "undefined" != typeof Symbol;
      y2 = p3 && void 0 !== Symbol.toStringTag;
      l$1 = "undefined" != typeof Uint8Array;
      d2 = "undefined" != typeof ArrayBuffer;
      if (l$1 && y2)
        var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
      m2 = c$1(Object.prototype.toString);
      h3 = c$1(Number.prototype.valueOf);
      j = c$1(String.prototype.valueOf);
      A = c$1(Boolean.prototype.valueOf);
      if (s3)
        var w = c$1(BigInt.prototype.valueOf);
      if (p3)
        var v2 = c$1(Symbol.prototype.valueOf);
      o$2.isArgumentsObject = f3, o$2.isGeneratorFunction = a3, o$2.isPromise = function(e9) {
        return "undefined" != typeof Promise && e9 instanceof Promise || null !== e9 && "object" == typeof e9 && "function" == typeof e9.then && "function" == typeof e9.catch;
      }, o$2.isArrayBufferView = function(e9) {
        return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e9) : S(e9) || R(e9);
      }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = "undefined" != typeof Map && T2(/* @__PURE__ */ new Map()), o$2.isMap = function(e9) {
        return "undefined" != typeof Map && (T2.working ? T2(e9) : e9 instanceof Map);
      }, N.working = "undefined" != typeof Set && N(/* @__PURE__ */ new Set()), o$2.isSet = function(e9) {
        return "undefined" != typeof Set && (N.working ? N(e9) : e9 instanceof Set);
      }, W.working = "undefined" != typeof WeakMap && W(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(e9) {
        return "undefined" != typeof WeakMap && (W.working ? W(e9) : e9 instanceof WeakMap);
      }, $.working = "undefined" != typeof WeakSet && $(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(e9) {
        return $(e9);
      }, C.working = "undefined" != typeof ArrayBuffer && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = "undefined" != typeof SharedArrayBuffer && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e9) {
        return "[object AsyncFunction]" === m2(e9);
      }, o$2.isMapIterator = function(e9) {
        return "[object Map Iterator]" === m2(e9);
      }, o$2.isSetIterator = function(e9) {
        return "[object Set Iterator]" === m2(e9);
      }, o$2.isGeneratorObject = function(e9) {
        return "[object Generator]" === m2(e9);
      }, o$2.isWebAssemblyCompiledModule = function(e9) {
        return "[object WebAssembly.Module]" === m2(e9);
      }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e9) {
        return H(e9) || Z(e9) || q(e9) || K(e9) || L(e9);
      }, o$2.isAnyArrayBuffer = function(e9) {
        return l$1 && (V(e9) || _(e9));
      }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e9) {
        Object.defineProperty(o$2, e9, { enumerable: false, value: function() {
          throw new Error(e9 + " is not supported in userland");
        } });
      });
      Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
      X = {};
      Y = T;
      ee = Object.getOwnPropertyDescriptors || function(e9) {
        for (var t8 = Object.keys(e9), r9 = {}, n8 = 0; n8 < t8.length; n8++)
          r9[t8[n8]] = Object.getOwnPropertyDescriptor(e9, t8[n8]);
        return r9;
      };
      te = /%[sdj%]/g;
      X.format = function(e9) {
        if (!ge(e9)) {
          for (var t8 = [], r9 = 0; r9 < arguments.length; r9++)
            t8.push(oe(arguments[r9]));
          return t8.join(" ");
        }
        r9 = 1;
        for (var n8 = arguments, i7 = n8.length, o8 = String(e9).replace(te, function(e10) {
          if ("%%" === e10)
            return "%";
          if (r9 >= i7)
            return e10;
          switch (e10) {
            case "%s":
              return String(n8[r9++]);
            case "%d":
              return Number(n8[r9++]);
            case "%j":
              try {
                return JSON.stringify(n8[r9++]);
              } catch (e11) {
                return "[Circular]";
              }
            default:
              return e10;
          }
        }), u7 = n8[r9]; r9 < i7; u7 = n8[++r9])
          le(u7) || !he(u7) ? o8 += " " + u7 : o8 += " " + oe(u7);
        return o8;
      }, X.deprecate = function(e9, t8) {
        if (void 0 !== Y && true === Y.noDeprecation)
          return e9;
        if (void 0 === Y)
          return function() {
            return X.deprecate(e9, t8).apply(this || Q, arguments);
          };
        var r9 = false;
        return function() {
          if (!r9) {
            if (Y.throwDeprecation)
              throw new Error(t8);
            Y.traceDeprecation ? console.trace(t8) : console.error(t8), r9 = true;
          }
          return e9.apply(this || Q, arguments);
        };
      };
      re = {};
      ne = /^$/;
      if (Y.env.NODE_DEBUG) {
        ie = Y.env.NODE_DEBUG;
        ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
      }
      X.debuglog = function(e9) {
        if (e9 = e9.toUpperCase(), !re[e9])
          if (ne.test(e9)) {
            var t8 = Y.pid;
            re[e9] = function() {
              var r9 = X.format.apply(X, arguments);
              console.error("%s %d: %s", e9, t8, r9);
            };
          } else
            re[e9] = function() {
            };
        return re[e9];
      }, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e9) {
        return null == e9;
      }, X.isNumber = de, X.isString = ge, X.isSymbol = function(e9) {
        return "symbol" == typeof e9;
      }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e9) {
        return null === e9 || "boolean" == typeof e9 || "number" == typeof e9 || "string" == typeof e9 || "symbol" == typeof e9 || void 0 === e9;
      }, X.isBuffer = i$1;
      Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      X.log = function() {
        console.log("%s - %s", Be(), X.format.apply(X, arguments));
      }, X.inherits = t$2, X._extend = function(e9, t8) {
        if (!t8 || !he(t8))
          return e9;
        for (var r9 = Object.keys(t8), n8 = r9.length; n8--; )
          e9[r9[n8]] = t8[r9[n8]];
        return e9;
      };
      Ee = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
      X.promisify = function(e9) {
        if ("function" != typeof e9)
          throw new TypeError('The "original" argument must be of type Function');
        if (Ee && e9[Ee]) {
          var t8;
          if ("function" != typeof (t8 = e9[Ee]))
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty(t8, Ee, { value: t8, enumerable: false, writable: false, configurable: true }), t8;
        }
        function t8() {
          for (var t9, r9, n8 = new Promise(function(e10, n9) {
            t9 = e10, r9 = n9;
          }), i7 = [], o8 = 0; o8 < arguments.length; o8++)
            i7.push(arguments[o8]);
          i7.push(function(e10, n9) {
            e10 ? r9(e10) : t9(n9);
          });
          try {
            e9.apply(this || Q, i7);
          } catch (e10) {
            r9(e10);
          }
          return n8;
        }
        return Object.setPrototypeOf(t8, Object.getPrototypeOf(e9)), Ee && Object.defineProperty(t8, Ee, { value: t8, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t8, ee(e9));
      }, X.promisify.custom = Ee, X.callbackify = function(e9) {
        if ("function" != typeof e9)
          throw new TypeError('The "original" argument must be of type Function');
        function t8() {
          for (var t9 = [], r9 = 0; r9 < arguments.length; r9++)
            t9.push(arguments[r9]);
          var n8 = t9.pop();
          if ("function" != typeof n8)
            throw new TypeError("The last argument must be of type Function");
          var i7 = this || Q, o8 = function() {
            return n8.apply(i7, arguments);
          };
          e9.apply(this || Q, t9).then(function(e10) {
            Y.nextTick(o8.bind(null, null, e10));
          }, function(e10) {
            Y.nextTick(De.bind(null, e10, o8));
          });
        }
        return Object.setPrototypeOf(t8, Object.getPrototypeOf(e9)), Object.defineProperties(t8, ee(e9)), t8;
      };
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-ce0fbc82.js
  var _extend, callbackify, debuglog, deprecate, format, inherits, inspect, isArray4, isBoolean, isBuffer, isDate, isError, isFunction2, isNull, isNullOrUndefined, isNumber, isObject, isPrimitive, isRegExp, isString, isSymbol, isUndefined, log, promisify, types, TextEncoder2, TextDecoder2;
  var init_chunk_ce0fbc82 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-ce0fbc82.js"() {
      init_dirname();
      init_buffer2();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      X._extend;
      X.callbackify;
      X.debuglog;
      X.deprecate;
      X.format;
      X.inherits;
      X.inspect;
      X.isArray;
      X.isBoolean;
      X.isBuffer;
      X.isDate;
      X.isError;
      X.isFunction;
      X.isNull;
      X.isNullOrUndefined;
      X.isNumber;
      X.isObject;
      X.isPrimitive;
      X.isRegExp;
      X.isString;
      X.isSymbol;
      X.isUndefined;
      X.log;
      X.promisify;
      _extend = X._extend;
      callbackify = X.callbackify;
      debuglog = X.debuglog;
      deprecate = X.deprecate;
      format = X.format;
      inherits = X.inherits;
      inspect = X.inspect;
      isArray4 = X.isArray;
      isBoolean = X.isBoolean;
      isBuffer = X.isBuffer;
      isDate = X.isDate;
      isError = X.isError;
      isFunction2 = X.isFunction;
      isNull = X.isNull;
      isNullOrUndefined = X.isNullOrUndefined;
      isNumber = X.isNumber;
      isObject = X.isObject;
      isPrimitive = X.isPrimitive;
      isRegExp = X.isRegExp;
      isString = X.isString;
      isSymbol = X.isSymbol;
      isUndefined = X.isUndefined;
      log = X.log;
      promisify = X.promisify;
      types = X.types;
      TextEncoder2 = self.TextEncoder;
      TextDecoder2 = self.TextDecoder;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js
  function dew2() {
    if (_dewExec2)
      return exports2;
    _dewExec2 = true;
    var process4 = exports2 = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e9) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e9) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e9) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e10) {
          return cachedSetTimeout.call(this || _global, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e9) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e10) {
          return cachedClearTimeout.call(this || _global, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout2 = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout2);
    }
    process4.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i7 = 1; i7 < arguments.length; i7++) {
          args[i7 - 1] = arguments[i7];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      (this || _global).fun = fun;
      (this || _global).array = array;
    }
    Item.prototype.run = function() {
      (this || _global).fun.apply(null, (this || _global).array);
    };
    process4.title = "browser";
    process4.browser = true;
    process4.env = {};
    process4.argv = [];
    process4.version = "";
    process4.versions = {};
    function noop2() {
    }
    process4.on = noop2;
    process4.addListener = noop2;
    process4.once = noop2;
    process4.off = noop2;
    process4.removeListener = noop2;
    process4.removeAllListeners = noop2;
    process4.emit = noop2;
    process4.prependListener = noop2;
    process4.prependOnceListener = noop2;
    process4.listeners = function(name2) {
      return [];
    };
    process4.binding = function(name2) {
      throw new Error("process.binding is not supported");
    };
    process4.cwd = function() {
      return "/";
    };
    process4.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process4.umask = function() {
      return 0;
    };
    return exports2;
  }
  var exports2, _dewExec2, _global, process3;
  var init_chunk_2eac56ff = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js"() {
      init_dirname();
      init_buffer2();
      exports2 = {};
      _dewExec2 = false;
      _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      process3 = dew2();
      process3.platform = "browser";
      process3.addListener;
      process3.argv;
      process3.binding;
      process3.browser;
      process3.chdir;
      process3.cwd;
      process3.emit;
      process3.env;
      process3.listeners;
      process3.nextTick;
      process3.off;
      process3.on;
      process3.once;
      process3.prependListener;
      process3.prependOnceListener;
      process3.removeAllListeners;
      process3.removeListener;
      process3.title;
      process3.umask;
      process3.version;
      process3.versions;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js
  function u$2(r9) {
    var t8 = r9.length;
    if (t8 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var e9 = r9.indexOf("=");
    return -1 === e9 && (e9 = t8), [e9, e9 === t8 ? 0 : 4 - e9 % 4];
  }
  function c$12(r9, e9, n8) {
    for (var o8, a7, h8 = [], u7 = e9; u7 < n8; u7 += 3)
      o8 = (r9[u7] << 16 & 16711680) + (r9[u7 + 1] << 8 & 65280) + (255 & r9[u7 + 2]), h8.push(t$13[(a7 = o8) >> 18 & 63] + t$13[a7 >> 12 & 63] + t$13[a7 >> 6 & 63] + t$13[63 & a7]);
    return h8.join("");
  }
  function f$2(t8) {
    if (t8 > 2147483647)
      throw new RangeError('The value "' + t8 + '" is invalid for option "size"');
    var r9 = new Uint8Array(t8);
    return Object.setPrototypeOf(r9, u$1$1.prototype), r9;
  }
  function u$1$1(t8, r9, e9) {
    if ("number" == typeof t8) {
      if ("string" == typeof r9)
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return a$2(t8);
    }
    return s$1(t8, r9, e9);
  }
  function s$1(t8, r9, e9) {
    if ("string" == typeof t8)
      return function(t9, r10) {
        "string" == typeof r10 && "" !== r10 || (r10 = "utf8");
        if (!u$1$1.isEncoding(r10))
          throw new TypeError("Unknown encoding: " + r10);
        var e10 = 0 | y3(t9, r10), n9 = f$2(e10), i8 = n9.write(t9, r10);
        i8 !== e10 && (n9 = n9.slice(0, i8));
        return n9;
      }(t8, r9);
    if (ArrayBuffer.isView(t8))
      return p4(t8);
    if (null == t8)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t8);
    if (F2(t8, ArrayBuffer) || t8 && F2(t8.buffer, ArrayBuffer))
      return c$1$1(t8, r9, e9);
    if ("undefined" != typeof SharedArrayBuffer && (F2(t8, SharedArrayBuffer) || t8 && F2(t8.buffer, SharedArrayBuffer)))
      return c$1$1(t8, r9, e9);
    if ("number" == typeof t8)
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    var n8 = t8.valueOf && t8.valueOf();
    if (null != n8 && n8 !== t8)
      return u$1$1.from(n8, r9, e9);
    var i7 = function(t9) {
      if (u$1$1.isBuffer(t9)) {
        var r10 = 0 | l$12(t9.length), e10 = f$2(r10);
        return 0 === e10.length || t9.copy(e10, 0, 0, r10), e10;
      }
      if (void 0 !== t9.length)
        return "number" != typeof t9.length || N2(t9.length) ? f$2(0) : p4(t9);
      if ("Buffer" === t9.type && Array.isArray(t9.data))
        return p4(t9.data);
    }(t8);
    if (i7)
      return i7;
    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t8[Symbol.toPrimitive])
      return u$1$1.from(t8[Symbol.toPrimitive]("string"), r9, e9);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t8);
  }
  function h$1$1(t8) {
    if ("number" != typeof t8)
      throw new TypeError('"size" argument must be of type number');
    if (t8 < 0)
      throw new RangeError('The value "' + t8 + '" is invalid for option "size"');
  }
  function a$2(t8) {
    return h$1$1(t8), f$2(t8 < 0 ? 0 : 0 | l$12(t8));
  }
  function p4(t8) {
    for (var r9 = t8.length < 0 ? 0 : 0 | l$12(t8.length), e9 = f$2(r9), n8 = 0; n8 < r9; n8 += 1)
      e9[n8] = 255 & t8[n8];
    return e9;
  }
  function c$1$1(t8, r9, e9) {
    if (r9 < 0 || t8.byteLength < r9)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (t8.byteLength < r9 + (e9 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var n8;
    return n8 = void 0 === r9 && void 0 === e9 ? new Uint8Array(t8) : void 0 === e9 ? new Uint8Array(t8, r9) : new Uint8Array(t8, r9, e9), Object.setPrototypeOf(n8, u$1$1.prototype), n8;
  }
  function l$12(t8) {
    if (t8 >= 2147483647)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
    return 0 | t8;
  }
  function y3(t8, r9) {
    if (u$1$1.isBuffer(t8))
      return t8.length;
    if (ArrayBuffer.isView(t8) || F2(t8, ArrayBuffer))
      return t8.byteLength;
    if ("string" != typeof t8)
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t8);
    var e9 = t8.length, n8 = arguments.length > 2 && true === arguments[2];
    if (!n8 && 0 === e9)
      return 0;
    for (var i7 = false; ; )
      switch (r9) {
        case "ascii":
        case "latin1":
        case "binary":
          return e9;
        case "utf8":
        case "utf-8":
          return _2(t8).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * e9;
        case "hex":
          return e9 >>> 1;
        case "base64":
          return z2(t8).length;
        default:
          if (i7)
            return n8 ? -1 : _2(t8).length;
          r9 = ("" + r9).toLowerCase(), i7 = true;
      }
  }
  function g2(t8, r9, e9) {
    var n8 = false;
    if ((void 0 === r9 || r9 < 0) && (r9 = 0), r9 > this.length)
      return "";
    if ((void 0 === e9 || e9 > this.length) && (e9 = this.length), e9 <= 0)
      return "";
    if ((e9 >>>= 0) <= (r9 >>>= 0))
      return "";
    for (t8 || (t8 = "utf8"); ; )
      switch (t8) {
        case "hex":
          return O2(this, r9, e9);
        case "utf8":
        case "utf-8":
          return I2(this, r9, e9);
        case "ascii":
          return S2(this, r9, e9);
        case "latin1":
        case "binary":
          return R2(this, r9, e9);
        case "base64":
          return T3(this, r9, e9);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return L2(this, r9, e9);
        default:
          if (n8)
            throw new TypeError("Unknown encoding: " + t8);
          t8 = (t8 + "").toLowerCase(), n8 = true;
      }
  }
  function w2(t8, r9, e9) {
    var n8 = t8[r9];
    t8[r9] = t8[e9], t8[e9] = n8;
  }
  function d3(t8, r9, e9, n8, i7) {
    if (0 === t8.length)
      return -1;
    if ("string" == typeof e9 ? (n8 = e9, e9 = 0) : e9 > 2147483647 ? e9 = 2147483647 : e9 < -2147483648 && (e9 = -2147483648), N2(e9 = +e9) && (e9 = i7 ? 0 : t8.length - 1), e9 < 0 && (e9 = t8.length + e9), e9 >= t8.length) {
      if (i7)
        return -1;
      e9 = t8.length - 1;
    } else if (e9 < 0) {
      if (!i7)
        return -1;
      e9 = 0;
    }
    if ("string" == typeof r9 && (r9 = u$1$1.from(r9, n8)), u$1$1.isBuffer(r9))
      return 0 === r9.length ? -1 : v3(t8, r9, e9, n8, i7);
    if ("number" == typeof r9)
      return r9 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i7 ? Uint8Array.prototype.indexOf.call(t8, r9, e9) : Uint8Array.prototype.lastIndexOf.call(t8, r9, e9) : v3(t8, [r9], e9, n8, i7);
    throw new TypeError("val must be string, number or Buffer");
  }
  function v3(t8, r9, e9, n8, i7) {
    var o8, f7 = 1, u7 = t8.length, s6 = r9.length;
    if (void 0 !== n8 && ("ucs2" === (n8 = String(n8).toLowerCase()) || "ucs-2" === n8 || "utf16le" === n8 || "utf-16le" === n8)) {
      if (t8.length < 2 || r9.length < 2)
        return -1;
      f7 = 2, u7 /= 2, s6 /= 2, e9 /= 2;
    }
    function h8(t9, r10) {
      return 1 === f7 ? t9[r10] : t9.readUInt16BE(r10 * f7);
    }
    if (i7) {
      var a7 = -1;
      for (o8 = e9; o8 < u7; o8++)
        if (h8(t8, o8) === h8(r9, -1 === a7 ? 0 : o8 - a7)) {
          if (-1 === a7 && (a7 = o8), o8 - a7 + 1 === s6)
            return a7 * f7;
        } else
          -1 !== a7 && (o8 -= o8 - a7), a7 = -1;
    } else
      for (e9 + s6 > u7 && (e9 = u7 - s6), o8 = e9; o8 >= 0; o8--) {
        for (var p7 = true, c7 = 0; c7 < s6; c7++)
          if (h8(t8, o8 + c7) !== h8(r9, c7)) {
            p7 = false;
            break;
          }
        if (p7)
          return o8;
      }
    return -1;
  }
  function b2(t8, r9, e9, n8) {
    e9 = Number(e9) || 0;
    var i7 = t8.length - e9;
    n8 ? (n8 = Number(n8)) > i7 && (n8 = i7) : n8 = i7;
    var o8 = r9.length;
    n8 > o8 / 2 && (n8 = o8 / 2);
    for (var f7 = 0; f7 < n8; ++f7) {
      var u7 = parseInt(r9.substr(2 * f7, 2), 16);
      if (N2(u7))
        return f7;
      t8[e9 + f7] = u7;
    }
    return f7;
  }
  function m3(t8, r9, e9, n8) {
    return D2(_2(r9, t8.length - e9), t8, e9, n8);
  }
  function E2(t8, r9, e9, n8) {
    return D2(function(t9) {
      for (var r10 = [], e10 = 0; e10 < t9.length; ++e10)
        r10.push(255 & t9.charCodeAt(e10));
      return r10;
    }(r9), t8, e9, n8);
  }
  function B2(t8, r9, e9, n8) {
    return E2(t8, r9, e9, n8);
  }
  function A2(t8, r9, e9, n8) {
    return D2(z2(r9), t8, e9, n8);
  }
  function U2(t8, r9, e9, n8) {
    return D2(function(t9, r10) {
      for (var e10, n9, i7, o8 = [], f7 = 0; f7 < t9.length && !((r10 -= 2) < 0); ++f7)
        e10 = t9.charCodeAt(f7), n9 = e10 >> 8, i7 = e10 % 256, o8.push(i7), o8.push(n9);
      return o8;
    }(r9, t8.length - e9), t8, e9, n8);
  }
  function T3(t8, r9, e9) {
    return 0 === r9 && e9 === t8.length ? n$1$1.fromByteArray(t8) : n$1$1.fromByteArray(t8.slice(r9, e9));
  }
  function I2(t8, r9, e9) {
    e9 = Math.min(t8.length, e9);
    for (var n8 = [], i7 = r9; i7 < e9; ) {
      var o8, f7, u7, s6, h8 = t8[i7], a7 = null, p7 = h8 > 239 ? 4 : h8 > 223 ? 3 : h8 > 191 ? 2 : 1;
      if (i7 + p7 <= e9)
        switch (p7) {
          case 1:
            h8 < 128 && (a7 = h8);
            break;
          case 2:
            128 == (192 & (o8 = t8[i7 + 1])) && (s6 = (31 & h8) << 6 | 63 & o8) > 127 && (a7 = s6);
            break;
          case 3:
            o8 = t8[i7 + 1], f7 = t8[i7 + 2], 128 == (192 & o8) && 128 == (192 & f7) && (s6 = (15 & h8) << 12 | (63 & o8) << 6 | 63 & f7) > 2047 && (s6 < 55296 || s6 > 57343) && (a7 = s6);
            break;
          case 4:
            o8 = t8[i7 + 1], f7 = t8[i7 + 2], u7 = t8[i7 + 3], 128 == (192 & o8) && 128 == (192 & f7) && 128 == (192 & u7) && (s6 = (15 & h8) << 18 | (63 & o8) << 12 | (63 & f7) << 6 | 63 & u7) > 65535 && s6 < 1114112 && (a7 = s6);
        }
      null === a7 ? (a7 = 65533, p7 = 1) : a7 > 65535 && (a7 -= 65536, n8.push(a7 >>> 10 & 1023 | 55296), a7 = 56320 | 1023 & a7), n8.push(a7), i7 += p7;
    }
    return function(t9) {
      var r10 = t9.length;
      if (r10 <= 4096)
        return String.fromCharCode.apply(String, t9);
      var e10 = "", n9 = 0;
      for (; n9 < r10; )
        e10 += String.fromCharCode.apply(String, t9.slice(n9, n9 += 4096));
      return e10;
    }(n8);
  }
  function S2(t8, r9, e9) {
    var n8 = "";
    e9 = Math.min(t8.length, e9);
    for (var i7 = r9; i7 < e9; ++i7)
      n8 += String.fromCharCode(127 & t8[i7]);
    return n8;
  }
  function R2(t8, r9, e9) {
    var n8 = "";
    e9 = Math.min(t8.length, e9);
    for (var i7 = r9; i7 < e9; ++i7)
      n8 += String.fromCharCode(t8[i7]);
    return n8;
  }
  function O2(t8, r9, e9) {
    var n8 = t8.length;
    (!r9 || r9 < 0) && (r9 = 0), (!e9 || e9 < 0 || e9 > n8) && (e9 = n8);
    for (var i7 = "", o8 = r9; o8 < e9; ++o8)
      i7 += Y2[t8[o8]];
    return i7;
  }
  function L2(t8, r9, e9) {
    for (var n8 = t8.slice(r9, e9), i7 = "", o8 = 0; o8 < n8.length; o8 += 2)
      i7 += String.fromCharCode(n8[o8] + 256 * n8[o8 + 1]);
    return i7;
  }
  function x2(t8, r9, e9) {
    if (t8 % 1 != 0 || t8 < 0)
      throw new RangeError("offset is not uint");
    if (t8 + r9 > e9)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function C2(t8, r9, e9, n8, i7, o8) {
    if (!u$1$1.isBuffer(t8))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r9 > i7 || r9 < o8)
      throw new RangeError('"value" argument is out of bounds');
    if (e9 + n8 > t8.length)
      throw new RangeError("Index out of range");
  }
  function P2(t8, r9, e9, n8, i7, o8) {
    if (e9 + n8 > t8.length)
      throw new RangeError("Index out of range");
    if (e9 < 0)
      throw new RangeError("Index out of range");
  }
  function k2(t8, r9, e9, n8, o8) {
    return r9 = +r9, e9 >>>= 0, o8 || P2(t8, 0, e9, 4), i$12.write(t8, r9, e9, n8, 23, 4), e9 + 4;
  }
  function M2(t8, r9, e9, n8, o8) {
    return r9 = +r9, e9 >>>= 0, o8 || P2(t8, 0, e9, 8), i$12.write(t8, r9, e9, n8, 52, 8), e9 + 8;
  }
  function _2(t8, r9) {
    var e9;
    r9 = r9 || 1 / 0;
    for (var n8 = t8.length, i7 = null, o8 = [], f7 = 0; f7 < n8; ++f7) {
      if ((e9 = t8.charCodeAt(f7)) > 55295 && e9 < 57344) {
        if (!i7) {
          if (e9 > 56319) {
            (r9 -= 3) > -1 && o8.push(239, 191, 189);
            continue;
          }
          if (f7 + 1 === n8) {
            (r9 -= 3) > -1 && o8.push(239, 191, 189);
            continue;
          }
          i7 = e9;
          continue;
        }
        if (e9 < 56320) {
          (r9 -= 3) > -1 && o8.push(239, 191, 189), i7 = e9;
          continue;
        }
        e9 = 65536 + (i7 - 55296 << 10 | e9 - 56320);
      } else
        i7 && (r9 -= 3) > -1 && o8.push(239, 191, 189);
      if (i7 = null, e9 < 128) {
        if ((r9 -= 1) < 0)
          break;
        o8.push(e9);
      } else if (e9 < 2048) {
        if ((r9 -= 2) < 0)
          break;
        o8.push(e9 >> 6 | 192, 63 & e9 | 128);
      } else if (e9 < 65536) {
        if ((r9 -= 3) < 0)
          break;
        o8.push(e9 >> 12 | 224, e9 >> 6 & 63 | 128, 63 & e9 | 128);
      } else {
        if (!(e9 < 1114112))
          throw new Error("Invalid code point");
        if ((r9 -= 4) < 0)
          break;
        o8.push(e9 >> 18 | 240, e9 >> 12 & 63 | 128, e9 >> 6 & 63 | 128, 63 & e9 | 128);
      }
    }
    return o8;
  }
  function z2(t8) {
    return n$1$1.toByteArray(function(t9) {
      if ((t9 = (t9 = t9.split("=")[0]).trim().replace(j2, "")).length < 2)
        return "";
      for (; t9.length % 4 != 0; )
        t9 += "=";
      return t9;
    }(t8));
  }
  function D2(t8, r9, e9, n8) {
    for (var i7 = 0; i7 < n8 && !(i7 + e9 >= r9.length || i7 >= t8.length); ++i7)
      r9[i7 + e9] = t8[i7];
    return i7;
  }
  function F2(t8, r9) {
    return t8 instanceof r9 || null != t8 && null != t8.constructor && null != t8.constructor.name && t8.constructor.name === r9.name;
  }
  function N2(t8) {
    return t8 != t8;
  }
  function t4(r9, e9) {
    for (var n8 in r9)
      e9[n8] = r9[n8];
  }
  function f4(r9, e9, n8) {
    return o4(r9, e9, n8);
  }
  function a4(t8) {
    var e9;
    switch (this.encoding = function(t9) {
      var e10 = function(t10) {
        if (!t10)
          return "utf8";
        for (var e11; ; )
          switch (t10) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return t10;
            default:
              if (e11)
                return;
              t10 = ("" + t10).toLowerCase(), e11 = true;
          }
      }(t9);
      if ("string" != typeof e10 && (s4.isEncoding === i4 || !i4(t9)))
        throw new Error("Unknown encoding: " + t9);
      return e10 || t9;
    }(t8), this.encoding) {
      case "utf16le":
        this.text = h4, this.end = l4, e9 = 4;
        break;
      case "utf8":
        this.fillLast = n$12, e9 = 4;
        break;
      case "base64":
        this.text = u$12, this.end = o$12, e9 = 3;
        break;
      default:
        return this.write = f$1, this.end = c4, void 0;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s4.allocUnsafe(e9);
  }
  function r4(t8) {
    return t8 <= 127 ? 0 : t8 >> 5 == 6 ? 2 : t8 >> 4 == 14 ? 3 : t8 >> 3 == 30 ? 4 : t8 >> 6 == 2 ? -1 : -2;
  }
  function n$12(t8) {
    var e9 = this.lastTotal - this.lastNeed, s6 = function(t9, e10, s7) {
      if (128 != (192 & e10[0]))
        return t9.lastNeed = 0, "\uFFFD";
      if (t9.lastNeed > 1 && e10.length > 1) {
        if (128 != (192 & e10[1]))
          return t9.lastNeed = 1, "\uFFFD";
        if (t9.lastNeed > 2 && e10.length > 2 && 128 != (192 & e10[2]))
          return t9.lastNeed = 2, "\uFFFD";
      }
    }(this, t8);
    return void 0 !== s6 ? s6 : this.lastNeed <= t8.length ? (t8.copy(this.lastChar, e9, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t8.copy(this.lastChar, e9, 0, t8.length), this.lastNeed -= t8.length, void 0);
  }
  function h4(t8, e9) {
    if ((t8.length - e9) % 2 == 0) {
      var s6 = t8.toString("utf16le", e9);
      if (s6) {
        var i7 = s6.charCodeAt(s6.length - 1);
        if (i7 >= 55296 && i7 <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t8[t8.length - 2], this.lastChar[1] = t8[t8.length - 1], s6.slice(0, -1);
      }
      return s6;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t8[t8.length - 1], t8.toString("utf16le", e9, t8.length - 1);
  }
  function l4(t8) {
    var e9 = t8 && t8.length ? this.write(t8) : "";
    if (this.lastNeed) {
      var s6 = this.lastTotal - this.lastNeed;
      return e9 + this.lastChar.toString("utf16le", 0, s6);
    }
    return e9;
  }
  function u$12(t8, e9) {
    var s6 = (t8.length - e9) % 3;
    return 0 === s6 ? t8.toString("base64", e9) : (this.lastNeed = 3 - s6, this.lastTotal = 3, 1 === s6 ? this.lastChar[0] = t8[t8.length - 1] : (this.lastChar[0] = t8[t8.length - 2], this.lastChar[1] = t8[t8.length - 1]), t8.toString("base64", e9, t8.length - s6));
  }
  function o$12(t8) {
    var e9 = t8 && t8.length ? this.write(t8) : "";
    return this.lastNeed ? e9 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e9;
  }
  function f$1(t8) {
    return t8.toString(this.encoding);
  }
  function c4(t8) {
    return t8 && t8.length ? this.write(t8) : "";
  }
  var r$13, t$13, e$22, n$22, o$23, a$12, h$12, a$1$1, e$1$1, n$1$1, i$12, o$1$1, j2, Y2, e4, n4, o4, u4, e$12, s4, i4;
  var init_chunk_4ccc3a29 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js"() {
      init_dirname();
      init_buffer2();
      for (r$13 = { byteLength: function(r9) {
        var t8 = u$2(r9), e9 = t8[0], n8 = t8[1];
        return 3 * (e9 + n8) / 4 - n8;
      }, toByteArray: function(r9) {
        var t8, o8, a7 = u$2(r9), h8 = a7[0], c7 = a7[1], d6 = new n$22(function(r10, t9, e9) {
          return 3 * (t9 + e9) / 4 - e9;
        }(0, h8, c7)), f7 = 0, A4 = c7 > 0 ? h8 - 4 : h8;
        for (o8 = 0; o8 < A4; o8 += 4)
          t8 = e$22[r9.charCodeAt(o8)] << 18 | e$22[r9.charCodeAt(o8 + 1)] << 12 | e$22[r9.charCodeAt(o8 + 2)] << 6 | e$22[r9.charCodeAt(o8 + 3)], d6[f7++] = t8 >> 16 & 255, d6[f7++] = t8 >> 8 & 255, d6[f7++] = 255 & t8;
        2 === c7 && (t8 = e$22[r9.charCodeAt(o8)] << 2 | e$22[r9.charCodeAt(o8 + 1)] >> 4, d6[f7++] = 255 & t8);
        1 === c7 && (t8 = e$22[r9.charCodeAt(o8)] << 10 | e$22[r9.charCodeAt(o8 + 1)] << 4 | e$22[r9.charCodeAt(o8 + 2)] >> 2, d6[f7++] = t8 >> 8 & 255, d6[f7++] = 255 & t8);
        return d6;
      }, fromByteArray: function(r9) {
        for (var e9, n8 = r9.length, o8 = n8 % 3, a7 = [], h8 = 0, u7 = n8 - o8; h8 < u7; h8 += 16383)
          a7.push(c$12(r9, h8, h8 + 16383 > u7 ? u7 : h8 + 16383));
        1 === o8 ? (e9 = r9[n8 - 1], a7.push(t$13[e9 >> 2] + t$13[e9 << 4 & 63] + "==")) : 2 === o8 && (e9 = (r9[n8 - 2] << 8) + r9[n8 - 1], a7.push(t$13[e9 >> 10] + t$13[e9 >> 4 & 63] + t$13[e9 << 2 & 63] + "="));
        return a7.join("");
      } }, t$13 = [], e$22 = [], n$22 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$23 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$12 = 0, h$12 = o$23.length; a$12 < h$12; ++a$12)
        t$13[a$12] = o$23[a$12], e$22[o$23.charCodeAt(a$12)] = a$12;
      e$22["-".charCodeAt(0)] = 62, e$22["_".charCodeAt(0)] = 63;
      a$1$1 = { read: function(a7, t8, o8, r9, h8) {
        var M4, f7, p7 = 8 * h8 - r9 - 1, w4 = (1 << p7) - 1, e9 = w4 >> 1, i7 = -7, N4 = o8 ? h8 - 1 : 0, n8 = o8 ? -1 : 1, u7 = a7[t8 + N4];
        for (N4 += n8, M4 = u7 & (1 << -i7) - 1, u7 >>= -i7, i7 += p7; i7 > 0; M4 = 256 * M4 + a7[t8 + N4], N4 += n8, i7 -= 8)
          ;
        for (f7 = M4 & (1 << -i7) - 1, M4 >>= -i7, i7 += r9; i7 > 0; f7 = 256 * f7 + a7[t8 + N4], N4 += n8, i7 -= 8)
          ;
        if (0 === M4)
          M4 = 1 - e9;
        else {
          if (M4 === w4)
            return f7 ? NaN : 1 / 0 * (u7 ? -1 : 1);
          f7 += Math.pow(2, r9), M4 -= e9;
        }
        return (u7 ? -1 : 1) * f7 * Math.pow(2, M4 - r9);
      }, write: function(a7, t8, o8, r9, h8, M4) {
        var f7, p7, w4, e9 = 8 * M4 - h8 - 1, i7 = (1 << e9) - 1, N4 = i7 >> 1, n8 = 23 === h8 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u7 = r9 ? 0 : M4 - 1, l7 = r9 ? 1 : -1, s6 = t8 < 0 || 0 === t8 && 1 / t8 < 0 ? 1 : 0;
        for (t8 = Math.abs(t8), isNaN(t8) || t8 === 1 / 0 ? (p7 = isNaN(t8) ? 1 : 0, f7 = i7) : (f7 = Math.floor(Math.log(t8) / Math.LN2), t8 * (w4 = Math.pow(2, -f7)) < 1 && (f7--, w4 *= 2), (t8 += f7 + N4 >= 1 ? n8 / w4 : n8 * Math.pow(2, 1 - N4)) * w4 >= 2 && (f7++, w4 /= 2), f7 + N4 >= i7 ? (p7 = 0, f7 = i7) : f7 + N4 >= 1 ? (p7 = (t8 * w4 - 1) * Math.pow(2, h8), f7 += N4) : (p7 = t8 * Math.pow(2, N4 - 1) * Math.pow(2, h8), f7 = 0)); h8 >= 8; a7[o8 + u7] = 255 & p7, u7 += l7, p7 /= 256, h8 -= 8)
          ;
        for (f7 = f7 << h8 | p7, e9 += h8; e9 > 0; a7[o8 + u7] = 255 & f7, u7 += l7, f7 /= 256, e9 -= 8)
          ;
        a7[o8 + u7 - l7] |= 128 * s6;
      } };
      e$1$1 = {};
      n$1$1 = r$13;
      i$12 = a$1$1;
      o$1$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
      e$1$1.Buffer = u$1$1, e$1$1.SlowBuffer = function(t8) {
        +t8 != t8 && (t8 = 0);
        return u$1$1.alloc(+t8);
      }, e$1$1.INSPECT_MAX_BYTES = 50;
      e$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
        try {
          var t8 = new Uint8Array(1), r9 = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(r9, Uint8Array.prototype), Object.setPrototypeOf(t8, r9), 42 === t8.foo();
        } catch (t9) {
          return false;
        }
      }(), u$1$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$1.prototype, "parent", { enumerable: true, get: function() {
        if (u$1$1.isBuffer(this))
          return this.buffer;
      } }), Object.defineProperty(u$1$1.prototype, "offset", { enumerable: true, get: function() {
        if (u$1$1.isBuffer(this))
          return this.byteOffset;
      } }), u$1$1.poolSize = 8192, u$1$1.from = function(t8, r9, e9) {
        return s$1(t8, r9, e9);
      }, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function(t8, r9, e9) {
        return function(t9, r10, e10) {
          return h$1$1(t9), t9 <= 0 ? f$2(t9) : void 0 !== r10 ? "string" == typeof e10 ? f$2(t9).fill(r10, e10) : f$2(t9).fill(r10) : f$2(t9);
        }(t8, r9, e9);
      }, u$1$1.allocUnsafe = function(t8) {
        return a$2(t8);
      }, u$1$1.allocUnsafeSlow = function(t8) {
        return a$2(t8);
      }, u$1$1.isBuffer = function(t8) {
        return null != t8 && true === t8._isBuffer && t8 !== u$1$1.prototype;
      }, u$1$1.compare = function(t8, r9) {
        if (F2(t8, Uint8Array) && (t8 = u$1$1.from(t8, t8.offset, t8.byteLength)), F2(r9, Uint8Array) && (r9 = u$1$1.from(r9, r9.offset, r9.byteLength)), !u$1$1.isBuffer(t8) || !u$1$1.isBuffer(r9))
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (t8 === r9)
          return 0;
        for (var e9 = t8.length, n8 = r9.length, i7 = 0, o8 = Math.min(e9, n8); i7 < o8; ++i7)
          if (t8[i7] !== r9[i7]) {
            e9 = t8[i7], n8 = r9[i7];
            break;
          }
        return e9 < n8 ? -1 : n8 < e9 ? 1 : 0;
      }, u$1$1.isEncoding = function(t8) {
        switch (String(t8).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, u$1$1.concat = function(t8, r9) {
        if (!Array.isArray(t8))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t8.length)
          return u$1$1.alloc(0);
        var e9;
        if (void 0 === r9)
          for (r9 = 0, e9 = 0; e9 < t8.length; ++e9)
            r9 += t8[e9].length;
        var n8 = u$1$1.allocUnsafe(r9), i7 = 0;
        for (e9 = 0; e9 < t8.length; ++e9) {
          var o8 = t8[e9];
          if (F2(o8, Uint8Array) && (o8 = u$1$1.from(o8)), !u$1$1.isBuffer(o8))
            throw new TypeError('"list" argument must be an Array of Buffers');
          o8.copy(n8, i7), i7 += o8.length;
        }
        return n8;
      }, u$1$1.byteLength = y3, u$1$1.prototype._isBuffer = true, u$1$1.prototype.swap16 = function() {
        var t8 = this.length;
        if (t8 % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var r9 = 0; r9 < t8; r9 += 2)
          w2(this, r9, r9 + 1);
        return this;
      }, u$1$1.prototype.swap32 = function() {
        var t8 = this.length;
        if (t8 % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var r9 = 0; r9 < t8; r9 += 4)
          w2(this, r9, r9 + 3), w2(this, r9 + 1, r9 + 2);
        return this;
      }, u$1$1.prototype.swap64 = function() {
        var t8 = this.length;
        if (t8 % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var r9 = 0; r9 < t8; r9 += 8)
          w2(this, r9, r9 + 7), w2(this, r9 + 1, r9 + 6), w2(this, r9 + 2, r9 + 5), w2(this, r9 + 3, r9 + 4);
        return this;
      }, u$1$1.prototype.toString = function() {
        var t8 = this.length;
        return 0 === t8 ? "" : 0 === arguments.length ? I2(this, 0, t8) : g2.apply(this, arguments);
      }, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function(t8) {
        if (!u$1$1.isBuffer(t8))
          throw new TypeError("Argument must be a Buffer");
        return this === t8 || 0 === u$1$1.compare(this, t8);
      }, u$1$1.prototype.inspect = function() {
        var t8 = "", r9 = e$1$1.INSPECT_MAX_BYTES;
        return t8 = this.toString("hex", 0, r9).replace(/(.{2})/g, "$1 ").trim(), this.length > r9 && (t8 += " ... "), "<Buffer " + t8 + ">";
      }, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function(t8, r9, e9, n8, i7) {
        if (F2(t8, Uint8Array) && (t8 = u$1$1.from(t8, t8.offset, t8.byteLength)), !u$1$1.isBuffer(t8))
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t8);
        if (void 0 === r9 && (r9 = 0), void 0 === e9 && (e9 = t8 ? t8.length : 0), void 0 === n8 && (n8 = 0), void 0 === i7 && (i7 = this.length), r9 < 0 || e9 > t8.length || n8 < 0 || i7 > this.length)
          throw new RangeError("out of range index");
        if (n8 >= i7 && r9 >= e9)
          return 0;
        if (n8 >= i7)
          return -1;
        if (r9 >= e9)
          return 1;
        if (this === t8)
          return 0;
        for (var o8 = (i7 >>>= 0) - (n8 >>>= 0), f7 = (e9 >>>= 0) - (r9 >>>= 0), s6 = Math.min(o8, f7), h8 = this.slice(n8, i7), a7 = t8.slice(r9, e9), p7 = 0; p7 < s6; ++p7)
          if (h8[p7] !== a7[p7]) {
            o8 = h8[p7], f7 = a7[p7];
            break;
          }
        return o8 < f7 ? -1 : f7 < o8 ? 1 : 0;
      }, u$1$1.prototype.includes = function(t8, r9, e9) {
        return -1 !== this.indexOf(t8, r9, e9);
      }, u$1$1.prototype.indexOf = function(t8, r9, e9) {
        return d3(this, t8, r9, e9, true);
      }, u$1$1.prototype.lastIndexOf = function(t8, r9, e9) {
        return d3(this, t8, r9, e9, false);
      }, u$1$1.prototype.write = function(t8, r9, e9, n8) {
        if (void 0 === r9)
          n8 = "utf8", e9 = this.length, r9 = 0;
        else if (void 0 === e9 && "string" == typeof r9)
          n8 = r9, e9 = this.length, r9 = 0;
        else {
          if (!isFinite(r9))
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          r9 >>>= 0, isFinite(e9) ? (e9 >>>= 0, void 0 === n8 && (n8 = "utf8")) : (n8 = e9, e9 = void 0);
        }
        var i7 = this.length - r9;
        if ((void 0 === e9 || e9 > i7) && (e9 = i7), t8.length > 0 && (e9 < 0 || r9 < 0) || r9 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        n8 || (n8 = "utf8");
        for (var o8 = false; ; )
          switch (n8) {
            case "hex":
              return b2(this, t8, r9, e9);
            case "utf8":
            case "utf-8":
              return m3(this, t8, r9, e9);
            case "ascii":
              return E2(this, t8, r9, e9);
            case "latin1":
            case "binary":
              return B2(this, t8, r9, e9);
            case "base64":
              return A2(this, t8, r9, e9);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return U2(this, t8, r9, e9);
            default:
              if (o8)
                throw new TypeError("Unknown encoding: " + n8);
              n8 = ("" + n8).toLowerCase(), o8 = true;
          }
      }, u$1$1.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      u$1$1.prototype.slice = function(t8, r9) {
        var e9 = this.length;
        (t8 = ~~t8) < 0 ? (t8 += e9) < 0 && (t8 = 0) : t8 > e9 && (t8 = e9), (r9 = void 0 === r9 ? e9 : ~~r9) < 0 ? (r9 += e9) < 0 && (r9 = 0) : r9 > e9 && (r9 = e9), r9 < t8 && (r9 = t8);
        var n8 = this.subarray(t8, r9);
        return Object.setPrototypeOf(n8, u$1$1.prototype), n8;
      }, u$1$1.prototype.readUIntLE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
        for (var n8 = this[t8], i7 = 1, o8 = 0; ++o8 < r9 && (i7 *= 256); )
          n8 += this[t8 + o8] * i7;
        return n8;
      }, u$1$1.prototype.readUIntBE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
        for (var n8 = this[t8 + --r9], i7 = 1; r9 > 0 && (i7 *= 256); )
          n8 += this[t8 + --r9] * i7;
        return n8;
      }, u$1$1.prototype.readUInt8 = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 1, this.length), this[t8];
      }, u$1$1.prototype.readUInt16LE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 2, this.length), this[t8] | this[t8 + 1] << 8;
      }, u$1$1.prototype.readUInt16BE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 2, this.length), this[t8] << 8 | this[t8 + 1];
      }, u$1$1.prototype.readUInt32LE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), (this[t8] | this[t8 + 1] << 8 | this[t8 + 2] << 16) + 16777216 * this[t8 + 3];
      }, u$1$1.prototype.readUInt32BE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), 16777216 * this[t8] + (this[t8 + 1] << 16 | this[t8 + 2] << 8 | this[t8 + 3]);
      }, u$1$1.prototype.readIntLE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
        for (var n8 = this[t8], i7 = 1, o8 = 0; ++o8 < r9 && (i7 *= 256); )
          n8 += this[t8 + o8] * i7;
        return n8 >= (i7 *= 128) && (n8 -= Math.pow(2, 8 * r9)), n8;
      }, u$1$1.prototype.readIntBE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
        for (var n8 = r9, i7 = 1, o8 = this[t8 + --n8]; n8 > 0 && (i7 *= 256); )
          o8 += this[t8 + --n8] * i7;
        return o8 >= (i7 *= 128) && (o8 -= Math.pow(2, 8 * r9)), o8;
      }, u$1$1.prototype.readInt8 = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 1, this.length), 128 & this[t8] ? -1 * (255 - this[t8] + 1) : this[t8];
      }, u$1$1.prototype.readInt16LE = function(t8, r9) {
        t8 >>>= 0, r9 || x2(t8, 2, this.length);
        var e9 = this[t8] | this[t8 + 1] << 8;
        return 32768 & e9 ? 4294901760 | e9 : e9;
      }, u$1$1.prototype.readInt16BE = function(t8, r9) {
        t8 >>>= 0, r9 || x2(t8, 2, this.length);
        var e9 = this[t8 + 1] | this[t8] << 8;
        return 32768 & e9 ? 4294901760 | e9 : e9;
      }, u$1$1.prototype.readInt32LE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), this[t8] | this[t8 + 1] << 8 | this[t8 + 2] << 16 | this[t8 + 3] << 24;
      }, u$1$1.prototype.readInt32BE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), this[t8] << 24 | this[t8 + 1] << 16 | this[t8 + 2] << 8 | this[t8 + 3];
      }, u$1$1.prototype.readFloatLE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), i$12.read(this, t8, true, 23, 4);
      }, u$1$1.prototype.readFloatBE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), i$12.read(this, t8, false, 23, 4);
      }, u$1$1.prototype.readDoubleLE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 8, this.length), i$12.read(this, t8, true, 52, 8);
      }, u$1$1.prototype.readDoubleBE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 8, this.length), i$12.read(this, t8, false, 52, 8);
      }, u$1$1.prototype.writeUIntLE = function(t8, r9, e9, n8) {
        (t8 = +t8, r9 >>>= 0, e9 >>>= 0, n8) || C2(this, t8, r9, e9, Math.pow(2, 8 * e9) - 1, 0);
        var i7 = 1, o8 = 0;
        for (this[r9] = 255 & t8; ++o8 < e9 && (i7 *= 256); )
          this[r9 + o8] = t8 / i7 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeUIntBE = function(t8, r9, e9, n8) {
        (t8 = +t8, r9 >>>= 0, e9 >>>= 0, n8) || C2(this, t8, r9, e9, Math.pow(2, 8 * e9) - 1, 0);
        var i7 = e9 - 1, o8 = 1;
        for (this[r9 + i7] = 255 & t8; --i7 >= 0 && (o8 *= 256); )
          this[r9 + i7] = t8 / o8 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeUInt8 = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 1, 255, 0), this[r9] = 255 & t8, r9 + 1;
      }, u$1$1.prototype.writeUInt16LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 65535, 0), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, r9 + 2;
      }, u$1$1.prototype.writeUInt16BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 65535, 0), this[r9] = t8 >>> 8, this[r9 + 1] = 255 & t8, r9 + 2;
      }, u$1$1.prototype.writeUInt32LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 4294967295, 0), this[r9 + 3] = t8 >>> 24, this[r9 + 2] = t8 >>> 16, this[r9 + 1] = t8 >>> 8, this[r9] = 255 & t8, r9 + 4;
      }, u$1$1.prototype.writeUInt32BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 4294967295, 0), this[r9] = t8 >>> 24, this[r9 + 1] = t8 >>> 16, this[r9 + 2] = t8 >>> 8, this[r9 + 3] = 255 & t8, r9 + 4;
      }, u$1$1.prototype.writeIntLE = function(t8, r9, e9, n8) {
        if (t8 = +t8, r9 >>>= 0, !n8) {
          var i7 = Math.pow(2, 8 * e9 - 1);
          C2(this, t8, r9, e9, i7 - 1, -i7);
        }
        var o8 = 0, f7 = 1, u7 = 0;
        for (this[r9] = 255 & t8; ++o8 < e9 && (f7 *= 256); )
          t8 < 0 && 0 === u7 && 0 !== this[r9 + o8 - 1] && (u7 = 1), this[r9 + o8] = (t8 / f7 >> 0) - u7 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeIntBE = function(t8, r9, e9, n8) {
        if (t8 = +t8, r9 >>>= 0, !n8) {
          var i7 = Math.pow(2, 8 * e9 - 1);
          C2(this, t8, r9, e9, i7 - 1, -i7);
        }
        var o8 = e9 - 1, f7 = 1, u7 = 0;
        for (this[r9 + o8] = 255 & t8; --o8 >= 0 && (f7 *= 256); )
          t8 < 0 && 0 === u7 && 0 !== this[r9 + o8 + 1] && (u7 = 1), this[r9 + o8] = (t8 / f7 >> 0) - u7 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeInt8 = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 1, 127, -128), t8 < 0 && (t8 = 255 + t8 + 1), this[r9] = 255 & t8, r9 + 1;
      }, u$1$1.prototype.writeInt16LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 32767, -32768), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, r9 + 2;
      }, u$1$1.prototype.writeInt16BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 2, 32767, -32768), this[r9] = t8 >>> 8, this[r9 + 1] = 255 & t8, r9 + 2;
      }, u$1$1.prototype.writeInt32LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 2147483647, -2147483648), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, this[r9 + 2] = t8 >>> 16, this[r9 + 3] = t8 >>> 24, r9 + 4;
      }, u$1$1.prototype.writeInt32BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C2(this, t8, r9, 4, 2147483647, -2147483648), t8 < 0 && (t8 = 4294967295 + t8 + 1), this[r9] = t8 >>> 24, this[r9 + 1] = t8 >>> 16, this[r9 + 2] = t8 >>> 8, this[r9 + 3] = 255 & t8, r9 + 4;
      }, u$1$1.prototype.writeFloatLE = function(t8, r9, e9) {
        return k2(this, t8, r9, true, e9);
      }, u$1$1.prototype.writeFloatBE = function(t8, r9, e9) {
        return k2(this, t8, r9, false, e9);
      }, u$1$1.prototype.writeDoubleLE = function(t8, r9, e9) {
        return M2(this, t8, r9, true, e9);
      }, u$1$1.prototype.writeDoubleBE = function(t8, r9, e9) {
        return M2(this, t8, r9, false, e9);
      }, u$1$1.prototype.copy = function(t8, r9, e9, n8) {
        if (!u$1$1.isBuffer(t8))
          throw new TypeError("argument should be a Buffer");
        if (e9 || (e9 = 0), n8 || 0 === n8 || (n8 = this.length), r9 >= t8.length && (r9 = t8.length), r9 || (r9 = 0), n8 > 0 && n8 < e9 && (n8 = e9), n8 === e9)
          return 0;
        if (0 === t8.length || 0 === this.length)
          return 0;
        if (r9 < 0)
          throw new RangeError("targetStart out of bounds");
        if (e9 < 0 || e9 >= this.length)
          throw new RangeError("Index out of range");
        if (n8 < 0)
          throw new RangeError("sourceEnd out of bounds");
        n8 > this.length && (n8 = this.length), t8.length - r9 < n8 - e9 && (n8 = t8.length - r9 + e9);
        var i7 = n8 - e9;
        if (this === t8 && "function" == typeof Uint8Array.prototype.copyWithin)
          this.copyWithin(r9, e9, n8);
        else if (this === t8 && e9 < r9 && r9 < n8)
          for (var o8 = i7 - 1; o8 >= 0; --o8)
            t8[o8 + r9] = this[o8 + e9];
        else
          Uint8Array.prototype.set.call(t8, this.subarray(e9, n8), r9);
        return i7;
      }, u$1$1.prototype.fill = function(t8, r9, e9, n8) {
        if ("string" == typeof t8) {
          if ("string" == typeof r9 ? (n8 = r9, r9 = 0, e9 = this.length) : "string" == typeof e9 && (n8 = e9, e9 = this.length), void 0 !== n8 && "string" != typeof n8)
            throw new TypeError("encoding must be a string");
          if ("string" == typeof n8 && !u$1$1.isEncoding(n8))
            throw new TypeError("Unknown encoding: " + n8);
          if (1 === t8.length) {
            var i7 = t8.charCodeAt(0);
            ("utf8" === n8 && i7 < 128 || "latin1" === n8) && (t8 = i7);
          }
        } else
          "number" == typeof t8 ? t8 &= 255 : "boolean" == typeof t8 && (t8 = Number(t8));
        if (r9 < 0 || this.length < r9 || this.length < e9)
          throw new RangeError("Out of range index");
        if (e9 <= r9)
          return this;
        var o8;
        if (r9 >>>= 0, e9 = void 0 === e9 ? this.length : e9 >>> 0, t8 || (t8 = 0), "number" == typeof t8)
          for (o8 = r9; o8 < e9; ++o8)
            this[o8] = t8;
        else {
          var f7 = u$1$1.isBuffer(t8) ? t8 : u$1$1.from(t8, n8), s6 = f7.length;
          if (0 === s6)
            throw new TypeError('The value "' + t8 + '" is invalid for argument "value"');
          for (o8 = 0; o8 < e9 - r9; ++o8)
            this[o8 + r9] = f7[o8 % s6];
        }
        return this;
      };
      j2 = /[^+/0-9A-Za-z-_]/g;
      Y2 = function() {
        for (var t8 = new Array(256), r9 = 0; r9 < 16; ++r9)
          for (var e9 = 16 * r9, n8 = 0; n8 < 16; ++n8)
            t8[e9 + n8] = "0123456789abcdef"[r9] + "0123456789abcdef"[n8];
        return t8;
      }();
      e$1$1.Buffer;
      e$1$1.INSPECT_MAX_BYTES;
      e$1$1.kMaxLength;
      e4 = {};
      n4 = e$1$1;
      o4 = n4.Buffer;
      o4.from && o4.alloc && o4.allocUnsafe && o4.allocUnsafeSlow ? e4 = n4 : (t4(n4, e4), e4.Buffer = f4), f4.prototype = Object.create(o4.prototype), t4(o4, f4), f4.from = function(r9, e9, n8) {
        if ("number" == typeof r9)
          throw new TypeError("Argument must not be a number");
        return o4(r9, e9, n8);
      }, f4.alloc = function(r9, e9, n8) {
        if ("number" != typeof r9)
          throw new TypeError("Argument must be a number");
        var t8 = o4(r9);
        return void 0 !== e9 ? "string" == typeof n8 ? t8.fill(e9, n8) : t8.fill(e9) : t8.fill(0), t8;
      }, f4.allocUnsafe = function(r9) {
        if ("number" != typeof r9)
          throw new TypeError("Argument must be a number");
        return o4(r9);
      }, f4.allocUnsafeSlow = function(r9) {
        if ("number" != typeof r9)
          throw new TypeError("Argument must be a number");
        return n4.SlowBuffer(r9);
      };
      u4 = e4;
      e$12 = {};
      s4 = u4.Buffer;
      i4 = s4.isEncoding || function(t8) {
        switch ((t8 = "" + t8) && t8.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      e$12.StringDecoder = a4, a4.prototype.write = function(t8) {
        if (0 === t8.length)
          return "";
        var e9, s6;
        if (this.lastNeed) {
          if (void 0 === (e9 = this.fillLast(t8)))
            return "";
          s6 = this.lastNeed, this.lastNeed = 0;
        } else
          s6 = 0;
        return s6 < t8.length ? e9 ? e9 + this.text(t8, s6) : this.text(t8, s6) : e9 || "";
      }, a4.prototype.end = function(t8) {
        var e9 = t8 && t8.length ? this.write(t8) : "";
        return this.lastNeed ? e9 + "\uFFFD" : e9;
      }, a4.prototype.text = function(t8, e9) {
        var s6 = function(t9, e10, s7) {
          var i8 = e10.length - 1;
          if (i8 < s7)
            return 0;
          var a7 = r4(e10[i8]);
          if (a7 >= 0)
            return a7 > 0 && (t9.lastNeed = a7 - 1), a7;
          if (--i8 < s7 || -2 === a7)
            return 0;
          if ((a7 = r4(e10[i8])) >= 0)
            return a7 > 0 && (t9.lastNeed = a7 - 2), a7;
          if (--i8 < s7 || -2 === a7)
            return 0;
          if ((a7 = r4(e10[i8])) >= 0)
            return a7 > 0 && (2 === a7 ? a7 = 0 : t9.lastNeed = a7 - 3), a7;
          return 0;
        }(this, t8, e9);
        if (!this.lastNeed)
          return t8.toString("utf8", e9);
        this.lastTotal = s6;
        var i7 = t8.length - (s6 - this.lastNeed);
        return t8.copy(this.lastChar, 0, i7), t8.toString("utf8", e9, i7);
      }, a4.prototype.fillLast = function(t8) {
        if (this.lastNeed <= t8.length)
          return t8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t8.length), this.lastNeed -= t8.length;
      };
      e$12.StringDecoder;
      e$12.StringDecoder;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js
  function dew$2$1() {
    if (_dewExec$2$1)
      return exports$2$1;
    _dewExec$2$1 = true;
    exports$2$1.byteLength = byteLength;
    exports$2$1.toByteArray = toByteArray;
    exports$2$1.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i7 = 0, len = code.length; i7 < len; ++i7) {
      lookup[i7] = code[i7];
      revLookup[code.charCodeAt(i7)] = i7;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i8;
      for (i8 = 0; i8 < len2; i8 += 4) {
        tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i8 = start; i8 < end; i8 += 3) {
        tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    return exports$2$1;
  }
  function dew$1$1() {
    if (_dewExec$1$1)
      return exports$1$1;
    _dewExec$1$1 = true;
    exports$1$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e9, m6;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i7 = isLE ? nBytes - 1 : 0;
      var d6 = isLE ? -1 : 1;
      var s6 = buffer2[offset + i7];
      i7 += d6;
      e9 = s6 & (1 << -nBits) - 1;
      s6 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e9 = e9 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
      }
      m6 = e9 & (1 << -nBits) - 1;
      e9 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d6, nBits -= 8) {
      }
      if (e9 === 0) {
        e9 = 1 - eBias;
      } else if (e9 === eMax) {
        return m6 ? NaN : (s6 ? -1 : 1) * Infinity;
      } else {
        m6 = m6 + Math.pow(2, mLen);
        e9 = e9 - eBias;
      }
      return (s6 ? -1 : 1) * m6 * Math.pow(2, e9 - mLen);
    };
    exports$1$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e9, m6, c7;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i7 = isLE ? 0 : nBytes - 1;
      var d6 = isLE ? 1 : -1;
      var s6 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m6 = isNaN(value) ? 1 : 0;
        e9 = eMax;
      } else {
        e9 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c7 = Math.pow(2, -e9)) < 1) {
          e9--;
          c7 *= 2;
        }
        if (e9 + eBias >= 1) {
          value += rt / c7;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c7 >= 2) {
          e9++;
          c7 /= 2;
        }
        if (e9 + eBias >= eMax) {
          m6 = 0;
          e9 = eMax;
        } else if (e9 + eBias >= 1) {
          m6 = (value * c7 - 1) * Math.pow(2, mLen);
          e9 = e9 + eBias;
        } else {
          m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e9 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d6, m6 /= 256, mLen -= 8) {
      }
      e9 = e9 << mLen | m6;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i7] = e9 & 255, i7 += d6, e9 /= 256, eLen -= 8) {
      }
      buffer2[offset + i7 - d6] |= s6 * 128;
    };
    return exports$1$1;
  }
  function dew$g() {
    if (_dewExec$g)
      return exports$g;
    _dewExec$g = true;
    const base64 = dew$2$1();
    const ieee754 = dew$1$1();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports$g.Buffer = Buffer3;
    exports$g.SlowBuffer = SlowBuffer;
    exports$g.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports$g.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e9) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from2(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from2(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b5 = fromObject(value);
      if (b5)
        return b5;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from2(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike2(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i7 = 0; i7 < length; i7 += 1) {
        buf[i7] = array[i7] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike2(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike2(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike2(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer3(b5) {
      return b5 != null && b5._isBuffer === true && b5 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a7, b5) {
      if (isInstance(a7, Uint8Array))
        a7 = Buffer3.from(a7, a7.offset, a7.byteLength);
      if (isInstance(b5, Uint8Array))
        b5 = Buffer3.from(b5, b5.offset, b5.byteLength);
      if (!Buffer3.isBuffer(a7) || !Buffer3.isBuffer(b5)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a7 === b5)
        return 0;
      let x4 = a7.length;
      let y6 = b5.length;
      for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
        if (a7[i7] !== b5[i7]) {
          x4 = a7[i7];
          y6 = b5[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i7;
      if (length === void 0) {
        length = 0;
        for (i7 = 0; i7 < list.length; ++i7) {
          length += list[i7].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        let buf = list[i7];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(buffer2, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b5, n8, m6) {
      const i7 = b5[n8];
      b5[n8] = b5[m6];
      b5[m6] = i7;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 2) {
        swap(this, i7, i7 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 4) {
        swap(this, i7, i7 + 3);
        swap(this, i7 + 1, i7 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 8) {
        swap(this, i7, i7 + 7);
        swap(this, i7 + 1, i7 + 6);
        swap(this, i7 + 2, i7 + 5);
        swap(this, i7 + 3, i7 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b5) {
      if (!Buffer3.isBuffer(b5))
        throw new TypeError("Argument must be a Buffer");
      if (this === b5)
        return true;
      return Buffer3.compare(this, b5) === 0;
    };
    Buffer3.prototype.inspect = function inspect3() {
      let str = "";
      const max = exports$g.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x4 = thisEnd - thisStart;
      let y6 = end - start;
      const len = Math.min(x4, y6);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i7 = 0; i7 < len; ++i7) {
        if (thisCopy[i7] !== targetCopy[i7]) {
          x4 = thisCopy[i7];
          y6 = targetCopy[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i8) {
        if (indexSize === 1) {
          return buf[i8];
        } else {
          return buf.readUInt16BE(i8 * indexSize);
        }
      }
      let i7;
      if (dir) {
        let foundIndex = -1;
        for (i7 = byteOffset; i7 < arrLength; i7++) {
          if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i7;
            if (i7 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i7 -= i7 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i7 = byteOffset; i7 >= 0; i7--) {
          let found = true;
          for (let j4 = 0; j4 < valLength; j4++) {
            if (read2(arr, i7 + j4) !== read2(val, j4)) {
              found = false;
              break;
            }
          }
          if (found)
            return i7;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        const parsed = parseInt(string.substr(i7 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i7;
        buf[offset + i7] = parsed;
      }
      return i7;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i7 = start;
      while (i7 < end) {
        const firstByte = buf[i7];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i7 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i7 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              fourthByte = buf[i7 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i7 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i7 = 0;
      while (i7 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i7 = start; i7 < end; ++i7) {
        out += hexSliceLookupTable[buf[i7]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
        res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i7 = byteLength2;
      let mul = 1;
      let val = this[offset + --i7];
      while (i7 > 0 && (mul *= 256)) {
        val += this[offset + --i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first2 << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i7 = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i7;
      if (typeof val === "number") {
        for (i7 = start; i7 < end; ++i7) {
          this[i7] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i7 = 0; i7 < end - start; ++i7) {
          this[i7 + start] = bytes[i7 % len];
        }
      }
      return this;
    };
    const errors = {};
    function E4(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E4("ERR_INVALID_ARG_TYPE", function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E4("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i7 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i7 >= start + 4; i7 -= 3) {
        res = `_${val.slice(i7 - 3, i7)}${res}`;
      }
      return `${val.slice(0, i7)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n8 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
          } else {
            range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
          }
        } else {
          range = `>= ${min}${n8} and <= ${max}${n8}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i7 = 0; i7 < length; ++i7) {
        codePoint = string.charCodeAt(i7);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i7 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        byteArray.push(str.charCodeAt(i7) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c7, hi, lo;
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        if ((units -= 2) < 0)
          break;
        c7 = str.charCodeAt(i7);
        hi = c7 >> 8;
        lo = c7 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        if (i7 + offset >= dst.length || i7 >= src.length)
          break;
        dst[i7 + offset] = src[i7];
      }
      return i7;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i7 = 0; i7 < 16; ++i7) {
        const i16 = i7 * 16;
        for (let j4 = 0; j4 < 16; ++j4) {
          table[i16 + j4] = alphabet[i7] + alphabet[j4];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    return exports$g;
  }
  function dew$f() {
    if (_dewExec$f)
      return exports$f;
    _dewExec$f = true;
    if (typeof Object.create === "function") {
      exports$f = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      exports$f = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    return exports$f;
  }
  function dew$e() {
    if (_dewExec$e)
      return exports$e;
    _dewExec$e = true;
    exports$e = y.EventEmitter;
    return exports$e;
  }
  function dew$d() {
    if (_dewExec$d)
      return exports$d;
    _dewExec$d = true;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i7 = 1; i7 < arguments.length; i7++) {
        var source2 = arguments[i7] != null ? arguments[i7] : {};
        if (i7 % 2) {
          ownKeys(Object(source2), true).forEach(function(key) {
            _defineProperty(target, key, source2[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
        } else {
          ownKeys(Object(source2)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i7 = 0; i7 < props.length; i7++) {
        var descriptor = props[i7];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = buffer, Buffer3 = _require.Buffer;
    var _require2 = X, inspect3 = _require2.inspect;
    var custom = inspect3 && inspect3.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer3.prototype.copy.call(src, target, offset);
    }
    exports$d = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v6) {
          var entry = {
            data: v6,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v6) {
          var entry = {
            data: v6,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join2(s6) {
          if (this.length === 0)
            return "";
          var p7 = this.head;
          var ret = "" + p7.data;
          while (p7 = p7.next) {
            ret += s6 + p7.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat2(n8) {
          if (this.length === 0)
            return Buffer3.alloc(0);
          var ret = Buffer3.allocUnsafe(n8 >>> 0);
          var p7 = this.head;
          var i7 = 0;
          while (p7) {
            copyBuffer(p7.data, ret, i7);
            i7 += p7.data.length;
            p7 = p7.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n8, hasStrings) {
          var ret;
          if (n8 < this.head.data.length) {
            ret = this.head.data.slice(0, n8);
            this.head.data = this.head.data.slice(n8);
          } else if (n8 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n8) : this._getBuffer(n8);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n8) {
          var p7 = this.head;
          var c7 = 1;
          var ret = p7.data;
          n8 -= ret.length;
          while (p7 = p7.next) {
            var str = p7.data;
            var nb = n8 > str.length ? str.length : n8;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n8);
            n8 -= nb;
            if (n8 === 0) {
              if (nb === str.length) {
                ++c7;
                if (p7.next)
                  this.head = p7.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p7;
                p7.data = str.slice(nb);
              }
              break;
            }
            ++c7;
          }
          this.length -= c7;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n8) {
          var ret = Buffer3.allocUnsafe(n8);
          var p7 = this.head;
          var c7 = 1;
          p7.data.copy(ret);
          n8 -= p7.data.length;
          while (p7 = p7.next) {
            var buf = p7.data;
            var nb = n8 > buf.length ? buf.length : n8;
            buf.copy(ret, ret.length - n8, 0, nb);
            n8 -= nb;
            if (n8 === 0) {
              if (nb === buf.length) {
                ++c7;
                if (p7.next)
                  this.head = p7.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p7;
                p7.data = buf.slice(nb);
              }
              break;
            }
            ++c7;
          }
          this.length -= c7;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_4, options) {
          return inspect3(this, _objectSpread({}, options, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
    return exports$d;
  }
  function dew$c() {
    if (_dewExec$c)
      return exports$c;
    _dewExec$c = true;
    var process$1 = process3;
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process$1.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process$1.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process$1.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    exports$c = {
      destroy,
      undestroy,
      errorOrDestroy
    };
    return exports$c;
  }
  function dew$b() {
    if (_dewExec$b)
      return exports$b;
    _dewExec$b = true;
    const codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i7) => String(i7));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + value + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name2, " argument")) {
        msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name2, ".") ? "property" : "argument";
        msg = `The "${name2}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    exports$b.codes = codes;
    return exports$b;
  }
  function dew$a() {
    if (_dewExec$a)
      return exports$a;
    _dewExec$a = true;
    var ERR_INVALID_OPT_VALUE = dew$b().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name2 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name2, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    exports$a = {
      getHighWaterMark
    };
    return exports$a;
  }
  function dew$9() {
    if (_dewExec$9)
      return exports$9;
    _dewExec$9 = true;
    exports$9 = deprecate3;
    function deprecate3(fn, msg) {
      if (config2("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config2("throwDeprecation")) {
            throw new Error(msg);
          } else if (config2("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this || _global$2, arguments);
      }
      return deprecated;
    }
    function config2(name2) {
      try {
        if (!_global$2.localStorage)
          return false;
      } catch (_4) {
        return false;
      }
      var val = _global$2.localStorage[name2];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
    return exports$9;
  }
  function dew$8() {
    if (_dewExec$8)
      return exports$8;
    _dewExec$8 = true;
    var process$1 = process3;
    exports$8 = Writable2;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex2;
    Writable2.WritableState = WritableState;
    var internalUtil = {
      deprecate: dew$9()
    };
    var Stream2 = dew$e();
    var Buffer3 = buffer.Buffer;
    var OurUint8Array = _global$1.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = dew$c();
    var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    dew$f()(Writable2, Stream2);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || dew$7();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_4) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable2)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable2(options) {
      Duplex2 = Duplex2 || dew$7();
      var isDuplex = this instanceof Duplex2;
      if (!isDuplex && !realHasInstance.call(Writable2, this))
        return new Writable2(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process$1.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer3.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer3.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev2, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev2)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process$1.nextTick(cb, er);
        process$1.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished2 = needFinish(state) || stream.destroyed;
        if (!finished2 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process$1.nextTick(afterWrite, stream, state, finished2, cb);
        } else {
          afterWrite(stream, state, finished2, cb);
        }
      }
    }
    function afterWrite(stream, state, finished2, cb) {
      if (!finished2)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l7 = state.bufferedRequestCount;
        var buffer2 = new Array(l7);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process$1.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process$1.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    return exports$8;
  }
  function dew$7() {
    if (_dewExec$7)
      return exports$7;
    _dewExec$7 = true;
    var process$1 = process3;
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    exports$7 = Duplex2;
    var Readable2 = dew$3();
    var Writable2 = dew$8();
    dew$f()(Duplex2, Readable2);
    {
      var keys = objectKeys(Writable2.prototype);
      for (var v6 = 0; v6 < keys.length; v6++) {
        var method = keys[v6];
        if (!Duplex2.prototype[method])
          Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    function Duplex2(options) {
      if (!(this instanceof Duplex2))
        return new Duplex2(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process$1.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    return exports$7;
  }
  function dew$6() {
    if (_dewExec$6)
      return exports$6;
    _dewExec$6 = true;
    var ERR_STREAM_PREMATURE_CLOSE = dew$b().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once2(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once2(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    exports$6 = eos;
    return exports$6;
  }
  function dew$5() {
    if (_dewExec$5)
      return exports$5;
    _dewExec$5 = true;
    var process$1 = process3;
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished2 = dew$6();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult2(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve3 = iter[kLastResolve];
      if (resolve3 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve3(createIterResult2(data, false));
        }
      }
    }
    function onReadable(iter) {
      process$1.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve3, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve3(createIterResult2(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve3, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult2(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve3, reject) {
            process$1.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve3(createIterResult2(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult2(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve3, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve3(createIterResult2(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve3, reject) {
          var data = iterator2[kStream].read();
          if (data) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            resolve3(createIterResult2(data, false));
          } else {
            iterator2[kLastResolve] = resolve3;
            iterator2[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator2[kLastPromise] = null;
      finished2(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator2[kLastReject];
          if (reject !== null) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            reject(err);
          }
          iterator2[kError] = err;
          return;
        }
        var resolve3 = iterator2[kLastResolve];
        if (resolve3 !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve3(createIterResult2(void 0, true));
        }
        iterator2[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator2));
      return iterator2;
    };
    exports$5 = createReadableStreamAsyncIterator;
    return exports$5;
  }
  function dew$4() {
    if (_dewExec$4)
      return exports$4;
    _dewExec$4 = true;
    exports$4 = function() {
      throw new Error("Readable.from is not available in the browser");
    };
    return exports$4;
  }
  function dew$3() {
    if (_dewExec$3)
      return exports$32;
    _dewExec$3 = true;
    var process$1 = process3;
    exports$32 = Readable2;
    var Duplex2;
    Readable2.ReadableState = ReadableState;
    y.EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream2 = dew$e();
    var Buffer3 = buffer.Buffer;
    var OurUint8Array = _global2.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = X;
    var debug3;
    if (debugUtil && debugUtil.debuglog) {
      debug3 = debugUtil.debuglog("stream");
    } else {
      debug3 = function debug4() {
      };
    }
    var BufferList = dew$d();
    var destroyImpl = dew$c();
    var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from2;
    dew$f()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || dew$7();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = e$12.StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex2 = Duplex2 || dew$7();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      var isDuplex = this instanceof Duplex2;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug3("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = e$12.StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p7 = this._readableState.buffer.head;
      var content = "";
      while (p7 !== null) {
        content += decoder.write(p7.data);
        p7 = p7.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n8) {
      if (n8 >= MAX_HWM) {
        n8 = MAX_HWM;
      } else {
        n8--;
        n8 |= n8 >>> 1;
        n8 |= n8 >>> 2;
        n8 |= n8 >>> 4;
        n8 |= n8 >>> 8;
        n8 |= n8 >>> 16;
        n8++;
      }
      return n8;
    }
    function howMuchToRead(n8, state) {
      if (n8 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n8 !== n8) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n8 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n8);
      if (n8 <= state.length)
        return n8;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n8) {
      debug3("read", n8);
      n8 = parseInt(n8, 10);
      var state = this._readableState;
      var nOrig = n8;
      if (n8 !== 0)
        state.emittedReadable = false;
      if (n8 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug3("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n8 = howMuchToRead(n8, state);
      if (n8 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug3("need readable", doRead);
      if (state.length === 0 || state.length - n8 < state.highWaterMark) {
        doRead = true;
        debug3("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug3("reading or ended", doRead);
      } else if (doRead) {
        debug3("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n8 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n8 > 0)
        ret = fromList(n8, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n8 = 0;
      } else {
        state.length -= n8;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n8 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug3("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug3("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug3("emitReadable", state.flowing);
        state.emittedReadable = true;
        process$1.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug3("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process$1.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug3("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n8) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug3("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process$1.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug3("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug3("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug3("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug3("ondata");
        var ret = dest.write(chunk);
        debug3("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug3("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug3("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug3("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug3("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug3("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug3("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i7 = 0; i7 < len; i7++) {
          dests[i7].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug3("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process$1.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug3("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug3("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process$1.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug3("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug3("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug3("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug3("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug3("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug3("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i7 in stream) {
        if (this[i7] === void 0 && typeof stream[i7] === "function") {
          this[i7] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i7);
        }
      }
      for (var n8 = 0; n8 < kProxyEvents.length; n8++) {
        stream.on(kProxyEvents[n8], this.emit.bind(this, kProxyEvents[n8]));
      }
      this._read = function(n9) {
        debug3("wrapped _read", n9);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = dew$5();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n8, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n8 || n8 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n8, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug3("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process$1.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug3("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from2 === void 0) {
          from2 = dew$4();
        }
        return from2(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x4) {
      for (var i7 = 0, l7 = xs.length; i7 < l7; i7++) {
        if (xs[i7] === x4)
          return i7;
      }
      return -1;
    }
    return exports$32;
  }
  function dew$22() {
    if (_dewExec$22)
      return exports$22;
    _dewExec$22 = true;
    exports$22 = Transform2;
    var _require$codes = dew$b().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex2 = dew$7();
    dew$f()(Transform2, Duplex2);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex2.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex2.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n8) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex2.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
    return exports$22;
  }
  function dew$12() {
    if (_dewExec$12)
      return exports$12;
    _dewExec$12 = true;
    exports$12 = PassThrough2;
    var Transform2 = dew$22();
    dew$f()(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    return exports$12;
  }
  function dew3() {
    if (_dewExec3)
      return exports3;
    _dewExec3 = true;
    var eos;
    function once2(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = dew$b().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once2(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = dew$6();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe2(from2, to) {
      return from2.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline2() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i7) {
        var reading = i7 < streams.length - 1;
        var writing = i7 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe2);
    }
    exports3 = pipeline2;
    return exports3;
  }
  var exports$2$1, _dewExec$2$1, exports$1$1, _dewExec$1$1, exports$g, _dewExec$g, buffer, exports$f, _dewExec$f, exports$e, _dewExec$e, exports$d, _dewExec$d, exports$c, _dewExec$c, exports$b, _dewExec$b, exports$a, _dewExec$a, exports$9, _dewExec$9, _global$2, exports$8, _dewExec$8, _global$1, exports$7, _dewExec$7, exports$6, _dewExec$6, exports$5, _dewExec$5, exports$4, _dewExec$4, exports$32, _dewExec$3, _global2, exports$22, _dewExec$22, exports$12, _dewExec$12, exports3, _dewExec3;
  var init_chunk_44e51b61 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js"() {
      init_dirname();
      init_buffer2();
      init_chunk_4bd36a8f();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_2eac56ff();
      init_chunk_4ccc3a29();
      exports$2$1 = {};
      _dewExec$2$1 = false;
      exports$1$1 = {};
      _dewExec$1$1 = false;
      exports$g = {};
      _dewExec$g = false;
      buffer = dew$g();
      buffer.Buffer;
      buffer.INSPECT_MAX_BYTES;
      buffer.kMaxLength;
      exports$f = {};
      _dewExec$f = false;
      exports$e = {};
      _dewExec$e = false;
      exports$d = {};
      _dewExec$d = false;
      exports$c = {};
      _dewExec$c = false;
      exports$b = {};
      _dewExec$b = false;
      exports$a = {};
      _dewExec$a = false;
      exports$9 = {};
      _dewExec$9 = false;
      _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$8 = {};
      _dewExec$8 = false;
      _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$7 = {};
      _dewExec$7 = false;
      exports$6 = {};
      _dewExec$6 = false;
      exports$5 = {};
      _dewExec$5 = false;
      exports$4 = {};
      _dewExec$4 = false;
      exports$32 = {};
      _dewExec$3 = false;
      _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$22 = {};
      _dewExec$22 = false;
      exports$12 = {};
      _dewExec$12 = false;
      exports3 = {};
      _dewExec3 = false;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/assert.js
  function e5(e9, r9) {
    if (null == e9)
      throw new TypeError("Cannot convert first argument to object");
    for (var t8 = Object(e9), n8 = 1; n8 < arguments.length; n8++) {
      var o8 = arguments[n8];
      if (null != o8)
        for (var a7 = Object.keys(Object(o8)), l7 = 0, i7 = a7.length; l7 < i7; l7++) {
          var c7 = a7[l7], b5 = Object.getOwnPropertyDescriptor(o8, c7);
          void 0 !== b5 && b5.enumerable && (t8[c7] = o8[c7]);
        }
    }
    return t8;
  }
  function i$5() {
    if (a$6)
      return c$4;
    function e9(t8) {
      return (e9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
        return typeof t9;
      } : function(t9) {
        return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
      })(t8);
    }
    function n8(t8, n9) {
      return !n9 || "object" !== e9(n9) && "function" != typeof n9 ? function(t9) {
        if (void 0 === t9)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t9;
      }(t8) : n9;
    }
    function r9(t8) {
      return (r9 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t9) {
        return t9.__proto__ || Object.getPrototypeOf(t9);
      })(t8);
    }
    function o8(t8, e10) {
      return (o8 = Object.setPrototypeOf || function(t9, e11) {
        return t9.__proto__ = e11, t9;
      })(t8, e10);
    }
    a$6 = true;
    var i7, u7, l7 = {};
    function f7(t8, e10, c7) {
      c7 || (c7 = Error);
      var a7 = function(c8) {
        function a8(o9, c9, i8) {
          var u8;
          return !function(t9, e11) {
            if (!(t9 instanceof e11))
              throw new TypeError("Cannot call a class as a function");
          }(this, a8), (u8 = n8(this, r9(a8).call(this, function(t9, n9, r10) {
            return "string" == typeof e10 ? e10 : e10(t9, n9, r10);
          }(o9, c9, i8)))).code = t8, u8;
        }
        return !function(t9, e11) {
          if ("function" != typeof e11 && null !== e11)
            throw new TypeError("Super expression must either be null or a function");
          t9.prototype = Object.create(e11 && e11.prototype, { constructor: { value: t9, writable: true, configurable: true } }), e11 && o8(t9, e11);
        }(a8, c8), a8;
      }(c7);
      l7[t8] = a7;
    }
    function s6(t8, e10) {
      if (Array.isArray(t8)) {
        var n9 = t8.length;
        return t8 = t8.map(function(t9) {
          return String(t9);
        }), n9 > 2 ? "one of ".concat(e10, " ").concat(t8.slice(0, n9 - 1).join(", "), ", or ") + t8[n9 - 1] : 2 === n9 ? "one of ".concat(e10, " ").concat(t8[0], " or ").concat(t8[1]) : "of ".concat(e10, " ").concat(t8[0]);
      }
      return "of ".concat(e10, " ").concat(String(t8));
    }
    return f7("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f7("ERR_INVALID_ARG_TYPE", function(t8, n9, r10) {
      var o9, c7, u8;
      if (void 0 === i7 && (i7 = tt()), i7("string" == typeof t8, "'name' must be a string"), "string" == typeof n9 && (c7 = "not ", n9.substr(0, c7.length) === c7) ? (o9 = "must not be", n9 = n9.replace(/^not /, "")) : o9 = "must be", function(t9, e10, n10) {
        return (void 0 === n10 || n10 > t9.length) && (n10 = t9.length), t9.substring(n10 - e10.length, n10) === e10;
      }(t8, " argument"))
        u8 = "The ".concat(t8, " ").concat(o9, " ").concat(s6(n9, "type"));
      else {
        var l8 = function(t9, e10, n10) {
          return "number" != typeof n10 && (n10 = 0), !(n10 + e10.length > t9.length) && -1 !== t9.indexOf(e10, n10);
        }(t8, ".") ? "property" : "argument";
        u8 = 'The "'.concat(t8, '" ').concat(l8, " ").concat(o9, " ").concat(s6(n9, "type"));
      }
      return u8 += ". Received type ".concat(e9(r10));
    }, TypeError), f7("ERR_INVALID_ARG_VALUE", function(e10, n9) {
      var r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
      void 0 === u7 && (u7 = X);
      var o9 = u7.inspect(n9);
      return o9.length > 128 && (o9 = "".concat(o9.slice(0, 128), "...")), "The argument '".concat(e10, "' ").concat(r10, ". Received ").concat(o9);
    }, TypeError), f7("ERR_INVALID_RETURN_VALUE", function(t8, n9, r10) {
      var o9;
      return o9 = r10 && r10.constructor && r10.constructor.name ? "instance of ".concat(r10.constructor.name) : "type ".concat(e9(r10)), "Expected ".concat(t8, ' to be returned from the "').concat(n9, '"') + " function but got ".concat(o9, ".");
    }, TypeError), f7("ERR_MISSING_ARGS", function() {
      for (var t8 = arguments.length, e10 = new Array(t8), n9 = 0; n9 < t8; n9++)
        e10[n9] = arguments[n9];
      void 0 === i7 && (i7 = tt()), i7(e10.length > 0, "At least one arg needs to be specified");
      var r10 = "The ", o9 = e10.length;
      switch (e10 = e10.map(function(t9) {
        return '"'.concat(t9, '"');
      }), o9) {
        case 1:
          r10 += "".concat(e10[0], " argument");
          break;
        case 2:
          r10 += "".concat(e10[0], " and ").concat(e10[1], " arguments");
          break;
        default:
          r10 += e10.slice(0, o9 - 1).join(", "), r10 += ", and ".concat(e10[o9 - 1], " arguments");
      }
      return "".concat(r10, " must be specified");
    }, TypeError), c$4.codes = l7, c$4;
  }
  function f$6() {
    if (l$6)
      return u$5;
    l$6 = true;
    var n8 = T;
    function r9(t8, e9, n9) {
      return e9 in t8 ? Object.defineProperty(t8, e9, { value: n9, enumerable: true, configurable: true, writable: true }) : t8[e9] = n9, t8;
    }
    function o8(t8, e9) {
      for (var n9 = 0; n9 < e9.length; n9++) {
        var r10 = e9[n9];
        r10.enumerable = r10.enumerable || false, r10.configurable = true, "value" in r10 && (r10.writable = true), Object.defineProperty(t8, r10.key, r10);
      }
    }
    function c7(t8, e9) {
      return !e9 || "object" !== y6(e9) && "function" != typeof e9 ? a7(t8) : e9;
    }
    function a7(t8) {
      if (void 0 === t8)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t8;
    }
    function f7(t8) {
      var e9 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return (f7 = function(t9) {
        if (null === t9 || (n9 = t9, -1 === Function.toString.call(n9).indexOf("[native code]")))
          return t9;
        var n9;
        if ("function" != typeof t9)
          throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== e9) {
          if (e9.has(t9))
            return e9.get(t9);
          e9.set(t9, r10);
        }
        function r10() {
          return p7(t9, arguments, h8(this).constructor);
        }
        return r10.prototype = Object.create(t9.prototype, { constructor: { value: r10, enumerable: false, writable: true, configurable: true } }), g5(r10, t9);
      })(t8);
    }
    function s6() {
      if ("undefined" == typeof Reflect || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if ("function" == typeof Proxy)
        return true;
      try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        })), true;
      } catch (t8) {
        return false;
      }
    }
    function p7(t8, e9, n9) {
      return (p7 = s6() ? Reflect.construct : function(t9, e10, n10) {
        var r10 = [null];
        r10.push.apply(r10, e10);
        var o9 = new (Function.bind.apply(t9, r10))();
        return n10 && g5(o9, n10.prototype), o9;
      }).apply(null, arguments);
    }
    function g5(t8, e9) {
      return (g5 = Object.setPrototypeOf || function(t9, e10) {
        return t9.__proto__ = e10, t9;
      })(t8, e9);
    }
    function h8(t8) {
      return (h8 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t9) {
        return t9.__proto__ || Object.getPrototypeOf(t9);
      })(t8);
    }
    function y6(t8) {
      return (y6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
        return typeof t9;
      } : function(t9) {
        return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
      })(t8);
    }
    var b5 = X.inspect, v6 = i$5().codes.ERR_INVALID_ARG_TYPE;
    function d6(t8, e9, n9) {
      return (void 0 === n9 || n9 > t8.length) && (n9 = t8.length), t8.substring(n9 - e9.length, n9) === e9;
    }
    var m6 = "", E4 = "", w4 = "", S4 = "", j4 = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
    function O5(t8) {
      var e9 = Object.keys(t8), n9 = Object.create(Object.getPrototypeOf(t8));
      return e9.forEach(function(e10) {
        n9[e10] = t8[e10];
      }), Object.defineProperty(n9, "message", { value: t8.message }), n9;
    }
    function x4(t8) {
      return b5(t8, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
    }
    function q3(t8, e9, r10) {
      var o9 = "", c8 = "", a8 = 0, i7 = "", u7 = false, l7 = x4(t8), f8 = l7.split("\n"), s7 = x4(e9).split("\n"), p8 = 0, g6 = "";
      if ("strictEqual" === r10 && "object" === y6(t8) && "object" === y6(e9) && null !== t8 && null !== e9 && (r10 = "strictEqualObject"), 1 === f8.length && 1 === s7.length && f8[0] !== s7[0]) {
        var h9 = f8[0].length + s7[0].length;
        if (h9 <= 10) {
          if (!("object" === y6(t8) && null !== t8 || "object" === y6(e9) && null !== e9 || 0 === t8 && 0 === e9))
            return "".concat(j4[r10], "\n\n") + "".concat(f8[0], " !== ").concat(s7[0], "\n");
        } else if ("strictEqualObject" !== r10) {
          if (h9 < (n8.stderr && n8.stderr.isTTY ? n8.stderr.columns : 80)) {
            for (; f8[0][p8] === s7[0][p8]; )
              p8++;
            p8 > 2 && (g6 = "\n  ".concat(function(t9, e10) {
              if (e10 = Math.floor(e10), 0 == t9.length || 0 == e10)
                return "";
              var n9 = t9.length * e10;
              for (e10 = Math.floor(Math.log(e10) / Math.log(2)); e10; )
                t9 += t9, e10--;
              return t9 += t9.substring(0, n9 - t9.length);
            }(" ", p8), "^"), p8 = 0);
          }
        }
      }
      for (var b6 = f8[f8.length - 1], v7 = s7[s7.length - 1]; b6 === v7 && (p8++ < 2 ? i7 = "\n  ".concat(b6).concat(i7) : o9 = b6, f8.pop(), s7.pop(), 0 !== f8.length && 0 !== s7.length); )
        b6 = f8[f8.length - 1], v7 = s7[s7.length - 1];
      var O6 = Math.max(f8.length, s7.length);
      if (0 === O6) {
        var q4 = l7.split("\n");
        if (q4.length > 30)
          for (q4[26] = "".concat(m6, "...").concat(S4); q4.length > 27; )
            q4.pop();
        return "".concat(j4.notIdentical, "\n\n").concat(q4.join("\n"), "\n");
      }
      p8 > 3 && (i7 = "\n".concat(m6, "...").concat(S4).concat(i7), u7 = true), "" !== o9 && (i7 = "\n  ".concat(o9).concat(i7), o9 = "");
      var R5 = 0, A4 = j4[r10] + "\n".concat(E4, "+ actual").concat(S4, " ").concat(w4, "- expected").concat(S4), k4 = " ".concat(m6, "...").concat(S4, " Lines skipped");
      for (p8 = 0; p8 < O6; p8++) {
        var _4 = p8 - a8;
        if (f8.length < p8 + 1)
          _4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(s7[p8 - 2]), R5++), c8 += "\n  ".concat(s7[p8 - 1]), R5++), a8 = p8, o9 += "\n".concat(w4, "-").concat(S4, " ").concat(s7[p8]), R5++;
        else if (s7.length < p8 + 1)
          _4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(f8[p8 - 2]), R5++), c8 += "\n  ".concat(f8[p8 - 1]), R5++), a8 = p8, c8 += "\n".concat(E4, "+").concat(S4, " ").concat(f8[p8]), R5++;
        else {
          var T5 = s7[p8], P4 = f8[p8], I4 = P4 !== T5 && (!d6(P4, ",") || P4.slice(0, -1) !== T5);
          I4 && d6(T5, ",") && T5.slice(0, -1) === P4 && (I4 = false, P4 += ","), I4 ? (_4 > 1 && p8 > 2 && (_4 > 4 ? (c8 += "\n".concat(m6, "...").concat(S4), u7 = true) : _4 > 3 && (c8 += "\n  ".concat(f8[p8 - 2]), R5++), c8 += "\n  ".concat(f8[p8 - 1]), R5++), a8 = p8, c8 += "\n".concat(E4, "+").concat(S4, " ").concat(P4), o9 += "\n".concat(w4, "-").concat(S4, " ").concat(T5), R5 += 2) : (c8 += o9, o9 = "", 1 !== _4 && 0 !== p8 || (c8 += "\n  ".concat(P4), R5++));
        }
        if (R5 > 20 && p8 < O6 - 2)
          return "".concat(A4).concat(k4, "\n").concat(c8, "\n").concat(m6, "...").concat(S4).concat(o9, "\n") + "".concat(m6, "...").concat(S4);
      }
      return "".concat(A4).concat(u7 ? k4 : "", "\n").concat(c8).concat(o9).concat(i7).concat(g6);
    }
    var R4 = function(t8) {
      function e9(t9) {
        var r10;
        if (!function(t10, e10) {
          if (!(t10 instanceof e10))
            throw new TypeError("Cannot call a class as a function");
        }(this, e9), "object" !== y6(t9) || null === t9)
          throw new v6("options", "Object", t9);
        var o9 = t9.message, i8 = t9.operator, u8 = t9.stackStartFn, l7 = t9.actual, f8 = t9.expected, s7 = Error.stackTraceLimit;
        if (Error.stackTraceLimit = 0, null != o9)
          r10 = c7(this, h8(e9).call(this, String(o9)));
        else if (n8.stderr && n8.stderr.isTTY && (n8.stderr && n8.stderr.getColorDepth && 1 !== n8.stderr.getColorDepth() ? (m6 = "\x1B[34m", E4 = "\x1B[32m", S4 = "\x1B[39m", w4 = "\x1B[31m") : (m6 = "", E4 = "", S4 = "", w4 = "")), "object" === y6(l7) && null !== l7 && "object" === y6(f8) && null !== f8 && "stack" in l7 && l7 instanceof Error && "stack" in f8 && f8 instanceof Error && (l7 = O5(l7), f8 = O5(f8)), "deepStrictEqual" === i8 || "strictEqual" === i8)
          r10 = c7(this, h8(e9).call(this, q3(l7, f8, i8)));
        else if ("notDeepStrictEqual" === i8 || "notStrictEqual" === i8) {
          var p8 = j4[i8], g6 = x4(l7).split("\n");
          if ("notStrictEqual" === i8 && "object" === y6(l7) && null !== l7 && (p8 = j4.notStrictEqualObject), g6.length > 30)
            for (g6[26] = "".concat(m6, "...").concat(S4); g6.length > 27; )
              g6.pop();
          r10 = 1 === g6.length ? c7(this, h8(e9).call(this, "".concat(p8, " ").concat(g6[0]))) : c7(this, h8(e9).call(this, "".concat(p8, "\n\n").concat(g6.join("\n"), "\n")));
        } else {
          var b6 = x4(l7), d7 = "", R5 = j4[i8];
          "notDeepEqual" === i8 || "notEqual" === i8 ? (b6 = "".concat(j4[i8], "\n\n").concat(b6)).length > 1024 && (b6 = "".concat(b6.slice(0, 1021), "...")) : (d7 = "".concat(x4(f8)), b6.length > 512 && (b6 = "".concat(b6.slice(0, 509), "...")), d7.length > 512 && (d7 = "".concat(d7.slice(0, 509), "...")), "deepEqual" === i8 || "equal" === i8 ? b6 = "".concat(R5, "\n\n").concat(b6, "\n\nshould equal\n\n") : d7 = " ".concat(i8, " ").concat(d7)), r10 = c7(this, h8(e9).call(this, "".concat(b6).concat(d7)));
        }
        return Error.stackTraceLimit = s7, r10.generatedMessage = !o9, Object.defineProperty(a7(r10), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r10.code = "ERR_ASSERTION", r10.actual = l7, r10.expected = f8, r10.operator = i8, Error.captureStackTrace && Error.captureStackTrace(a7(r10), u8), r10.stack, r10.name = "AssertionError", c7(r10);
      }
      var i7, u7;
      return !function(t9, e10) {
        if ("function" != typeof e10 && null !== e10)
          throw new TypeError("Super expression must either be null or a function");
        t9.prototype = Object.create(e10 && e10.prototype, { constructor: { value: t9, writable: true, configurable: true } }), e10 && g5(t9, e10);
      }(e9, t8), i7 = e9, (u7 = [{ key: "toString", value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      } }, { key: b5.custom, value: function(t9, e10) {
        return b5(this, function(t10) {
          for (var e11 = 1; e11 < arguments.length; e11++) {
            var n9 = null != arguments[e11] ? arguments[e11] : {}, o9 = Object.keys(n9);
            "function" == typeof Object.getOwnPropertySymbols && (o9 = o9.concat(Object.getOwnPropertySymbols(n9).filter(function(t11) {
              return Object.getOwnPropertyDescriptor(n9, t11).enumerable;
            }))), o9.forEach(function(e12) {
              r9(t10, e12, n9[e12]);
            });
          }
          return t10;
        }({}, e10, { customInspect: false, depth: 0 }));
      } }]) && o8(i7.prototype, u7), e9;
    }(f7(Error));
    return u$5 = R4;
  }
  function s$3(t8, e9) {
    return function(t9) {
      if (Array.isArray(t9))
        return t9;
    }(t8) || function(t9, e10) {
      var n8 = [], r9 = true, o8 = false, c7 = void 0;
      try {
        for (var a7, i7 = t9[Symbol.iterator](); !(r9 = (a7 = i7.next()).done) && (n8.push(a7.value), !e10 || n8.length !== e10); r9 = true)
          ;
      } catch (t10) {
        o8 = true, c7 = t10;
      } finally {
        try {
          r9 || null == i7.return || i7.return();
        } finally {
          if (o8)
            throw c7;
        }
      }
      return n8;
    }(t8, e9) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }();
  }
  function p$3(t8) {
    return (p$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
      return typeof t9;
    } : function(t9) {
      return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
    })(t8);
  }
  function m$2(t8) {
    return t8.call.bind(t8);
  }
  function U3(t8) {
    if (0 === t8.length || t8.length > 10)
      return true;
    for (var e9 = 0; e9 < t8.length; e9++) {
      var n8 = t8.charCodeAt(e9);
      if (n8 < 48 || n8 > 57)
        return true;
    }
    return 10 === t8.length && t8 >= Math.pow(2, 32);
  }
  function G2(t8) {
    return Object.keys(t8).filter(U3).concat(v$1(t8).filter(Object.prototype.propertyIsEnumerable.bind(t8)));
  }
  function V2(t8, e9) {
    if (t8 === e9)
      return 0;
    for (var n8 = t8.length, r9 = e9.length, o8 = 0, c7 = Math.min(n8, r9); o8 < c7; ++o8)
      if (t8[o8] !== e9[o8]) {
        n8 = t8[o8], r9 = e9[o8];
        break;
      }
    return n8 < r9 ? -1 : r9 < n8 ? 1 : 0;
  }
  function B3(t8, e9, n8, r9) {
    if (t8 === e9)
      return 0 !== t8 || (!n8 || b$1(t8, e9));
    if (n8) {
      if ("object" !== p$3(t8))
        return "number" == typeof t8 && d$1(t8) && d$1(e9);
      if ("object" !== p$3(e9) || null === t8 || null === e9)
        return false;
      if (Object.getPrototypeOf(t8) !== Object.getPrototypeOf(e9))
        return false;
    } else {
      if (null === t8 || "object" !== p$3(t8))
        return (null === e9 || "object" !== p$3(e9)) && t8 == e9;
      if (null === e9 || "object" !== p$3(e9))
        return false;
    }
    var o8, c7, a7, i7, u7 = S3(t8);
    if (u7 !== S3(e9))
      return false;
    if (Array.isArray(t8)) {
      if (t8.length !== e9.length)
        return false;
      var l7 = G2(t8), f7 = G2(e9);
      return l7.length === f7.length && C3(t8, e9, n8, r9, 1, l7);
    }
    if ("[object Object]" === u7 && (!R3(t8) && R3(e9) || !k3(t8) && k3(e9)))
      return false;
    if (q2(t8)) {
      if (!q2(e9) || Date.prototype.getTime.call(t8) !== Date.prototype.getTime.call(e9))
        return false;
    } else if (A$1(t8)) {
      if (!A$1(e9) || (a7 = t8, i7 = e9, !(g$1 ? a7.source === i7.source && a7.flags === i7.flags : RegExp.prototype.toString.call(a7) === RegExp.prototype.toString.call(i7))))
        return false;
    } else if (_3(t8) || t8 instanceof Error) {
      if (t8.message !== e9.message || t8.name !== e9.name)
        return false;
    } else {
      if (x3(t8)) {
        if (n8 || !L3(t8) && !M3(t8)) {
          if (!function(t9, e10) {
            return t9.byteLength === e10.byteLength && 0 === V2(new Uint8Array(t9.buffer, t9.byteOffset, t9.byteLength), new Uint8Array(e10.buffer, e10.byteOffset, e10.byteLength));
          }(t8, e9))
            return false;
        } else if (!function(t9, e10) {
          if (t9.byteLength !== e10.byteLength)
            return false;
          for (var n9 = 0; n9 < t9.byteLength; n9++)
            if (t9[n9] !== e10[n9])
              return false;
          return true;
        }(t8, e9))
          return false;
        var s6 = G2(t8), h8 = G2(e9);
        return s6.length === h8.length && C3(t8, e9, n8, r9, 0, s6);
      }
      if (k3(t8))
        return !(!k3(e9) || t8.size !== e9.size) && C3(t8, e9, n8, r9, 2);
      if (R3(t8))
        return !(!R3(e9) || t8.size !== e9.size) && C3(t8, e9, n8, r9, 3);
      if (O3(t8)) {
        if (c7 = e9, (o8 = t8).byteLength !== c7.byteLength || 0 !== V2(new Uint8Array(o8), new Uint8Array(c7)))
          return false;
      } else if (T4(t8) && !function(t9, e10) {
        return P$1(t9) ? P$1(e10) && b$1(Number.prototype.valueOf.call(t9), Number.prototype.valueOf.call(e10)) : I3(t9) ? I3(e10) && String.prototype.valueOf.call(t9) === String.prototype.valueOf.call(e10) : D3(t9) ? D3(e10) && Boolean.prototype.valueOf.call(t9) === Boolean.prototype.valueOf.call(e10) : F3(t9) ? F3(e10) && BigInt.prototype.valueOf.call(t9) === BigInt.prototype.valueOf.call(e10) : N$1(e10) && Symbol.prototype.valueOf.call(t9) === Symbol.prototype.valueOf.call(e10);
      }(t8, e9))
        return false;
    }
    return C3(t8, e9, n8, r9, 0);
  }
  function z3(t8, e9) {
    return e9.filter(function(e10) {
      return w$1(t8, e10);
    });
  }
  function C3(t8, e9, n8, r9, o8, c7) {
    if (5 === arguments.length) {
      c7 = Object.keys(t8);
      var a7 = Object.keys(e9);
      if (c7.length !== a7.length)
        return false;
    }
    for (var i7 = 0; i7 < c7.length; i7++)
      if (!E3(e9, c7[i7]))
        return false;
    if (n8 && 5 === arguments.length) {
      var u7 = v$1(t8);
      if (0 !== u7.length) {
        var l7 = 0;
        for (i7 = 0; i7 < u7.length; i7++) {
          var f7 = u7[i7];
          if (w$1(t8, f7)) {
            if (!w$1(e9, f7))
              return false;
            c7.push(f7), l7++;
          } else if (w$1(e9, f7))
            return false;
        }
        var s6 = v$1(e9);
        if (u7.length !== s6.length && z3(e9, s6).length !== l7)
          return false;
      } else {
        var p7 = v$1(e9);
        if (0 !== p7.length && 0 !== z3(e9, p7).length)
          return false;
      }
    }
    if (0 === c7.length && (0 === o8 || 1 === o8 && 0 === t8.length || 0 === t8.size))
      return true;
    if (void 0 === r9)
      r9 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
    else {
      var g5 = r9.val1.get(t8);
      if (void 0 !== g5) {
        var h8 = r9.val2.get(e9);
        if (void 0 !== h8)
          return g5 === h8;
      }
      r9.position++;
    }
    r9.val1.set(t8, r9.position), r9.val2.set(e9, r9.position);
    var y6 = Q2(t8, e9, n8, c7, r9, o8);
    return r9.val1.delete(t8), r9.val2.delete(e9), y6;
  }
  function Y3(t8, e9, n8, r9) {
    for (var o8 = h$1(t8), c7 = 0; c7 < o8.length; c7++) {
      var a7 = o8[c7];
      if (B3(e9, a7, n8, r9))
        return t8.delete(a7), true;
    }
    return false;
  }
  function W2(t8) {
    switch (p$3(t8)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return false;
      case "string":
        t8 = +t8;
      case "number":
        if (d$1(t8))
          return false;
    }
    return true;
  }
  function H2(t8, e9, n8) {
    var r9 = W2(n8);
    return null != r9 ? r9 : e9.has(r9) && !t8.has(r9);
  }
  function J2(t8, e9, n8, r9, o8) {
    var c7 = W2(n8);
    if (null != c7)
      return c7;
    var a7 = e9.get(c7);
    return !(void 0 === a7 && !e9.has(c7) || !B3(r9, a7, false, o8)) && (!t8.has(c7) && B3(r9, a7, false, o8));
  }
  function K2(t8, e9, n8, r9, o8, c7) {
    for (var a7 = h$1(t8), i7 = 0; i7 < a7.length; i7++) {
      var u7 = a7[i7];
      if (B3(n8, u7, o8, c7) && B3(r9, e9.get(u7), o8, c7))
        return t8.delete(u7), true;
    }
    return false;
  }
  function Q2(t8, e9, n8, r9, o8, c7) {
    var a7 = 0;
    if (2 === c7) {
      if (!function(t9, e10, n9, r10) {
        for (var o9 = null, c8 = h$1(t9), a8 = 0; a8 < c8.length; a8++) {
          var i8 = c8[a8];
          if ("object" === p$3(i8) && null !== i8)
            null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(i8);
          else if (!e10.has(i8)) {
            if (n9)
              return false;
            if (!H2(t9, e10, i8))
              return false;
            null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(i8);
          }
        }
        if (null !== o9) {
          for (var u8 = h$1(e10), l8 = 0; l8 < u8.length; l8++) {
            var f7 = u8[l8];
            if ("object" === p$3(f7) && null !== f7) {
              if (!Y3(o9, f7, n9, r10))
                return false;
            } else if (!n9 && !t9.has(f7) && !Y3(o9, f7, n9, r10))
              return false;
          }
          return 0 === o9.size;
        }
        return true;
      }(t8, e9, n8, o8))
        return false;
    } else if (3 === c7) {
      if (!function(t9, e10, n9, r10) {
        for (var o9 = null, c8 = y$2(t9), a8 = 0; a8 < c8.length; a8++) {
          var i8 = s$3(c8[a8], 2), u8 = i8[0], l8 = i8[1];
          if ("object" === p$3(u8) && null !== u8)
            null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(u8);
          else {
            var f7 = e10.get(u8);
            if (void 0 === f7 && !e10.has(u8) || !B3(l8, f7, n9, r10)) {
              if (n9)
                return false;
              if (!J2(t9, e10, u8, l8, r10))
                return false;
              null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(u8);
            }
          }
        }
        if (null !== o9) {
          for (var g5 = y$2(e10), h8 = 0; h8 < g5.length; h8++) {
            var b5 = s$3(g5[h8], 2), v6 = (u8 = b5[0], b5[1]);
            if ("object" === p$3(u8) && null !== u8) {
              if (!K2(o9, t9, u8, v6, n9, r10))
                return false;
            } else if (!(n9 || t9.has(u8) && B3(t9.get(u8), v6, false, r10) || K2(o9, t9, u8, v6, false, r10)))
              return false;
          }
          return 0 === o9.size;
        }
        return true;
      }(t8, e9, n8, o8))
        return false;
    } else if (1 === c7)
      for (; a7 < t8.length; a7++) {
        if (!E3(t8, a7)) {
          if (E3(e9, a7))
            return false;
          for (var i7 = Object.keys(t8); a7 < i7.length; a7++) {
            var u7 = i7[a7];
            if (!E3(e9, u7) || !B3(t8[u7], e9[u7], n8, o8))
              return false;
          }
          return i7.length === Object.keys(e9).length;
        }
        if (!E3(e9, a7) || !B3(t8[a7], e9[a7], n8, o8))
          return false;
      }
    for (a7 = 0; a7 < r9.length; a7++) {
      var l7 = r9[a7];
      if (!B3(t8[l7], e9[l7], n8, o8))
        return false;
    }
    return true;
  }
  function tt() {
    if ($$1)
      return Z2;
    $$1 = true;
    var o8 = T;
    function c7(t8) {
      return (c7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
        return typeof t9;
      } : function(t9) {
        return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
      })(t8);
    }
    var a7, u7, l7 = i$5().codes, s6 = l7.ERR_AMBIGUOUS_ARGUMENT, p7 = l7.ERR_INVALID_ARG_TYPE, g5 = l7.ERR_INVALID_ARG_VALUE, h8 = l7.ERR_INVALID_RETURN_VALUE, y6 = l7.ERR_MISSING_ARGS, b5 = f$6(), v6 = X.inspect, d6 = X.types, m$12 = d6.isPromise, E4 = d6.isRegExp, w4 = Object.assign ? Object.assign : r5.assign, S4 = Object.is ? Object.is : m4;
    function j4() {
      a7 = X2.isDeepEqual, u7 = X2.isDeepStrictEqual;
    }
    var O5 = false, x4 = Z2 = k4, q3 = {};
    function R4(t8) {
      if (t8.message instanceof Error)
        throw t8.message;
      throw new b5(t8);
    }
    function A4(t8, e9, n8, r9) {
      if (!n8) {
        var o9 = false;
        if (0 === e9)
          o9 = true, r9 = "No value argument passed to `assert.ok()`";
        else if (r9 instanceof Error)
          throw r9;
        var c8 = new b5({ actual: n8, expected: true, message: r9, operator: "==", stackStartFn: t8 });
        throw c8.generatedMessage = o9, c8;
      }
    }
    function k4() {
      for (var t8 = arguments.length, e9 = new Array(t8), n8 = 0; n8 < t8; n8++)
        e9[n8] = arguments[n8];
      A4.apply(void 0, [k4, e9.length].concat(e9));
    }
    x4.fail = function t8(e9, n8, r9, c8, a8) {
      var i7, u8 = arguments.length;
      if (0 === u8)
        i7 = "Failed";
      else if (1 === u8)
        r9 = e9, e9 = void 0;
      else {
        if (false === O5) {
          O5 = true;
          var l8 = o8.emitWarning ? o8.emitWarning : console.warn.bind(console);
          l8("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        2 === u8 && (c8 = "!=");
      }
      if (r9 instanceof Error)
        throw r9;
      var f7 = { actual: e9, expected: n8, operator: void 0 === c8 ? "fail" : c8, stackStartFn: a8 || t8 };
      void 0 !== r9 && (f7.message = r9);
      var s7 = new b5(f7);
      throw i7 && (s7.message = i7, s7.generatedMessage = true), s7;
    }, x4.AssertionError = b5, x4.ok = k4, x4.equal = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      e9 != n8 && R4({ actual: e9, expected: n8, message: r9, operator: "==", stackStartFn: t8 });
    }, x4.notEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      e9 == n8 && R4({ actual: e9, expected: n8, message: r9, operator: "!=", stackStartFn: t8 });
    }, x4.deepEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      void 0 === a7 && j4(), a7(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: "deepEqual", stackStartFn: t8 });
    }, x4.notDeepEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      void 0 === a7 && j4(), a7(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: "notDeepEqual", stackStartFn: t8 });
    }, x4.deepStrictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      void 0 === a7 && j4(), u7(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: "deepStrictEqual", stackStartFn: t8 });
    }, x4.notDeepStrictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      void 0 === a7 && j4();
      u7(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: "notDeepStrictEqual", stackStartFn: t8 });
    }, x4.strictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      S4(e9, n8) || R4({ actual: e9, expected: n8, message: r9, operator: "strictEqual", stackStartFn: t8 });
    }, x4.notStrictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      S4(e9, n8) && R4({ actual: e9, expected: n8, message: r9, operator: "notStrictEqual", stackStartFn: t8 });
    };
    var _4 = function t8(e9, n8, r9) {
      var o9 = this;
      !function(t9, e10) {
        if (!(t9 instanceof e10))
          throw new TypeError("Cannot call a class as a function");
      }(this, t8), n8.forEach(function(t9) {
        t9 in e9 && (void 0 !== r9 && "string" == typeof r9[t9] && E4(e9[t9]) && e9[t9].test(r9[t9]) ? o9[t9] = r9[t9] : o9[t9] = e9[t9]);
      });
    };
    function T5(t8, e9, n8, r9, o9, c8) {
      if (!(n8 in t8) || !u7(t8[n8], e9[n8])) {
        if (!r9) {
          var a8 = new _4(t8, o9), i7 = new _4(e9, o9, t8), l8 = new b5({ actual: a8, expected: i7, operator: "deepStrictEqual", stackStartFn: c8 });
          throw l8.actual = t8, l8.expected = e9, l8.operator = c8.name, l8;
        }
        R4({ actual: t8, expected: e9, message: r9, operator: c8.name, stackStartFn: c8 });
      }
    }
    function P4(t8, e9, n8, r9) {
      if ("function" != typeof e9) {
        if (E4(e9))
          return e9.test(t8);
        if (2 === arguments.length)
          throw new p7("expected", ["Function", "RegExp"], e9);
        if ("object" !== c7(t8) || null === t8) {
          var o9 = new b5({ actual: t8, expected: e9, message: n8, operator: "deepStrictEqual", stackStartFn: r9 });
          throw o9.operator = r9.name, o9;
        }
        var i7 = Object.keys(e9);
        if (e9 instanceof Error)
          i7.push("name", "message");
        else if (0 === i7.length)
          throw new g5("error", e9, "may not be an empty object");
        return void 0 === a7 && j4(), i7.forEach(function(o10) {
          "string" == typeof t8[o10] && E4(e9[o10]) && e9[o10].test(t8[o10]) || T5(t8, e9, o10, n8, i7, r9);
        }), true;
      }
      return void 0 !== e9.prototype && t8 instanceof e9 || !Error.isPrototypeOf(e9) && true === e9.call({}, t8);
    }
    function I4(t8) {
      if ("function" != typeof t8)
        throw new p7("fn", "Function", t8);
      try {
        t8();
      } catch (t9) {
        return t9;
      }
      return q3;
    }
    function D4(t8) {
      return m$12(t8) || null !== t8 && "object" === c7(t8) && "function" == typeof t8.then && "function" == typeof t8.catch;
    }
    function F4(t8) {
      return Promise.resolve().then(function() {
        var e9;
        if ("function" == typeof t8) {
          if (!D4(e9 = t8()))
            throw new h8("instance of Promise", "promiseFn", e9);
        } else {
          if (!D4(t8))
            throw new p7("promiseFn", ["Function", "Promise"], t8);
          e9 = t8;
        }
        return Promise.resolve().then(function() {
          return e9;
        }).then(function() {
          return q3;
        }).catch(function(t9) {
          return t9;
        });
      });
    }
    function N4(t8, e9, n8, r9) {
      if ("string" == typeof n8) {
        if (4 === arguments.length)
          throw new p7("error", ["Object", "Error", "Function", "RegExp"], n8);
        if ("object" === c7(e9) && null !== e9) {
          if (e9.message === n8)
            throw new s6("error/message", 'The error message "'.concat(e9.message, '" is identical to the message.'));
        } else if (e9 === n8)
          throw new s6("error/message", 'The error "'.concat(e9, '" is identical to the message.'));
        r9 = n8, n8 = void 0;
      } else if (null != n8 && "object" !== c7(n8) && "function" != typeof n8)
        throw new p7("error", ["Object", "Error", "Function", "RegExp"], n8);
      if (e9 === q3) {
        var o9 = "";
        n8 && n8.name && (o9 += " (".concat(n8.name, ")")), o9 += r9 ? ": ".concat(r9) : ".";
        var a8 = "rejects" === t8.name ? "rejection" : "exception";
        R4({ actual: void 0, expected: n8, operator: t8.name, message: "Missing expected ".concat(a8).concat(o9), stackStartFn: t8 });
      }
      if (n8 && !P4(e9, n8, r9, t8))
        throw e9;
    }
    function L4(t8, e9, n8, r9) {
      if (e9 !== q3) {
        if ("string" == typeof n8 && (r9 = n8, n8 = void 0), !n8 || P4(e9, n8)) {
          var o9 = r9 ? ": ".concat(r9) : ".", c8 = "doesNotReject" === t8.name ? "rejection" : "exception";
          R4({ actual: e9, expected: n8, operator: t8.name, message: "Got unwanted ".concat(c8).concat(o9, "\n") + 'Actual message: "'.concat(e9 && e9.message, '"'), stackStartFn: t8 });
        }
        throw e9;
      }
    }
    function M4() {
      for (var t8 = arguments.length, e9 = new Array(t8), n8 = 0; n8 < t8; n8++)
        e9[n8] = arguments[n8];
      A4.apply(void 0, [M4, e9.length].concat(e9));
    }
    return x4.throws = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
        r9[o9 - 1] = arguments[o9];
      N4.apply(void 0, [t8, I4(e9)].concat(r9));
    }, x4.rejects = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
        r9[o9 - 1] = arguments[o9];
      return F4(e9).then(function(e10) {
        return N4.apply(void 0, [t8, e10].concat(r9));
      });
    }, x4.doesNotThrow = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
        r9[o9 - 1] = arguments[o9];
      L4.apply(void 0, [t8, I4(e9)].concat(r9));
    }, x4.doesNotReject = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
        r9[o9 - 1] = arguments[o9];
      return F4(e9).then(function(e10) {
        return L4.apply(void 0, [t8, e10].concat(r9));
      });
    }, x4.ifError = function t8(e9) {
      if (null != e9) {
        var n8 = "ifError got unwanted exception: ";
        "object" === c7(e9) && "string" == typeof e9.message ? 0 === e9.message.length && e9.constructor ? n8 += e9.constructor.name : n8 += e9.message : n8 += v6(e9);
        var r9 = new b5({ actual: e9, expected: null, operator: "ifError", message: n8, stackStartFn: t8 }), o9 = e9.stack;
        if ("string" == typeof o9) {
          var a8 = o9.split("\n");
          a8.shift();
          for (var i7 = r9.stack.split("\n"), u8 = 0; u8 < a8.length; u8++) {
            var l8 = i7.indexOf(a8[u8]);
            if (-1 !== l8) {
              i7 = i7.slice(0, l8);
              break;
            }
          }
          r9.stack = "".concat(i7.join("\n"), "\n").concat(a8.join("\n"));
        }
        throw r9;
      }
    }, x4.strict = w4(M4, x4, { equal: x4.strictEqual, deepEqual: x4.deepStrictEqual, notEqual: x4.notStrictEqual, notDeepEqual: x4.notDeepStrictEqual }), x4.strict.strict = x4.strict, Z2;
  }
  var r5, t5, e$13, r$12, n8, o8, c7, l7, i7, a7, u7, f7, p7, s6, y4, b3, g3, h5, $2, j3, w3, r$2, e$2, o$13, n$13, a$1, c$13, l$13, u$13, f$12, t$12, f$22, e$3, l$2, t$22, n$2, o$22, r$3, e$4, o$3, t$3, n$3, y$1, a$22, i$13, d4, f$3, u$22, A3, l$3, v4, P3, c$2, t$4, p$1, o$4, i$2, a$3, l$4, r$4, n$4, i$3, o$5, c$3, f$4, u$3, s$12, a$4, l$5, p$2, m4, N3, e$5, i$4, n$5, t$5, u$4, a$5, m$1, o$6, s$2, f$5, c$4, a$6, u$5, l$6, g$1, h$1, y$2, b$1, v$1, d$1, E3, w$1, S3, j$1, O3, x3, q2, R3, A$1, k3, _3, T4, P$1, I3, D3, F3, N$1, L3, M3, X2, Z2, $$1, et, AssertionError, deepEqual, deepStrictEqual, doesNotReject, doesNotThrow, equal, fail, ifError, notDeepEqual, notDeepStrictEqual, notEqual, notStrictEqual, ok, rejects, strict, strictEqual, throws;
  var init_assert2 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/assert.js"() {
      init_dirname();
      init_buffer2();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      r5 = { assign: e5, polyfill: function() {
        Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e5 });
      } };
      e$13 = Object.prototype.toString;
      r$12 = function(t8) {
        var r9 = e$13.call(t8), n8 = "[object Arguments]" === r9;
        return n8 || (n8 = "[object Array]" !== r9 && null !== t8 && "object" == typeof t8 && "number" == typeof t8.length && t8.length >= 0 && "[object Function]" === e$13.call(t8.callee)), n8;
      };
      if (!Object.keys) {
        n8 = Object.prototype.hasOwnProperty, o8 = Object.prototype.toString, c7 = r$12, l7 = Object.prototype.propertyIsEnumerable, i7 = !l7.call({ toString: null }, "toString"), a7 = l7.call(function() {
        }, "prototype"), u7 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], f7 = function(t8) {
          var e9 = t8.constructor;
          return e9 && e9.prototype === t8;
        }, p7 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, s6 = function() {
          if ("undefined" == typeof window)
            return false;
          for (var t8 in window)
            try {
              if (!p7["$" + t8] && n8.call(window, t8) && null !== window[t8] && "object" == typeof window[t8])
                try {
                  f7(window[t8]);
                } catch (t9) {
                  return true;
                }
            } catch (t9) {
              return true;
            }
          return false;
        }();
        t5 = function(t8) {
          var e9 = null !== t8 && "object" == typeof t8, r9 = "[object Function]" === o8.call(t8), l8 = c7(t8), p8 = e9 && "[object String]" === o8.call(t8), y6 = [];
          if (!e9 && !r9 && !l8)
            throw new TypeError("Object.keys called on a non-object");
          var b5 = a7 && r9;
          if (p8 && t8.length > 0 && !n8.call(t8, 0))
            for (var g5 = 0; g5 < t8.length; ++g5)
              y6.push(String(g5));
          if (l8 && t8.length > 0)
            for (var h8 = 0; h8 < t8.length; ++h8)
              y6.push(String(h8));
          else
            for (var $3 in t8)
              b5 && "prototype" === $3 || !n8.call(t8, $3) || y6.push(String($3));
          if (i7)
            for (var j4 = function(t9) {
              if ("undefined" == typeof window || !s6)
                return f7(t9);
              try {
                return f7(t9);
              } catch (t10) {
                return false;
              }
            }(t8), w4 = 0; w4 < u7.length; ++w4)
              j4 && "constructor" === u7[w4] || !n8.call(t8, u7[w4]) || y6.push(u7[w4]);
          return y6;
        };
      }
      y4 = t5;
      b3 = Array.prototype.slice;
      g3 = r$12;
      h5 = Object.keys;
      $2 = h5 ? function(t8) {
        return h5(t8);
      } : y4;
      j3 = Object.keys;
      $2.shim = function() {
        Object.keys ? function() {
          var t8 = Object.keys(arguments);
          return t8 && t8.length === arguments.length;
        }(1, 2) || (Object.keys = function(t8) {
          return g3(t8) ? j3(b3.call(t8)) : j3(t8);
        }) : Object.keys = $2;
        return Object.keys || $2;
      };
      w3 = $2;
      r$2 = w3;
      e$2 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo");
      o$13 = Object.prototype.toString;
      n$13 = Array.prototype.concat;
      a$1 = Object.defineProperty;
      c$13 = a$1 && function() {
        var t8 = {};
        try {
          for (var r9 in a$1(t8, "x", { enumerable: false, value: t8 }), t8)
            return false;
          return t8.x === t8;
        } catch (t9) {
          return false;
        }
      }();
      l$13 = function(t8, r9, e9, n8) {
        var l7;
        (!(r9 in t8) || "function" == typeof (l7 = n8) && "[object Function]" === o$13.call(l7) && n8()) && (c$13 ? a$1(t8, r9, { configurable: true, enumerable: false, value: e9, writable: true }) : t8[r9] = e9);
      };
      u$13 = function(t8, o8) {
        var a7 = arguments.length > 2 ? arguments[2] : {}, c7 = r$2(o8);
        e$2 && (c7 = n$13.call(c7, Object.getOwnPropertySymbols(o8)));
        for (var u7 = 0; u7 < c7.length; u7 += 1)
          l$13(t8, c7[u7], o8[c7[u7]], a7[c7[u7]]);
      };
      u$13.supportsDescriptors = !!c$13;
      f$12 = u$13;
      t$12 = function() {
        if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
          return false;
        if ("symbol" == typeof Symbol.iterator)
          return true;
        var t8 = {}, e9 = Symbol("test"), r9 = Object(e9);
        if ("string" == typeof e9)
          return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(e9))
          return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(r9))
          return false;
        for (e9 in t8[e9] = 42, t8)
          return false;
        if ("function" == typeof Object.keys && 0 !== Object.keys(t8).length)
          return false;
        if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t8).length)
          return false;
        var o8 = Object.getOwnPropertySymbols(t8);
        if (1 !== o8.length || o8[0] !== e9)
          return false;
        if (!Object.prototype.propertyIsEnumerable.call(t8, e9))
          return false;
        if ("function" == typeof Object.getOwnPropertyDescriptor) {
          var n8 = Object.getOwnPropertyDescriptor(t8, e9);
          if (42 !== n8.value || true !== n8.enumerable)
            return false;
        }
        return true;
      };
      f$22 = ("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global).Symbol;
      e$3 = t$12;
      l$2 = function() {
        return "function" == typeof f$22 && ("function" == typeof Symbol && ("symbol" == typeof f$22("foo") && ("symbol" == typeof Symbol("bar") && e$3())));
      };
      t$22 = "Function.prototype.bind called on incompatible ";
      n$2 = Array.prototype.slice;
      o$22 = Object.prototype.toString;
      r$3 = function(r9) {
        var e9 = this;
        if ("function" != typeof e9 || "[object Function]" !== o$22.call(e9))
          throw new TypeError(t$22 + e9);
        for (var p7, i7 = n$2.call(arguments, 1), c7 = function() {
          if (this instanceof p7) {
            var t8 = e9.apply(this, i7.concat(n$2.call(arguments)));
            return Object(t8) === t8 ? t8 : this;
          }
          return e9.apply(r9, i7.concat(n$2.call(arguments)));
        }, a7 = Math.max(0, e9.length - i7.length), l7 = [], u7 = 0; u7 < a7; u7++)
          l7.push("$" + u7);
        if (p7 = Function("binder", "return function (" + l7.join(",") + "){ return binder.apply(this,arguments); }")(c7), e9.prototype) {
          var y6 = function() {
          };
          y6.prototype = e9.prototype, p7.prototype = new y6(), y6.prototype = null;
        }
        return p7;
      };
      e$4 = Function.prototype.bind || r$3;
      o$3 = TypeError;
      t$3 = Object.getOwnPropertyDescriptor;
      if (t$3)
        try {
          t$3({}, "");
        } catch (r9) {
          t$3 = null;
        }
      n$3 = function() {
        throw new o$3();
      };
      y$1 = t$3 ? function() {
        try {
          return arguments.callee, n$3;
        } catch (r9) {
          try {
            return t$3(arguments, "callee").get;
          } catch (r10) {
            return n$3;
          }
        }
      }() : n$3;
      a$22 = l$2();
      i$13 = Object.getPrototypeOf || function(r9) {
        return r9.__proto__;
      };
      d4 = "undefined" == typeof Uint8Array ? void 0 : i$13(Uint8Array);
      f$3 = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": a$22 ? i$13([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": a$22 ? i$13(i$13([][Symbol.iterator]())) : void 0, "%JSON%": "object" == typeof JSON ? JSON : void 0, "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && a$22 ? i$13((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && a$22 ? i$13((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": a$22 ? i$13(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": a$22 ? Symbol : void 0, "%SymbolPrototype%": a$22 ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": y$1, "%TypedArray%": d4, "%TypedArrayPrototype%": d4 ? d4.prototype : void 0, "%TypeError%": o$3, "%TypeErrorPrototype%": o$3.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype };
      u$22 = e$4.call(Function.call, String.prototype.replace);
      A3 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      l$3 = /\\(\\)?/g;
      v4 = function(r9) {
        var e9 = [];
        return u$22(r9, A3, function(r10, o8, t8, n8) {
          e9[e9.length] = t8 ? u$22(n8, l$3, "$1") : o8 || r10;
        }), e9;
      };
      P3 = function(r9, e9) {
        if (!(r9 in f$3))
          throw new SyntaxError("intrinsic " + r9 + " does not exist!");
        if (void 0 === f$3[r9] && !e9)
          throw new o$3("intrinsic " + r9 + " exists, but is not available. Please file an issue!");
        return f$3[r9];
      };
      c$2 = function(r9, e9) {
        if ("string" != typeof r9 || 0 === r9.length)
          throw new TypeError("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && "boolean" != typeof e9)
          throw new TypeError('"allowMissing" argument must be a boolean');
        for (var n8 = v4(r9), y6 = P3("%" + (n8.length > 0 ? n8[0] : "") + "%", e9), a7 = 1; a7 < n8.length; a7 += 1)
          if (null != y6)
            if (t$3 && a7 + 1 >= n8.length) {
              var i7 = t$3(y6, n8[a7]);
              if (!e9 && !(n8[a7] in y6))
                throw new o$3("base intrinsic for " + r9 + " exists, but the property is not available.");
              y6 = i7 ? i7.get || i7.value : y6[n8[a7]];
            } else
              y6 = y6[n8[a7]];
        return y6;
      };
      p$1 = e$4;
      o$4 = c$2("%Function%");
      i$2 = o$4.apply;
      a$3 = o$4.call;
      (t$4 = function() {
        return p$1.apply(a$3, arguments);
      }).apply = function() {
        return p$1.apply(i$2, arguments);
      };
      l$4 = t$4;
      i$3 = function(t8) {
        return t8 != t8;
      };
      o$5 = (r$4 = function(t8, e9) {
        return 0 === t8 && 0 === e9 ? 1 / t8 == 1 / e9 : t8 === e9 || !(!i$3(t8) || !i$3(e9));
      }, r$4);
      c$3 = (n$4 = function() {
        return "function" == typeof Object.is ? Object.is : o$5;
      }, n$4);
      f$4 = f$12;
      u$3 = f$12;
      s$12 = r$4;
      a$4 = n$4;
      l$5 = function() {
        var t8 = c$3();
        return f$4(Object, { is: t8 }, { is: function() {
          return Object.is !== t8;
        } }), t8;
      };
      p$2 = l$4(a$4(), Object);
      u$3(p$2, { getPolyfill: a$4, implementation: s$12, shim: l$5 });
      m4 = p$2;
      N3 = function(r9) {
        return r9 != r9;
      };
      i$4 = N3;
      n$5 = (e$5 = function() {
        return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : i$4;
      }, f$12);
      t$5 = e$5;
      u$4 = f$12;
      a$5 = N3;
      m$1 = e$5;
      o$6 = function() {
        var r9 = t$5();
        return n$5(Number, { isNaN: r9 }, { isNaN: function() {
          return Number.isNaN !== r9;
        } }), r9;
      };
      s$2 = m$1();
      u$4(s$2, { getPolyfill: m$1, implementation: a$5, shim: o$6 });
      f$5 = s$2;
      c$4 = {};
      a$6 = false;
      u$5 = {};
      l$6 = false;
      g$1 = void 0 !== /a/g.flags;
      h$1 = function(t8) {
        var e9 = [];
        return t8.forEach(function(t9) {
          return e9.push(t9);
        }), e9;
      };
      y$2 = function(t8) {
        var e9 = [];
        return t8.forEach(function(t9, n8) {
          return e9.push([n8, t9]);
        }), e9;
      };
      b$1 = Object.is ? Object.is : m4;
      v$1 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
        return [];
      };
      d$1 = Number.isNaN ? Number.isNaN : f$5;
      E3 = m$2(Object.prototype.hasOwnProperty);
      w$1 = m$2(Object.prototype.propertyIsEnumerable);
      S3 = m$2(Object.prototype.toString);
      j$1 = X.types;
      O3 = j$1.isAnyArrayBuffer;
      x3 = j$1.isArrayBufferView;
      q2 = j$1.isDate;
      R3 = j$1.isMap;
      A$1 = j$1.isRegExp;
      k3 = j$1.isSet;
      _3 = j$1.isNativeError;
      T4 = j$1.isBoxedPrimitive;
      P$1 = j$1.isNumberObject;
      I3 = j$1.isStringObject;
      D3 = j$1.isBooleanObject;
      F3 = j$1.isBigIntObject;
      N$1 = j$1.isSymbolObject;
      L3 = j$1.isFloat32Array;
      M3 = j$1.isFloat64Array;
      X2 = { isDeepEqual: function(t8, e9) {
        return B3(t8, e9, false);
      }, isDeepStrictEqual: function(t8, e9) {
        return B3(t8, e9, true);
      } };
      Z2 = {};
      $$1 = false;
      et = tt();
      et.AssertionError;
      et.deepEqual;
      et.deepStrictEqual;
      et.doesNotReject;
      et.doesNotThrow;
      et.equal;
      et.fail;
      et.ifError;
      et.notDeepEqual;
      et.notDeepStrictEqual;
      et.notEqual;
      et.notStrictEqual;
      et.ok;
      et.rejects;
      et.strict;
      et.strictEqual;
      et.throws;
      et.AssertionError;
      et.deepEqual;
      et.deepStrictEqual;
      et.doesNotReject;
      et.doesNotThrow;
      et.equal;
      et.fail;
      et.ifError;
      et.notDeepEqual;
      et.notDeepStrictEqual;
      et.notEqual;
      et.notStrictEqual;
      et.ok;
      et.rejects;
      et.strict;
      et.strictEqual;
      et.throws;
      AssertionError = et.AssertionError;
      deepEqual = et.deepEqual;
      deepStrictEqual = et.deepStrictEqual;
      doesNotReject = et.doesNotReject;
      doesNotThrow = et.doesNotThrow;
      equal = et.equal;
      fail = et.fail;
      ifError = et.ifError;
      notDeepEqual = et.notDeepEqual;
      notDeepStrictEqual = et.notDeepStrictEqual;
      notEqual = et.notEqual;
      notStrictEqual = et.notStrictEqual;
      ok = et.ok;
      rejects = et.rejects;
      strict = et.strict;
      strictEqual = et.strictEqual;
      throws = et.throws;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/util.js
  var _extend2, callbackify2, debuglog2, deprecate2, format2, inherits2, inspect2, isArray5, isBoolean2, isBuffer2, isDate2, isError2, isFunction3, isNull2, isNullOrUndefined2, isNumber2, isObject2, isPrimitive2, isRegExp2, isString2, isSymbol2, isUndefined2, log2, promisify2, types2, TextEncoder3, TextDecoder3;
  var init_util = __esm({
    "node_modules/@jspm/core/nodelibs/browser/util.js"() {
      init_dirname();
      init_buffer2();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      _extend2 = X._extend;
      callbackify2 = X.callbackify;
      debuglog2 = X.debuglog;
      deprecate2 = X.deprecate;
      format2 = X.format;
      inherits2 = X.inherits;
      inspect2 = X.inspect;
      isArray5 = X.isArray;
      isBoolean2 = X.isBoolean;
      isBuffer2 = X.isBuffer;
      isDate2 = X.isDate;
      isError2 = X.isError;
      isFunction3 = X.isFunction;
      isNull2 = X.isNull;
      isNullOrUndefined2 = X.isNullOrUndefined;
      isNumber2 = X.isNumber;
      isObject2 = X.isObject;
      isPrimitive2 = X.isPrimitive;
      isRegExp2 = X.isRegExp;
      isString2 = X.isString;
      isSymbol2 = X.isSymbol;
      isUndefined2 = X.isUndefined;
      log2 = X.log;
      promisify2 = X.promisify;
      types2 = X.types;
      TextEncoder3 = X.TextEncoder = globalThis.TextEncoder;
      TextDecoder3 = X.TextDecoder = globalThis.TextDecoder;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js
  function dew4() {
    if (_dewExec4)
      return exports$13;
    _dewExec4 = true;
    var process$1 = process3;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i7 = 0; i7 <= path2.length; ++i7) {
        if (i7 < path2.length)
          code = path2.charCodeAt(i7);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i7 - 1 || dots === 1)
            ;
          else if (lastSlash !== i7 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i7;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i7;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path2.slice(lastSlash + 1, i7);
            else
              res = path2.slice(lastSlash + 1, i7);
            lastSegmentLength = i7 - lastSlash - 1;
          }
          lastSlash = i7;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep2, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep2 + base;
    }
    var posix2 = {
      // path.resolve([from ...], to)
      resolve: function resolve3() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
          var path2;
          if (i7 >= 0)
            path2 = arguments[i7];
          else {
            if (cwd === void 0)
              cwd = process$1.cwd();
            path2 = cwd;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize2(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var isAbsolute2 = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute2);
        if (path2.length === 0 && !isAbsolute2)
          path2 = ".";
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute2)
          return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute2(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join2() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i7 = 0; i7 < arguments.length; ++i7) {
          var arg = arguments[i7];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix2.normalize(joined);
      },
      relative: function relative2(from2, to) {
        assertPath(from2);
        assertPath(to);
        if (from2 === to)
          return "";
        from2 = posix2.resolve(from2);
        to = posix2.resolve(to);
        if (from2 === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from2.length; ++fromStart) {
          if (from2.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from2.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i7 = 0;
        for (; i7 <= length; ++i7) {
          if (i7 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i7) === 47) {
                return to.slice(toStart + i7 + 1);
              } else if (i7 === 0) {
                return to.slice(toStart + i7);
              }
            } else if (fromLen > length) {
              if (from2.charCodeAt(fromStart + i7) === 47) {
                lastCommonSep = i7;
              } else if (i7 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from2.charCodeAt(fromStart + i7);
          var toCode = to.charCodeAt(toStart + i7);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i7;
        }
        var out = "";
        for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
          if (i7 === fromEnd || from2.charCodeAt(i7) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong2(path2) {
        return path2;
      },
      dirname: function dirname2(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var code = path2.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i7 = path2.length - 1; i7 >= 1; --i7) {
          code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              end = i7;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path2.slice(0, end);
      },
      basename: function basename2(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i7;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            var code = path2.charCodeAt(i7);
            if (code === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i7 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i7;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            if (path2.charCodeAt(i7) === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i7 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname2(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i7 = path2.length - 1; i7 >= 0; --i7) {
          var code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i7;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format5(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse3(path2) {
        assertPath(path2);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path2.length === 0)
          return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute2 = code === 47;
        var start;
        if (isAbsolute2) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i7 = path2.length - 1;
        var preDotState = 0;
        for (; i7 >= start; --i7) {
          code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i7;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute2)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute2) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute2)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix2.posix = posix2;
    exports$13 = posix2;
    return exports$13;
  }
  var exports$13, _dewExec4, exports4;
  var init_chunk_23dbec7b = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js"() {
      init_dirname();
      init_buffer2();
      init_chunk_2eac56ff();
      exports$13 = {};
      _dewExec4 = false;
      exports4 = dew4();
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/path.js
  var path_exports = {};
  __export(path_exports, {
    _makeLong: () => _makeLong,
    basename: () => basename,
    default: () => exports4,
    delimiter: () => delimiter,
    dirname: () => dirname,
    extname: () => extname,
    format: () => format3,
    isAbsolute: () => isAbsolute,
    join: () => join,
    normalize: () => normalize,
    parse: () => parse,
    posix: () => posix,
    relative: () => relative,
    resolve: () => resolve,
    sep: () => sep,
    win32: () => win32
  });
  var _makeLong, basename, delimiter, dirname, extname, format3, isAbsolute, join, normalize, parse, posix, relative, resolve, sep, win32;
  var init_path = __esm({
    "node_modules/@jspm/core/nodelibs/browser/path.js"() {
      init_dirname();
      init_buffer2();
      init_chunk_23dbec7b();
      init_chunk_23dbec7b();
      init_chunk_2eac56ff();
      _makeLong = exports4._makeLong;
      basename = exports4.basename;
      delimiter = exports4.delimiter;
      dirname = exports4.dirname;
      extname = exports4.extname;
      format3 = exports4.format;
      isAbsolute = exports4.isAbsolute;
      join = exports4.join;
      normalize = exports4.normalize;
      parse = exports4.parse;
      posix = exports4.posix;
      relative = exports4.relative;
      resolve = exports4.resolve;
      sep = exports4.sep;
      win32 = exports4.win32;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/events.js
  var EventEmitter, defaultMaxListeners, init, listenerCount, on, once;
  var init_events = __esm({
    "node_modules/@jspm/core/nodelibs/browser/events.js"() {
      init_dirname();
      init_buffer2();
      init_chunk_4bd36a8f();
      init_chunk_4bd36a8f();
      y.once = function(emitter, event) {
        return new Promise((resolve3, reject) => {
          function eventListener(...args) {
            if (errorListener !== void 0) {
              emitter.removeListener("error", errorListener);
            }
            resolve3(args);
          }
          let errorListener;
          if (event !== "error") {
            errorListener = (err) => {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          emitter.once(event, eventListener);
        });
      };
      y.on = function(emitter, event) {
        const unconsumedEventValues = [];
        const unconsumedPromises = [];
        let error = null;
        let finished2 = false;
        const iterator2 = {
          async next() {
            const value = unconsumedEventValues.shift();
            if (value) {
              return createIterResult(value, false);
            }
            if (error) {
              const p7 = Promise.reject(error);
              error = null;
              return p7;
            }
            if (finished2) {
              return createIterResult(void 0, true);
            }
            return new Promise((resolve3, reject) => unconsumedPromises.push({ resolve: resolve3, reject }));
          },
          async return() {
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
            finished2 = true;
            for (const promise of unconsumedPromises) {
              promise.resolve(createIterResult(void 0, true));
            }
            return createIterResult(void 0, true);
          },
          throw(err) {
            error = err;
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
        emitter.on(event, eventHandler);
        emitter.on("error", errorHandler);
        return iterator2;
        function eventHandler(...args) {
          const promise = unconsumedPromises.shift();
          if (promise) {
            promise.resolve(createIterResult(args, false));
          } else {
            unconsumedEventValues.push(args);
          }
        }
        function errorHandler(err) {
          finished2 = true;
          const toError = unconsumedPromises.shift();
          if (toError) {
            toError.reject(err);
          } else {
            error = err;
          }
          iterator2.return();
        }
      };
      ({
        EventEmitter,
        defaultMaxListeners,
        init,
        listenerCount,
        on,
        once
      } = y);
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-6c718bbe.js
  function dew5() {
    if (_dewExec5)
      return exports$14;
    _dewExec5 = true;
    exports$14 = Stream2;
    var EE = y.EventEmitter;
    var inherits3 = dew$f();
    inherits3(Stream2, EE);
    Stream2.Readable = dew$3();
    Stream2.Writable = dew$8();
    Stream2.Duplex = dew$7();
    Stream2.Transform = dew$22();
    Stream2.PassThrough = dew$12();
    Stream2.finished = dew$6();
    Stream2.pipeline = dew3();
    Stream2.Stream = Stream2;
    function Stream2() {
      EE.call(this || _global3);
    }
    Stream2.prototype.pipe = function(dest, options) {
      var source2 = this || _global3;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source2.pause) {
            source2.pause();
          }
        }
      }
      source2.on("data", ondata);
      function ondrain() {
        if (source2.readable && source2.resume) {
          source2.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source2.on("end", onend);
        source2.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this || _global3, "error") === 0) {
          throw er;
        }
      }
      source2.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source2.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source2.removeListener("end", onend);
        source2.removeListener("close", onclose);
        source2.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source2.removeListener("end", cleanup);
        source2.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source2.on("end", cleanup);
      source2.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source2);
      return dest;
    };
    return exports$14;
  }
  var exports$14, _dewExec5, _global3, exports5;
  var init_chunk_6c718bbe = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-6c718bbe.js"() {
      init_dirname();
      init_buffer2();
      init_events();
      init_chunk_44e51b61();
      init_chunk_4bd36a8f();
      exports$14 = {};
      _dewExec5 = false;
      _global3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports5 = dew5();
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/stream.js
  var Readable, Writable, Duplex, Transform, PassThrough, finished, pipeline, Stream, promises;
  var init_stream = __esm({
    "node_modules/@jspm/core/nodelibs/browser/stream.js"() {
      init_dirname();
      init_buffer2();
      init_chunk_6c718bbe();
      init_chunk_6c718bbe();
      init_util();
      init_events();
      init_chunk_4bd36a8f();
      init_chunk_44e51b61();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      init_chunk_2eac56ff();
      init_chunk_4ccc3a29();
      Readable = exports5.Readable;
      Readable.wrap = function(src, options) {
        options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
        options.destroy = function(err, callback) {
          src.destroy(err);
          callback(err);
        };
        return new Readable(options).wrap(src);
      };
      Writable = exports5.Writable;
      Duplex = exports5.Duplex;
      Transform = exports5.Transform;
      PassThrough = exports5.PassThrough;
      finished = exports5.finished;
      pipeline = exports5.pipeline;
      Stream = exports5.Stream;
      promises = {
        finished: promisify2(exports5.finished),
        pipeline: promisify2(exports5.pipeline)
      };
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js
  function i5(t8) {
    throw new RangeError(r6[t8]);
  }
  function f5(t8, o8) {
    const n8 = t8.split("@");
    let r9 = "";
    n8.length > 1 && (r9 = n8[0] + "@", t8 = n8[1]);
    const c7 = function(t9, o9) {
      const n9 = [];
      let e9 = t9.length;
      for (; e9--; )
        n9[e9] = o9(t9[e9]);
      return n9;
    }((t8 = t8.replace(e6, ".")).split("."), o8).join(".");
    return r9 + c7;
  }
  function l5(t8) {
    const o8 = [];
    let n8 = 0;
    const e9 = t8.length;
    for (; n8 < e9; ) {
      const r9 = t8.charCodeAt(n8++);
      if (r9 >= 55296 && r9 <= 56319 && n8 < e9) {
        const e10 = t8.charCodeAt(n8++);
        56320 == (64512 & e10) ? o8.push(((1023 & r9) << 10) + (1023 & e10) + 65536) : (o8.push(r9), n8--);
      } else
        o8.push(r9);
    }
    return o8;
  }
  var t6, o5, n5, e6, r6, c5, s5, u5, a5, d5, h6, p5;
  var init_chunk_924bb2e1 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js"() {
      init_dirname();
      init_buffer2();
      t6 = 2147483647;
      o5 = /^xn--/;
      n5 = /[^\0-\x7E]/;
      e6 = /[\x2E\u3002\uFF0E\uFF61]/g;
      r6 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
      c5 = Math.floor;
      s5 = String.fromCharCode;
      u5 = function(t8, o8) {
        return t8 + 22 + 75 * (t8 < 26) - ((0 != o8) << 5);
      };
      a5 = function(t8, o8, n8) {
        let e9 = 0;
        for (t8 = n8 ? c5(t8 / 700) : t8 >> 1, t8 += c5(t8 / o8); t8 > 455; e9 += 36)
          t8 = c5(t8 / 35);
        return c5(e9 + 36 * t8 / (t8 + 38));
      };
      d5 = function(o8) {
        const n8 = [], e9 = o8.length;
        let r9 = 0, s6 = 128, f7 = 72, l7 = o8.lastIndexOf("-");
        l7 < 0 && (l7 = 0);
        for (let t8 = 0; t8 < l7; ++t8)
          o8.charCodeAt(t8) >= 128 && i5("not-basic"), n8.push(o8.charCodeAt(t8));
        for (let d6 = l7 > 0 ? l7 + 1 : 0; d6 < e9; ) {
          let l8 = r9;
          for (let n9 = 1, s7 = 36; ; s7 += 36) {
            d6 >= e9 && i5("invalid-input");
            const l9 = (u7 = o8.charCodeAt(d6++)) - 48 < 10 ? u7 - 22 : u7 - 65 < 26 ? u7 - 65 : u7 - 97 < 26 ? u7 - 97 : 36;
            (l9 >= 36 || l9 > c5((t6 - r9) / n9)) && i5("overflow"), r9 += l9 * n9;
            const a7 = s7 <= f7 ? 1 : s7 >= f7 + 26 ? 26 : s7 - f7;
            if (l9 < a7)
              break;
            const h9 = 36 - a7;
            n9 > c5(t6 / h9) && i5("overflow"), n9 *= h9;
          }
          const h8 = n8.length + 1;
          f7 = a5(r9 - l8, h8, 0 == l8), c5(r9 / h8) > t6 - s6 && i5("overflow"), s6 += c5(r9 / h8), r9 %= h8, n8.splice(r9++, 0, s6);
        }
        var u7;
        return String.fromCodePoint(...n8);
      };
      h6 = function(o8) {
        const n8 = [];
        let e9 = (o8 = l5(o8)).length, r9 = 128, f7 = 0, d6 = 72;
        for (const t8 of o8)
          t8 < 128 && n8.push(s5(t8));
        let h8 = n8.length, p7 = h8;
        for (h8 && n8.push("-"); p7 < e9; ) {
          let e10 = t6;
          for (const t8 of o8)
            t8 >= r9 && t8 < e10 && (e10 = t8);
          const l7 = p7 + 1;
          e10 - r9 > c5((t6 - f7) / l7) && i5("overflow"), f7 += (e10 - r9) * l7, r9 = e10;
          for (const e11 of o8)
            if (e11 < r9 && ++f7 > t6 && i5("overflow"), e11 == r9) {
              let t8 = f7;
              for (let o9 = 36; ; o9 += 36) {
                const e12 = o9 <= d6 ? 1 : o9 >= d6 + 26 ? 26 : o9 - d6;
                if (t8 < e12)
                  break;
                const r10 = t8 - e12, i7 = 36 - e12;
                n8.push(s5(u5(e12 + r10 % i7, 0))), t8 = c5(r10 / i7);
              }
              n8.push(s5(u5(t8, 0))), d6 = a5(f7, l7, p7 == h8), f7 = 0, ++p7;
            }
          ++f7, ++r9;
        }
        return n8.join("");
      };
      p5 = { version: "2.1.0", ucs2: { decode: l5, encode: (t8) => String.fromCodePoint(...t8) }, decode: d5, encode: h6, toASCII: function(t8) {
        return f5(t8, function(t9) {
          return n5.test(t9) ? "xn--" + h6(t9) : t9;
        });
      }, toUnicode: function(t8) {
        return f5(t8, function(t9) {
          return o5.test(t9) ? d5(t9.slice(4).toLowerCase()) : t9;
        });
      } };
      p5.decode;
      p5.encode;
      p5.toASCII;
      p5.toUnicode;
      p5.ucs2;
      p5.version;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js
  function e7(e9, n8) {
    return Object.prototype.hasOwnProperty.call(e9, n8);
  }
  var n6, r7, t7, o6;
  var init_chunk_b04e620d = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js"() {
      init_dirname();
      init_buffer2();
      n6 = function(n8, r9, t8, o8) {
        r9 = r9 || "&", t8 = t8 || "=";
        var a7 = {};
        if ("string" != typeof n8 || 0 === n8.length)
          return a7;
        var u7 = /\+/g;
        n8 = n8.split(r9);
        var c7 = 1e3;
        o8 && "number" == typeof o8.maxKeys && (c7 = o8.maxKeys);
        var i7 = n8.length;
        c7 > 0 && i7 > c7 && (i7 = c7);
        for (var s6 = 0; s6 < i7; ++s6) {
          var p7, f7, d6, y6, m6 = n8[s6].replace(u7, "%20"), l7 = m6.indexOf(t8);
          l7 >= 0 ? (p7 = m6.substr(0, l7), f7 = m6.substr(l7 + 1)) : (p7 = m6, f7 = ""), d6 = decodeURIComponent(p7), y6 = decodeURIComponent(f7), e7(a7, d6) ? Array.isArray(a7[d6]) ? a7[d6].push(y6) : a7[d6] = [a7[d6], y6] : a7[d6] = y6;
        }
        return a7;
      };
      r7 = function(e9) {
        switch (typeof e9) {
          case "string":
            return e9;
          case "boolean":
            return e9 ? "true" : "false";
          case "number":
            return isFinite(e9) ? e9 : "";
          default:
            return "";
        }
      };
      t7 = function(e9, n8, t8, o8) {
        return n8 = n8 || "&", t8 = t8 || "=", null === e9 && (e9 = void 0), "object" == typeof e9 ? Object.keys(e9).map(function(o9) {
          var a7 = encodeURIComponent(r7(o9)) + t8;
          return Array.isArray(e9[o9]) ? e9[o9].map(function(e10) {
            return a7 + encodeURIComponent(r7(e10));
          }).join(n8) : a7 + encodeURIComponent(r7(e9[o9]));
        }).join(n8) : o8 ? encodeURIComponent(r7(o8)) + t8 + encodeURIComponent(r7(e9)) : "";
      };
      o6 = {};
      o6.decode = o6.parse = n6, o6.encode = o6.stringify = t7;
      o6.decode;
      o6.encode;
      o6.parse;
      o6.stringify;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/url.js
  function r8() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  function O4(t8, s6, h8) {
    if (t8 && a6.isObject(t8) && t8 instanceof r8)
      return t8;
    var e9 = new r8();
    return e9.parse(t8, s6, h8), e9;
  }
  function dew6() {
    if (_dewExec6)
      return exports6;
    _dewExec6 = true;
    var process4 = T;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i7 = 0; i7 <= path2.length; ++i7) {
        if (i7 < path2.length)
          code = path2.charCodeAt(i7);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i7 - 1 || dots === 1)
            ;
          else if (lastSlash !== i7 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i7;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i7;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path2.slice(lastSlash + 1, i7);
            else
              res = path2.slice(lastSlash + 1, i7);
            lastSegmentLength = i7 - lastSlash - 1;
          }
          lastSlash = i7;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep2, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep2 + base;
    }
    var posix2 = {
      // path.resolve([from ...], to)
      resolve: function resolve3() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
          var path2;
          if (i7 >= 0)
            path2 = arguments[i7];
          else {
            if (cwd === void 0)
              cwd = process4.cwd();
            path2 = cwd;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize2(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var isAbsolute2 = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute2);
        if (path2.length === 0 && !isAbsolute2)
          path2 = ".";
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute2)
          return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute2(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join2() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i7 = 0; i7 < arguments.length; ++i7) {
          var arg = arguments[i7];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix2.normalize(joined);
      },
      relative: function relative2(from2, to) {
        assertPath(from2);
        assertPath(to);
        if (from2 === to)
          return "";
        from2 = posix2.resolve(from2);
        to = posix2.resolve(to);
        if (from2 === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from2.length; ++fromStart) {
          if (from2.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from2.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i7 = 0;
        for (; i7 <= length; ++i7) {
          if (i7 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i7) === 47) {
                return to.slice(toStart + i7 + 1);
              } else if (i7 === 0) {
                return to.slice(toStart + i7);
              }
            } else if (fromLen > length) {
              if (from2.charCodeAt(fromStart + i7) === 47) {
                lastCommonSep = i7;
              } else if (i7 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from2.charCodeAt(fromStart + i7);
          var toCode = to.charCodeAt(toStart + i7);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i7;
        }
        var out = "";
        for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
          if (i7 === fromEnd || from2.charCodeAt(i7) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong2(path2) {
        return path2;
      },
      dirname: function dirname2(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var code = path2.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i7 = path2.length - 1; i7 >= 1; --i7) {
          code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              end = i7;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path2.slice(0, end);
      },
      basename: function basename2(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i7;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            var code = path2.charCodeAt(i7);
            if (code === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i7 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i7;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            if (path2.charCodeAt(i7) === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i7 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname2(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i7 = path2.length - 1; i7 >= 0; --i7) {
          var code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i7;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format5(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse3(path2) {
        assertPath(path2);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path2.length === 0)
          return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute2 = code === 47;
        var start;
        if (isAbsolute2) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i7 = path2.length - 1;
        var preDotState = 0;
        for (; i7 >= start; --i7) {
          code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i7;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute2)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute2) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute2)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix2.posix = posix2;
    exports6 = posix2;
    return exports6;
  }
  function fileURLToPath$1(path2) {
    if (typeof path2 === "string")
      path2 = new URL(path2);
    else if (!(path2 instanceof URL)) {
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    }
    if (path2.protocol !== "file:") {
      throw new Deno.errors.InvalidData("invalid url scheme");
    }
    return isWindows$1 ? getPathFromURLWin$1(path2) : getPathFromURLPosix$1(path2);
  }
  function getPathFromURLWin$1(url) {
    const hostname = url.hostname;
    let pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102 || // 2f 2F /
        pathname[n8 + 1] === "5" && third === 99) {
          throw new Deno.errors.InvalidData(
            "must not include encoded \\ or / characters"
          );
        }
      }
    }
    pathname = pathname.replace(forwardSlashRegEx$1, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname !== "") {
      return `\\\\${hostname}${pathname}`;
    } else {
      const letter = pathname.codePointAt(1) | 32;
      const sep2 = pathname[2];
      if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
      sep2 !== ":") {
        throw new Deno.errors.InvalidData("file url path must be absolute");
      }
      return pathname.slice(1);
    }
  }
  function getPathFromURLPosix$1(url) {
    if (url.hostname !== "") {
      throw new Deno.errors.InvalidData("invalid file url hostname");
    }
    const pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102) {
          throw new Deno.errors.InvalidData(
            "must not include encoded / characters"
          );
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFileURL$1(filepath) {
    let resolved = path.resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
      resolved += "/";
    }
    const outURL = new URL("file://");
    if (resolved.includes("%"))
      resolved = resolved.replace(percentRegEx$1, "%25");
    if (!isWindows$1 && resolved.includes("\\")) {
      resolved = resolved.replace(backslashRegEx$1, "%5C");
    }
    if (resolved.includes("\n"))
      resolved = resolved.replace(newlineRegEx$1, "%0A");
    if (resolved.includes("\r")) {
      resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
    }
    if (resolved.includes("	"))
      resolved = resolved.replace(tabRegEx$1, "%09");
    outURL.pathname = resolved;
    return outURL;
  }
  function fileURLToPath(path2) {
    if (typeof path2 === "string")
      path2 = new URL(path2);
    else if (!(path2 instanceof URL)) {
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    }
    if (path2.protocol !== "file:") {
      throw new Deno.errors.InvalidData("invalid url scheme");
    }
    return isWindows ? getPathFromURLWin(path2) : getPathFromURLPosix(path2);
  }
  function getPathFromURLWin(url) {
    const hostname = url.hostname;
    let pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102 || // 2f 2F /
        pathname[n8 + 1] === "5" && third === 99) {
          throw new Deno.errors.InvalidData(
            "must not include encoded \\ or / characters"
          );
        }
      }
    }
    pathname = pathname.replace(forwardSlashRegEx, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname !== "") {
      return `\\\\${hostname}${pathname}`;
    } else {
      const letter = pathname.codePointAt(1) | 32;
      const sep2 = pathname[2];
      if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
      sep2 !== ":") {
        throw new Deno.errors.InvalidData("file url path must be absolute");
      }
      return pathname.slice(1);
    }
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      throw new Deno.errors.InvalidData("invalid file url hostname");
    }
    const pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102) {
          throw new Deno.errors.InvalidData(
            "must not include encoded / characters"
          );
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFileURL(filepath) {
    let resolved = exports4.resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports4.sep) {
      resolved += "/";
    }
    const outURL = new URL("file://");
    if (resolved.includes("%"))
      resolved = resolved.replace(percentRegEx, "%25");
    if (!isWindows && resolved.includes("\\")) {
      resolved = resolved.replace(backslashRegEx, "%5C");
    }
    if (resolved.includes("\n"))
      resolved = resolved.replace(newlineRegEx, "%0A");
    if (resolved.includes("\r")) {
      resolved = resolved.replace(carriageReturnRegEx, "%0D");
    }
    if (resolved.includes("	"))
      resolved = resolved.replace(tabRegEx, "%09");
    outURL.pathname = resolved;
    return outURL;
  }
  var h7, e8, a6, o7, n7, i6, l6, p6, c6, u6, f6, m5, v5, g4, y5, b4, exports6, _dewExec6, path, processPlatform$1, CHAR_BACKWARD_SLASH$1, CHAR_FORWARD_SLASH$1, CHAR_LOWERCASE_A$1, CHAR_LOWERCASE_Z$1, isWindows$1, forwardSlashRegEx$1, percentRegEx$1, backslashRegEx$1, newlineRegEx$1, carriageReturnRegEx$1, tabRegEx$1, processPlatform, Url, format4, resolve2, resolveObject, parse2, _URL, CHAR_BACKWARD_SLASH, CHAR_FORWARD_SLASH, CHAR_LOWERCASE_A, CHAR_LOWERCASE_Z, isWindows, forwardSlashRegEx, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx;
  var init_url = __esm({
    "node_modules/@jspm/core/nodelibs/browser/url.js"() {
      init_dirname();
      init_buffer2();
      init_chunk_924bb2e1();
      init_chunk_b04e620d();
      init_chunk_5decc758();
      init_chunk_23dbec7b();
      init_chunk_2eac56ff();
      h7 = {};
      e8 = p5;
      a6 = { isString: function(t8) {
        return "string" == typeof t8;
      }, isObject: function(t8) {
        return "object" == typeof t8 && null !== t8;
      }, isNull: function(t8) {
        return null === t8;
      }, isNullOrUndefined: function(t8) {
        return null == t8;
      } };
      h7.parse = O4, h7.resolve = function(t8, s6) {
        return O4(t8, false, true).resolve(s6);
      }, h7.resolveObject = function(t8, s6) {
        return t8 ? O4(t8, false, true).resolveObject(s6) : s6;
      }, h7.format = function(t8) {
        a6.isString(t8) && (t8 = O4(t8));
        return t8 instanceof r8 ? t8.format() : r8.prototype.format.call(t8);
      }, h7.Url = r8;
      o7 = /^([a-z0-9.+-]+:)/i;
      n7 = /:[0-9]*$/;
      i6 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
      l6 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
      p6 = ["'"].concat(l6);
      c6 = ["%", "/", "?", ";", "#"].concat(p6);
      u6 = ["/", "?", "#"];
      f6 = /^[+a-z0-9A-Z_-]{0,63}$/;
      m5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
      v5 = { javascript: true, "javascript:": true };
      g4 = { javascript: true, "javascript:": true };
      y5 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
      b4 = o6;
      r8.prototype.parse = function(t8, s6, h8) {
        if (!a6.isString(t8))
          throw new TypeError("Parameter 'url' must be a string, not " + typeof t8);
        var r9 = t8.indexOf("?"), n8 = -1 !== r9 && r9 < t8.indexOf("#") ? "?" : "#", l7 = t8.split(n8);
        l7[0] = l7[0].replace(/\\/g, "/");
        var O5 = t8 = l7.join(n8);
        if (O5 = O5.trim(), !h8 && 1 === t8.split("#").length) {
          var d6 = i6.exec(O5);
          if (d6)
            return this.path = O5, this.href = O5, this.pathname = d6[1], d6[2] ? (this.search = d6[2], this.query = s6 ? b4.parse(this.search.substr(1)) : this.search.substr(1)) : s6 && (this.search = "", this.query = {}), this;
        }
        var j4 = o7.exec(O5);
        if (j4) {
          var q3 = (j4 = j4[0]).toLowerCase();
          this.protocol = q3, O5 = O5.substr(j4.length);
        }
        if (h8 || j4 || O5.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var x4 = "//" === O5.substr(0, 2);
          !x4 || j4 && g4[j4] || (O5 = O5.substr(2), this.slashes = true);
        }
        if (!g4[j4] && (x4 || j4 && !y5[j4])) {
          for (var A4, C4, I4 = -1, w4 = 0; w4 < u6.length; w4++) {
            -1 !== (N4 = O5.indexOf(u6[w4])) && (-1 === I4 || N4 < I4) && (I4 = N4);
          }
          -1 !== (C4 = -1 === I4 ? O5.lastIndexOf("@") : O5.lastIndexOf("@", I4)) && (A4 = O5.slice(0, C4), O5 = O5.slice(C4 + 1), this.auth = decodeURIComponent(A4)), I4 = -1;
          for (w4 = 0; w4 < c6.length; w4++) {
            var N4;
            -1 !== (N4 = O5.indexOf(c6[w4])) && (-1 === I4 || N4 < I4) && (I4 = N4);
          }
          -1 === I4 && (I4 = O5.length), this.host = O5.slice(0, I4), O5 = O5.slice(I4), this.parseHost(), this.hostname = this.hostname || "";
          var U4 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
          if (!U4)
            for (var k4 = this.hostname.split(/\./), S4 = (w4 = 0, k4.length); w4 < S4; w4++) {
              var R4 = k4[w4];
              if (R4 && !R4.match(f6)) {
                for (var $3 = "", z4 = 0, H3 = R4.length; z4 < H3; z4++)
                  R4.charCodeAt(z4) > 127 ? $3 += "x" : $3 += R4[z4];
                if (!$3.match(f6)) {
                  var L4 = k4.slice(0, w4), Z3 = k4.slice(w4 + 1), _4 = R4.match(m5);
                  _4 && (L4.push(_4[1]), Z3.unshift(_4[2])), Z3.length && (O5 = "/" + Z3.join(".") + O5), this.hostname = L4.join(".");
                  break;
                }
              }
            }
          this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U4 || (this.hostname = e8.toASCII(this.hostname));
          var E4 = this.port ? ":" + this.port : "", P4 = this.hostname || "";
          this.host = P4 + E4, this.href += this.host, U4 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O5[0] && (O5 = "/" + O5));
        }
        if (!v5[q3])
          for (w4 = 0, S4 = p6.length; w4 < S4; w4++) {
            var T5 = p6[w4];
            if (-1 !== O5.indexOf(T5)) {
              var B4 = encodeURIComponent(T5);
              B4 === T5 && (B4 = escape(T5)), O5 = O5.split(T5).join(B4);
            }
          }
        var D4 = O5.indexOf("#");
        -1 !== D4 && (this.hash = O5.substr(D4), O5 = O5.slice(0, D4));
        var F4 = O5.indexOf("?");
        if (-1 !== F4 ? (this.search = O5.substr(F4), this.query = O5.substr(F4 + 1), s6 && (this.query = b4.parse(this.query)), O5 = O5.slice(0, F4)) : s6 && (this.search = "", this.query = {}), O5 && (this.pathname = O5), y5[q3] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          E4 = this.pathname || "";
          var G3 = this.search || "";
          this.path = E4 + G3;
        }
        return this.href = this.format(), this;
      }, r8.prototype.format = function() {
        var t8 = this.auth || "";
        t8 && (t8 = (t8 = encodeURIComponent(t8)).replace(/%3A/i, ":"), t8 += "@");
        var s6 = this.protocol || "", h8 = this.pathname || "", e9 = this.hash || "", r9 = false, o8 = "";
        this.host ? r9 = t8 + this.host : this.hostname && (r9 = t8 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r9 += ":" + this.port)), this.query && a6.isObject(this.query) && Object.keys(this.query).length && (o8 = b4.stringify(this.query));
        var n8 = this.search || o8 && "?" + o8 || "";
        return s6 && ":" !== s6.substr(-1) && (s6 += ":"), this.slashes || (!s6 || y5[s6]) && false !== r9 ? (r9 = "//" + (r9 || ""), h8 && "/" !== h8.charAt(0) && (h8 = "/" + h8)) : r9 || (r9 = ""), e9 && "#" !== e9.charAt(0) && (e9 = "#" + e9), n8 && "?" !== n8.charAt(0) && (n8 = "?" + n8), s6 + r9 + (h8 = h8.replace(/[?#]/g, function(t9) {
          return encodeURIComponent(t9);
        })) + (n8 = n8.replace("#", "%23")) + e9;
      }, r8.prototype.resolve = function(t8) {
        return this.resolveObject(O4(t8, false, true)).format();
      }, r8.prototype.resolveObject = function(t8) {
        if (a6.isString(t8)) {
          var s6 = new r8();
          s6.parse(t8, false, true), t8 = s6;
        }
        for (var h8 = new r8(), e9 = Object.keys(this), o8 = 0; o8 < e9.length; o8++) {
          var n8 = e9[o8];
          h8[n8] = this[n8];
        }
        if (h8.hash = t8.hash, "" === t8.href)
          return h8.href = h8.format(), h8;
        if (t8.slashes && !t8.protocol) {
          for (var i7 = Object.keys(t8), l7 = 0; l7 < i7.length; l7++) {
            var p7 = i7[l7];
            "protocol" !== p7 && (h8[p7] = t8[p7]);
          }
          return y5[h8.protocol] && h8.hostname && !h8.pathname && (h8.path = h8.pathname = "/"), h8.href = h8.format(), h8;
        }
        if (t8.protocol && t8.protocol !== h8.protocol) {
          if (!y5[t8.protocol]) {
            for (var c7 = Object.keys(t8), u7 = 0; u7 < c7.length; u7++) {
              var f7 = c7[u7];
              h8[f7] = t8[f7];
            }
            return h8.href = h8.format(), h8;
          }
          if (h8.protocol = t8.protocol, t8.host || g4[t8.protocol])
            h8.pathname = t8.pathname;
          else {
            for (var m6 = (t8.pathname || "").split("/"); m6.length && !(t8.host = m6.shift()); )
              ;
            t8.host || (t8.host = ""), t8.hostname || (t8.hostname = ""), "" !== m6[0] && m6.unshift(""), m6.length < 2 && m6.unshift(""), h8.pathname = m6.join("/");
          }
          if (h8.search = t8.search, h8.query = t8.query, h8.host = t8.host || "", h8.auth = t8.auth, h8.hostname = t8.hostname || t8.host, h8.port = t8.port, h8.pathname || h8.search) {
            var v6 = h8.pathname || "", b5 = h8.search || "";
            h8.path = v6 + b5;
          }
          return h8.slashes = h8.slashes || t8.slashes, h8.href = h8.format(), h8;
        }
        var O5 = h8.pathname && "/" === h8.pathname.charAt(0), d6 = t8.host || t8.pathname && "/" === t8.pathname.charAt(0), j4 = d6 || O5 || h8.host && t8.pathname, q3 = j4, x4 = h8.pathname && h8.pathname.split("/") || [], A4 = (m6 = t8.pathname && t8.pathname.split("/") || [], h8.protocol && !y5[h8.protocol]);
        if (A4 && (h8.hostname = "", h8.port = null, h8.host && ("" === x4[0] ? x4[0] = h8.host : x4.unshift(h8.host)), h8.host = "", t8.protocol && (t8.hostname = null, t8.port = null, t8.host && ("" === m6[0] ? m6[0] = t8.host : m6.unshift(t8.host)), t8.host = null), j4 = j4 && ("" === m6[0] || "" === x4[0])), d6)
          h8.host = t8.host || "" === t8.host ? t8.host : h8.host, h8.hostname = t8.hostname || "" === t8.hostname ? t8.hostname : h8.hostname, h8.search = t8.search, h8.query = t8.query, x4 = m6;
        else if (m6.length)
          x4 || (x4 = []), x4.pop(), x4 = x4.concat(m6), h8.search = t8.search, h8.query = t8.query;
        else if (!a6.isNullOrUndefined(t8.search)) {
          if (A4)
            h8.hostname = h8.host = x4.shift(), (U4 = !!(h8.host && h8.host.indexOf("@") > 0) && h8.host.split("@")) && (h8.auth = U4.shift(), h8.host = h8.hostname = U4.shift());
          return h8.search = t8.search, h8.query = t8.query, a6.isNull(h8.pathname) && a6.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : "") + (h8.search ? h8.search : "")), h8.href = h8.format(), h8;
        }
        if (!x4.length)
          return h8.pathname = null, h8.search ? h8.path = "/" + h8.search : h8.path = null, h8.href = h8.format(), h8;
        for (var C4 = x4.slice(-1)[0], I4 = (h8.host || t8.host || x4.length > 1) && ("." === C4 || ".." === C4) || "" === C4, w4 = 0, N4 = x4.length; N4 >= 0; N4--)
          "." === (C4 = x4[N4]) ? x4.splice(N4, 1) : ".." === C4 ? (x4.splice(N4, 1), w4++) : w4 && (x4.splice(N4, 1), w4--);
        if (!j4 && !q3)
          for (; w4--; w4)
            x4.unshift("..");
        !j4 || "" === x4[0] || x4[0] && "/" === x4[0].charAt(0) || x4.unshift(""), I4 && "/" !== x4.join("/").substr(-1) && x4.push("");
        var U4, k4 = "" === x4[0] || x4[0] && "/" === x4[0].charAt(0);
        A4 && (h8.hostname = h8.host = k4 ? "" : x4.length ? x4.shift() : "", (U4 = !!(h8.host && h8.host.indexOf("@") > 0) && h8.host.split("@")) && (h8.auth = U4.shift(), h8.host = h8.hostname = U4.shift()));
        return (j4 = j4 || h8.host && x4.length) && !k4 && x4.unshift(""), x4.length ? h8.pathname = x4.join("/") : (h8.pathname = null, h8.path = null), a6.isNull(h8.pathname) && a6.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : "") + (h8.search ? h8.search : "")), h8.auth = t8.auth || h8.auth, h8.slashes = h8.slashes || t8.slashes, h8.href = h8.format(), h8;
      }, r8.prototype.parseHost = function() {
        var t8 = this.host, s6 = n7.exec(t8);
        s6 && (":" !== (s6 = s6[0]) && (this.port = s6.substr(1)), t8 = t8.substr(0, t8.length - s6.length)), t8 && (this.hostname = t8);
      };
      h7.Url;
      h7.format;
      h7.resolve;
      h7.resolveObject;
      exports6 = {};
      _dewExec6 = false;
      path = dew6();
      processPlatform$1 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
      h7.URL = typeof URL !== "undefined" ? URL : null;
      h7.pathToFileURL = pathToFileURL$1;
      h7.fileURLToPath = fileURLToPath$1;
      h7.Url;
      h7.format;
      h7.resolve;
      h7.resolveObject;
      h7.URL;
      CHAR_BACKWARD_SLASH$1 = 92;
      CHAR_FORWARD_SLASH$1 = 47;
      CHAR_LOWERCASE_A$1 = 97;
      CHAR_LOWERCASE_Z$1 = 122;
      isWindows$1 = processPlatform$1 === "win32";
      forwardSlashRegEx$1 = /\//g;
      percentRegEx$1 = /%/g;
      backslashRegEx$1 = /\\/g;
      newlineRegEx$1 = /\n/g;
      carriageReturnRegEx$1 = /\r/g;
      tabRegEx$1 = /\t/g;
      processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
      h7.URL = typeof URL !== "undefined" ? URL : null;
      h7.pathToFileURL = pathToFileURL;
      h7.fileURLToPath = fileURLToPath;
      Url = h7.Url;
      format4 = h7.format;
      resolve2 = h7.resolve;
      resolveObject = h7.resolveObject;
      parse2 = h7.parse;
      _URL = h7.URL;
      CHAR_BACKWARD_SLASH = 92;
      CHAR_FORWARD_SLASH = 47;
      CHAR_LOWERCASE_A = 97;
      CHAR_LOWERCASE_Z = 122;
      isWindows = processPlatform === "win32";
      forwardSlashRegEx = /\//g;
      percentRegEx = /%/g;
      backslashRegEx = /\\/g;
      newlineRegEx = /\n/g;
      carriageReturnRegEx = /\r/g;
      tabRegEx = /\t/g;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/fs.js
  function dew$f2() {
    if (_dewExec$f2)
      return exports$h;
    _dewExec$f2 = true;
    Object.defineProperty(exports$h, "__esModule", {
      value: true
    });
    exports$h.constants = void 0;
    exports$h.constants = {
      O_RDONLY: 0,
      O_WRONLY: 1,
      O_RDWR: 2,
      S_IFMT: 61440,
      S_IFREG: 32768,
      S_IFDIR: 16384,
      S_IFCHR: 8192,
      S_IFBLK: 24576,
      S_IFIFO: 4096,
      S_IFLNK: 40960,
      S_IFSOCK: 49152,
      O_CREAT: 64,
      O_EXCL: 128,
      O_NOCTTY: 256,
      O_TRUNC: 512,
      O_APPEND: 1024,
      O_DIRECTORY: 65536,
      O_NOATIME: 262144,
      O_NOFOLLOW: 131072,
      O_SYNC: 1052672,
      O_DIRECT: 16384,
      O_NONBLOCK: 2048,
      S_IRWXU: 448,
      S_IRUSR: 256,
      S_IWUSR: 128,
      S_IXUSR: 64,
      S_IRWXG: 56,
      S_IRGRP: 32,
      S_IWGRP: 16,
      S_IXGRP: 8,
      S_IRWXO: 7,
      S_IROTH: 4,
      S_IWOTH: 2,
      S_IXOTH: 1,
      F_OK: 0,
      R_OK: 4,
      W_OK: 2,
      X_OK: 1,
      UV_FS_SYMLINK_DIR: 1,
      UV_FS_SYMLINK_JUNCTION: 2,
      UV_FS_COPYFILE_EXCL: 1,
      UV_FS_COPYFILE_FICLONE: 2,
      UV_FS_COPYFILE_FICLONE_FORCE: 4,
      COPYFILE_EXCL: 1,
      COPYFILE_FICLONE: 2,
      COPYFILE_FICLONE_FORCE: 4
    };
    return exports$h;
  }
  function dew$e2() {
    if (_dewExec$e2)
      return exports$g2;
    _dewExec$e2 = true;
    if (typeof BigInt === "function")
      exports$g2.default = BigInt;
    else
      exports$g2.default = function BigIntNotSupported() {
        throw new Error("BigInt is not supported in this environment.");
      };
    return exports$g2;
  }
  function dew$d2() {
    if (_dewExec$d2)
      return exports$f2;
    _dewExec$d2 = true;
    Object.defineProperty(exports$f2, "__esModule", {
      value: true
    });
    exports$f2.Stats = void 0;
    var constants_1 = dew$f2();
    var getBigInt_1 = dew$e2();
    var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
    var Stats2 = function() {
      function Stats3() {
      }
      Stats3.build = function(node, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var stats = new Stats3();
        var uid = node.uid, gid = node.gid, atime = node.atime, mtime = node.mtime, ctime = node.ctime;
        var getStatNumber = !bigint ? function(number) {
          return number;
        } : getBigInt_1.default;
        stats.uid = getStatNumber(uid);
        stats.gid = getStatNumber(gid);
        stats.rdev = getStatNumber(0);
        stats.blksize = getStatNumber(4096);
        stats.ino = getStatNumber(node.ino);
        stats.size = getStatNumber(node.getSize());
        stats.blocks = getStatNumber(1);
        stats.atime = atime;
        stats.mtime = mtime;
        stats.ctime = ctime;
        stats.birthtime = ctime;
        stats.atimeMs = getStatNumber(atime.getTime());
        stats.mtimeMs = getStatNumber(mtime.getTime());
        var ctimeMs = getStatNumber(ctime.getTime());
        stats.ctimeMs = ctimeMs;
        stats.birthtimeMs = ctimeMs;
        stats.dev = getStatNumber(0);
        stats.mode = getStatNumber(node.mode);
        stats.nlink = getStatNumber(node.nlink);
        return stats;
      };
      Stats3.prototype._checkModeProperty = function(property) {
        return (Number(this.mode) & S_IFMT) === property;
      };
      Stats3.prototype.isDirectory = function() {
        return this._checkModeProperty(S_IFDIR);
      };
      Stats3.prototype.isFile = function() {
        return this._checkModeProperty(S_IFREG);
      };
      Stats3.prototype.isBlockDevice = function() {
        return this._checkModeProperty(S_IFBLK);
      };
      Stats3.prototype.isCharacterDevice = function() {
        return this._checkModeProperty(S_IFCHR);
      };
      Stats3.prototype.isSymbolicLink = function() {
        return this._checkModeProperty(S_IFLNK);
      };
      Stats3.prototype.isFIFO = function() {
        return this._checkModeProperty(S_IFIFO);
      };
      Stats3.prototype.isSocket = function() {
        return this._checkModeProperty(S_IFSOCK);
      };
      return Stats3;
    }();
    exports$f2.Stats = Stats2;
    exports$f2.default = Stats2;
    return exports$f2;
  }
  function dew$c2() {
    if (_dewExec$c2)
      return exports$e2;
    _dewExec$c2 = true;
    var __spreadArray2 = exports$e2 && exports$e2.__spreadArray || function(to, from2, pack) {
      if (pack || arguments.length === 2)
        for (var i7 = 0, l7 = from2.length, ar; i7 < l7; i7++) {
          if (ar || !(i7 in from2)) {
            if (!ar)
              ar = Array.prototype.slice.call(from2, 0, i7);
            ar[i7] = from2[i7];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from2));
    };
    Object.defineProperty(exports$e2, "__esModule", {
      value: true
    });
    exports$e2.bufferFrom = exports$e2.bufferAllocUnsafe = exports$e2.Buffer = void 0;
    var buffer_1 = buffer;
    Object.defineProperty(exports$e2, "Buffer", {
      enumerable: true,
      get: function() {
        return buffer_1.Buffer;
      }
    });
    function bufferV0P12Ponyfill(arg0) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray2([void 0, arg0], args, false)))();
    }
    var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
    exports$e2.bufferAllocUnsafe = bufferAllocUnsafe;
    var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
    exports$e2.bufferFrom = bufferFrom;
    return exports$e2;
  }
  function dew$b2() {
    if (_dewExec$b2)
      return exports$d2;
    _dewExec$b2 = true;
    var __extends2 = exports$d2 && exports$d2.__extends || /* @__PURE__ */ function() {
      var extendStatics2 = function(d6, b5) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d7, b6) {
          d7.__proto__ = b6;
        } || function(d7, b6) {
          for (var p7 in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p7))
              d7[p7] = b6[p7];
        };
        return extendStatics2(d6, b5);
      };
      return function(d6, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics2(d6, b5);
        function __() {
          this.constructor = d6;
        }
        d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    Object.defineProperty(exports$d2, "__esModule", {
      value: true
    });
    exports$d2.E = exports$d2.AssertionError = exports$d2.message = exports$d2.RangeError = exports$d2.TypeError = exports$d2.Error = void 0;
    var assert2 = et;
    var util = X;
    var kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
    var messages = {};
    function makeNodeError(Base) {
      return function(_super) {
        __extends2(NodeError, _super);
        function NodeError(key) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          var _this = _super.call(this, message(key, args)) || this;
          _this.code = key;
          _this[kCode] = key;
          _this.name = _super.prototype.name + " [" + _this[kCode] + "]";
          return _this;
        }
        return NodeError;
      }(Base);
    }
    var g5 = typeof globalThis !== "undefined" ? globalThis : _global$3;
    var AssertionError2 = function(_super) {
      __extends2(AssertionError3, _super);
      function AssertionError3(options) {
        var _this = this;
        if (typeof options !== "object" || options === null) {
          throw new exports$d2.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
        }
        if (options.message) {
          _this = _super.call(this, options.message) || this;
        } else {
          _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + " " + (options.operator + " " + util.inspect(options.expected).slice(0, 128))) || this;
        }
        _this.generatedMessage = !options.message;
        _this.name = "AssertionError [ERR_ASSERTION]";
        _this.code = "ERR_ASSERTION";
        _this.actual = options.actual;
        _this.expected = options.expected;
        _this.operator = options.operator;
        exports$d2.Error.captureStackTrace(_this, options.stackStartFunction);
        return _this;
      }
      return AssertionError3;
    }(g5.Error);
    exports$d2.AssertionError = AssertionError2;
    function message(key, args) {
      assert2.strictEqual(typeof key, "string");
      var msg = messages[key];
      assert2(msg, "An invalid error message key was used: " + key + ".");
      var fmt;
      if (typeof msg === "function") {
        fmt = msg;
      } else {
        fmt = util.format;
        if (args === void 0 || args.length === 0)
          return msg;
        args.unshift(msg);
      }
      return String(fmt.apply(null, args));
    }
    exports$d2.message = message;
    function E4(sym, val) {
      messages[sym] = typeof val === "function" ? val : String(val);
    }
    exports$d2.E = E4;
    exports$d2.Error = makeNodeError(g5.Error);
    exports$d2.TypeError = makeNodeError(g5.TypeError);
    exports$d2.RangeError = makeNodeError(g5.RangeError);
    E4("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
    E4("ERR_ASSERTION", "%s");
    E4("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
    E4("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
    E4("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s");
    E4("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
    E4("ERR_DNS_SET_SERVERS_FAILED", function(err, servers) {
      return 'c-ares failed to set servers: "' + err + '" [' + servers + "]";
    });
    E4("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
    E4("ERR_ENCODING_NOT_SUPPORTED", function(enc) {
      return 'The "' + enc + '" encoding is not supported';
    });
    E4("ERR_ENCODING_INVALID_ENCODED_DATA", function(enc) {
      return "The encoded data was not valid for encoding " + enc;
    });
    E4("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client");
    E4("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
    E4("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding");
    E4("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
    E4("ERR_INVALID_ARG_TYPE", invalidArgType);
    E4("ERR_INVALID_ARRAY_LENGTH", function(name2, len, actual) {
      assert2.strictEqual(typeof actual, "number");
      return 'The array "' + name2 + '" (length ' + actual + ") must be of length " + len + ".";
    });
    E4("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
    E4("ERR_INVALID_CALLBACK", "Callback must be a function");
    E4("ERR_INVALID_CHAR", "Invalid character in %s");
    E4("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column");
    E4("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
    E4("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
    E4("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
    E4("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
    E4("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
    E4("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + String(value) + '" is invalid for option "' + name2 + '"';
    });
    E4("ERR_INVALID_OPT_VALUE_ENCODING", function(value) {
      return 'The value "' + String(value) + '" is invalid for option "encoding"';
    });
    E4("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
    E4("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s");
    E4("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
    E4("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
    E4("ERR_INVALID_URL", "Invalid URL: %s");
    E4("ERR_INVALID_URL_SCHEME", function(expected) {
      return "The URL must be " + oneOf(expected, "scheme");
    });
    E4("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
    E4("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
    E4("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
    E4("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
    E4("ERR_MISSING_ARGS", missingArgs);
    E4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    E4("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
    E4("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object");
    E4("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
    E4("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
    E4("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
    E4("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
    E4("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
    E4("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6");
    E4("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
    E4("ERR_SOCKET_CLOSED", "Socket is closed");
    E4("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
    E4("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
    E4("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
    E4("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
    E4("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s");
    E4("ERR_TLS_DH_PARAM_SIZE", function(size) {
      return "DH parameter size " + size + " is less than 2048";
    });
    E4("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
    E4("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
    E4("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext');
    E4("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
    E4("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming");
    E4("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0");
    E4("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
    E4("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
    E4("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
    E4("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
    E4("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
    function invalidArgType(name2, expected, actual) {
      assert2(name2, "name is required");
      var determiner;
      if (expected.includes("not ")) {
        determiner = "must not be";
        expected = expected.split("not ")[1];
      } else {
        determiner = "must be";
      }
      var msg;
      if (Array.isArray(name2)) {
        var names = name2.map(function(val) {
          return '"' + val + '"';
        }).join(", ");
        msg = "The " + names + " arguments " + determiner + " " + oneOf(expected, "type");
      } else if (name2.includes(" argument")) {
        msg = "The " + name2 + " " + determiner + " " + oneOf(expected, "type");
      } else {
        var type = name2.includes(".") ? "property" : "argument";
        msg = 'The "' + name2 + '" ' + type + " " + determiner + " " + oneOf(expected, "type");
      }
      if (arguments.length >= 3) {
        msg += ". Received type " + (actual !== null ? typeof actual : "null");
      }
      return msg;
    }
    function missingArgs() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      assert2(args.length > 0, "At least one arg needs to be specified");
      var msg = "The ";
      var len = args.length;
      args = args.map(function(a7) {
        return '"' + a7 + '"';
      });
      switch (len) {
        case 1:
          msg += args[0] + " argument";
          break;
        case 2:
          msg += args[0] + " and " + args[1] + " arguments";
          break;
        default:
          msg += args.slice(0, len - 1).join(", ");
          msg += ", and " + args[len - 1] + " arguments";
          break;
      }
      return msg + " must be specified";
    }
    function oneOf(expected, thing) {
      assert2(expected, "expected is required");
      assert2(typeof thing === "string", "thing is required");
      if (Array.isArray(expected)) {
        var len = expected.length;
        assert2(len > 0, "At least one expected value needs to be specified");
        expected = expected.map(function(i7) {
          return String(i7);
        });
        if (len > 2) {
          return "one of " + thing + " " + expected.slice(0, len - 1).join(", ") + ", or " + expected[len - 1];
        } else if (len === 2) {
          return "one of " + thing + " " + expected[0] + " or " + expected[1];
        } else {
          return "of " + thing + " " + expected[0];
        }
      } else {
        return "of " + thing + " " + String(expected);
      }
    }
    function bufferOutOfBounds(name2, isWriting) {
      if (isWriting) {
        return "Attempt to write outside buffer bounds";
      } else {
        return '"' + name2 + '" is outside of buffer bounds';
      }
    }
    return exports$d2;
  }
  function dew$a2() {
    if (_dewExec$a2)
      return exports$c2;
    _dewExec$a2 = true;
    Object.defineProperty(exports$c2, "__esModule", {
      value: true
    });
    exports$c2.strToEncoding = exports$c2.assertEncoding = exports$c2.ENCODING_UTF8 = void 0;
    var buffer_1 = dew$c2();
    var errors = dew$b2();
    exports$c2.ENCODING_UTF8 = "utf8";
    function assertEncoding(encoding) {
      if (encoding && !buffer_1.Buffer.isEncoding(encoding))
        throw new errors.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding);
    }
    exports$c2.assertEncoding = assertEncoding;
    function strToEncoding(str, encoding) {
      if (!encoding || encoding === exports$c2.ENCODING_UTF8)
        return str;
      if (encoding === "buffer")
        return new buffer_1.Buffer(str);
      return new buffer_1.Buffer(str).toString(encoding);
    }
    exports$c2.strToEncoding = strToEncoding;
    return exports$c2;
  }
  function dew$92() {
    if (_dewExec$92)
      return exports$b2;
    _dewExec$92 = true;
    Object.defineProperty(exports$b2, "__esModule", {
      value: true
    });
    exports$b2.Dirent = void 0;
    var constants_1 = dew$f2();
    var encoding_1 = dew$a2();
    var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
    var Dirent2 = function() {
      function Dirent3() {
        this.name = "";
        this.mode = 0;
      }
      Dirent3.build = function(link3, encoding) {
        var dirent = new Dirent3();
        var mode = link3.getNode().mode;
        dirent.name = (0, encoding_1.strToEncoding)(link3.getName(), encoding);
        dirent.mode = mode;
        return dirent;
      };
      Dirent3.prototype._checkModeProperty = function(property) {
        return (this.mode & S_IFMT) === property;
      };
      Dirent3.prototype.isDirectory = function() {
        return this._checkModeProperty(S_IFDIR);
      };
      Dirent3.prototype.isFile = function() {
        return this._checkModeProperty(S_IFREG);
      };
      Dirent3.prototype.isBlockDevice = function() {
        return this._checkModeProperty(S_IFBLK);
      };
      Dirent3.prototype.isCharacterDevice = function() {
        return this._checkModeProperty(S_IFCHR);
      };
      Dirent3.prototype.isSymbolicLink = function() {
        return this._checkModeProperty(S_IFLNK);
      };
      Dirent3.prototype.isFIFO = function() {
        return this._checkModeProperty(S_IFIFO);
      };
      Dirent3.prototype.isSocket = function() {
        return this._checkModeProperty(S_IFSOCK);
      };
      return Dirent3;
    }();
    exports$b2.Dirent = Dirent2;
    exports$b2.default = Dirent2;
    return exports$b2;
  }
  function dew$82() {
    if (_dewExec$82)
      return exports$a2;
    _dewExec$82 = true;
    var process$1 = process3;
    Object.defineProperty(exports$a2, "__esModule", {
      value: true
    });
    var _setImmediate;
    if (typeof process$1.nextTick === "function")
      _setImmediate = process$1.nextTick.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
    else
      _setImmediate = setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
    exports$a2.default = _setImmediate;
    return exports$a2;
  }
  function dew$72() {
    if (_dewExec$72)
      return exports$92;
    _dewExec$72 = true;
    var process$1 = process3;
    Object.defineProperty(exports$92, "__esModule", {
      value: true
    });
    exports$92.createProcess = void 0;
    var maybeReturnProcess = function() {
      if (typeof process$1 !== "undefined") {
        return process$1;
      }
      try {
        return process3;
      } catch (_a) {
        return void 0;
      }
    };
    function createProcess() {
      var p7 = maybeReturnProcess() || {};
      if (!p7.getuid)
        p7.getuid = function() {
          return 0;
        };
      if (!p7.getgid)
        p7.getgid = function() {
          return 0;
        };
      if (!p7.cwd)
        p7.cwd = function() {
          return "/";
        };
      if (!p7.nextTick)
        p7.nextTick = dew$82().default;
      if (!p7.emitWarning)
        p7.emitWarning = function(message, type) {
          console.warn("" + type + (type ? ": " : "") + message);
        };
      if (!p7.env)
        p7.env = {};
      return p7;
    }
    exports$92.createProcess = createProcess;
    exports$92.default = createProcess();
    return exports$92;
  }
  function dew$62() {
    if (_dewExec$62)
      return exports$82;
    _dewExec$62 = true;
    var __extends2 = exports$82 && exports$82.__extends || /* @__PURE__ */ function() {
      var extendStatics2 = function(d6, b5) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d7, b6) {
          d7.__proto__ = b6;
        } || function(d7, b6) {
          for (var p7 in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p7))
              d7[p7] = b6[p7];
        };
        return extendStatics2(d6, b5);
      };
      return function(d6, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics2(d6, b5);
        function __() {
          this.constructor = d6;
        }
        d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    Object.defineProperty(exports$82, "__esModule", {
      value: true
    });
    exports$82.File = exports$82.Link = exports$82.Node = exports$82.SEP = void 0;
    var process_1 = dew$72();
    var buffer_1 = dew$c2();
    var constants_1 = dew$f2();
    var events_1 = y;
    var Stats_1 = dew$d2();
    var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFLNK = constants_1.constants.S_IFLNK, O_APPEND = constants_1.constants.O_APPEND;
    exports$82.SEP = "/";
    var Node2 = function(_super) {
      __extends2(Node3, _super);
      function Node3(ino, perm) {
        if (perm === void 0) {
          perm = 438;
        }
        var _this = _super.call(this) || this;
        _this.uid = process_1.default.getuid();
        _this.gid = process_1.default.getgid();
        _this.atime = /* @__PURE__ */ new Date();
        _this.mtime = /* @__PURE__ */ new Date();
        _this.ctime = /* @__PURE__ */ new Date();
        _this.perm = 438;
        _this.mode = S_IFREG;
        _this.nlink = 1;
        _this.perm = perm;
        _this.mode |= perm;
        _this.ino = ino;
        return _this;
      }
      Node3.prototype.getString = function(encoding) {
        if (encoding === void 0) {
          encoding = "utf8";
        }
        return this.getBuffer().toString(encoding);
      };
      Node3.prototype.setString = function(str) {
        this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
        this.touch();
      };
      Node3.prototype.getBuffer = function() {
        if (!this.buf)
          this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
        return (0, buffer_1.bufferFrom)(this.buf);
      };
      Node3.prototype.setBuffer = function(buf) {
        this.buf = (0, buffer_1.bufferFrom)(buf);
        this.touch();
      };
      Node3.prototype.getSize = function() {
        return this.buf ? this.buf.length : 0;
      };
      Node3.prototype.setModeProperty = function(property) {
        this.mode = this.mode & ~S_IFMT | property;
      };
      Node3.prototype.setIsFile = function() {
        this.setModeProperty(S_IFREG);
      };
      Node3.prototype.setIsDirectory = function() {
        this.setModeProperty(S_IFDIR);
      };
      Node3.prototype.setIsSymlink = function() {
        this.setModeProperty(S_IFLNK);
      };
      Node3.prototype.isFile = function() {
        return (this.mode & S_IFMT) === S_IFREG;
      };
      Node3.prototype.isDirectory = function() {
        return (this.mode & S_IFMT) === S_IFDIR;
      };
      Node3.prototype.isSymlink = function() {
        return (this.mode & S_IFMT) === S_IFLNK;
      };
      Node3.prototype.makeSymlink = function(steps) {
        this.symlink = steps;
        this.setIsSymlink();
      };
      Node3.prototype.write = function(buf, off, len, pos) {
        if (off === void 0) {
          off = 0;
        }
        if (len === void 0) {
          len = buf.length;
        }
        if (pos === void 0) {
          pos = 0;
        }
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (pos + len > this.buf.length) {
          var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
          this.buf.copy(newBuf, 0, 0, this.buf.length);
          this.buf = newBuf;
        }
        buf.copy(this.buf, pos, off, off + len);
        this.touch();
        return len;
      };
      Node3.prototype.read = function(buf, off, len, pos) {
        if (off === void 0) {
          off = 0;
        }
        if (len === void 0) {
          len = buf.byteLength;
        }
        if (pos === void 0) {
          pos = 0;
        }
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        var actualLen = len;
        if (actualLen > buf.byteLength) {
          actualLen = buf.byteLength;
        }
        if (actualLen + pos > this.buf.length) {
          actualLen = this.buf.length - pos;
        }
        this.buf.copy(buf, off, pos, pos + actualLen);
        return actualLen;
      };
      Node3.prototype.truncate = function(len) {
        if (len === void 0) {
          len = 0;
        }
        if (!len)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        else {
          if (!this.buf)
            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          if (len <= this.buf.length) {
            this.buf = this.buf.slice(0, len);
          } else {
            var buf = (0, buffer_1.bufferAllocUnsafe)(0);
            this.buf.copy(buf);
            buf.fill(0, len);
          }
        }
        this.touch();
      };
      Node3.prototype.chmod = function(perm) {
        this.perm = perm;
        this.mode = this.mode & ~511 | perm;
        this.touch();
      };
      Node3.prototype.chown = function(uid, gid) {
        this.uid = uid;
        this.gid = gid;
        this.touch();
      };
      Node3.prototype.touch = function() {
        this.mtime = /* @__PURE__ */ new Date();
        this.emit("change", this);
      };
      Node3.prototype.canRead = function(uid, gid) {
        if (uid === void 0) {
          uid = process_1.default.getuid();
        }
        if (gid === void 0) {
          gid = process_1.default.getgid();
        }
        if (this.perm & 4) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 32) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 256) {
            return true;
          }
        }
        return false;
      };
      Node3.prototype.canWrite = function(uid, gid) {
        if (uid === void 0) {
          uid = process_1.default.getuid();
        }
        if (gid === void 0) {
          gid = process_1.default.getgid();
        }
        if (this.perm & 2) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 16) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 128) {
            return true;
          }
        }
        return false;
      };
      Node3.prototype.del = function() {
        this.emit("delete", this);
      };
      Node3.prototype.toJSON = function() {
        return {
          ino: this.ino,
          uid: this.uid,
          gid: this.gid,
          atime: this.atime.getTime(),
          mtime: this.mtime.getTime(),
          ctime: this.ctime.getTime(),
          perm: this.perm,
          mode: this.mode,
          nlink: this.nlink,
          symlink: this.symlink,
          data: this.getString()
        };
      };
      return Node3;
    }(events_1.EventEmitter);
    exports$82.Node = Node2;
    var Link = function(_super) {
      __extends2(Link2, _super);
      function Link2(vol2, parent, name2) {
        var _this = _super.call(this) || this;
        _this.children = {};
        _this.steps = [];
        _this.ino = 0;
        _this.length = 0;
        _this.vol = vol2;
        _this.parent = parent;
        _this.steps = parent ? parent.steps.concat([name2]) : [name2];
        return _this;
      }
      Link2.prototype.setNode = function(node) {
        this.node = node;
        this.ino = node.ino;
      };
      Link2.prototype.getNode = function() {
        return this.node;
      };
      Link2.prototype.createChild = function(name2, node) {
        if (node === void 0) {
          node = this.vol.createNode();
        }
        var link3 = new Link2(this.vol, this, name2);
        link3.setNode(node);
        if (node.isDirectory())
          ;
        this.setChild(name2, link3);
        return link3;
      };
      Link2.prototype.setChild = function(name2, link3) {
        if (link3 === void 0) {
          link3 = new Link2(this.vol, this, name2);
        }
        this.children[name2] = link3;
        link3.parent = this;
        this.length++;
        this.emit("child:add", link3, this);
        return link3;
      };
      Link2.prototype.deleteChild = function(link3) {
        delete this.children[link3.getName()];
        this.length--;
        this.emit("child:delete", link3, this);
      };
      Link2.prototype.getChild = function(name2) {
        if (Object.hasOwnProperty.call(this.children, name2)) {
          return this.children[name2];
        }
      };
      Link2.prototype.getPath = function() {
        return this.steps.join(exports$82.SEP);
      };
      Link2.prototype.getName = function() {
        return this.steps[this.steps.length - 1];
      };
      Link2.prototype.walk = function(steps, stop, i7) {
        if (stop === void 0) {
          stop = steps.length;
        }
        if (i7 === void 0) {
          i7 = 0;
        }
        if (i7 >= steps.length)
          return this;
        if (i7 >= stop)
          return this;
        var step = steps[i7];
        var link3 = this.getChild(step);
        if (!link3)
          return null;
        return link3.walk(steps, stop, i7 + 1);
      };
      Link2.prototype.toJSON = function() {
        return {
          steps: this.steps,
          ino: this.ino,
          children: Object.keys(this.children)
        };
      };
      return Link2;
    }(events_1.EventEmitter);
    exports$82.Link = Link;
    var File = function() {
      function File2(link3, node, flags, fd) {
        this.position = 0;
        this.link = link3;
        this.node = node;
        this.flags = flags;
        this.fd = fd;
      }
      File2.prototype.getString = function(encoding) {
        return this.node.getString();
      };
      File2.prototype.setString = function(str) {
        this.node.setString(str);
      };
      File2.prototype.getBuffer = function() {
        return this.node.getBuffer();
      };
      File2.prototype.setBuffer = function(buf) {
        this.node.setBuffer(buf);
      };
      File2.prototype.getSize = function() {
        return this.node.getSize();
      };
      File2.prototype.truncate = function(len) {
        this.node.truncate(len);
      };
      File2.prototype.seekTo = function(position) {
        this.position = position;
      };
      File2.prototype.stats = function() {
        return Stats_1.default.build(this.node);
      };
      File2.prototype.write = function(buf, offset, length, position) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = buf.length;
        }
        if (typeof position !== "number")
          position = this.position;
        if (this.flags & O_APPEND)
          position = this.getSize();
        var bytes = this.node.write(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      };
      File2.prototype.read = function(buf, offset, length, position) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = buf.byteLength;
        }
        if (typeof position !== "number")
          position = this.position;
        var bytes = this.node.read(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      };
      File2.prototype.chmod = function(perm) {
        this.node.chmod(perm);
      };
      File2.prototype.chown = function(uid, gid) {
        this.node.chown(uid, gid);
      };
      return File2;
    }();
    exports$82.File = File;
    return exports$82;
  }
  function dew$52() {
    if (_dewExec$52)
      return exports$72;
    _dewExec$52 = true;
    Object.defineProperty(exports$72, "__esModule", {
      value: true
    });
    function setTimeoutUnref(callback, time, args) {
      var ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : _global$12, arguments);
      if (ref && typeof ref === "object" && typeof ref.unref === "function")
        ref.unref();
      return ref;
    }
    exports$72.default = setTimeoutUnref;
    return exports$72;
  }
  function dew$42() {
    if (_dewExec$42)
      return exports$62;
    _dewExec$42 = true;
    var __spreadArray2 = exports$62 && exports$62.__spreadArray || function(to, from2, pack) {
      if (pack || arguments.length === 2)
        for (var i7 = 0, l7 = from2.length, ar; i7 < l7; i7++) {
          if (ar || !(i7 in from2)) {
            if (!ar)
              ar = Array.prototype.slice.call(from2, 0, i7);
            ar[i7] = from2[i7];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from2));
    };
    Object.defineProperty(exports$62, "__esModule", {
      value: true
    });
    exports$62.FileHandle = void 0;
    function promisify3(vol2, fn, getResult) {
      if (getResult === void 0) {
        getResult = function(input) {
          return input;
        };
      }
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return new Promise(function(resolve3, reject) {
          vol2[fn].bind(vol2).apply(void 0, __spreadArray2(__spreadArray2([], args, false), [function(error, result) {
            if (error)
              return reject(error);
            return resolve3(getResult(result));
          }], false));
        });
      };
    }
    var FileHandle = function() {
      function FileHandle2(vol2, fd) {
        this.vol = vol2;
        this.fd = fd;
      }
      FileHandle2.prototype.appendFile = function(data, options) {
        return promisify3(this.vol, "appendFile")(this.fd, data, options);
      };
      FileHandle2.prototype.chmod = function(mode) {
        return promisify3(this.vol, "fchmod")(this.fd, mode);
      };
      FileHandle2.prototype.chown = function(uid, gid) {
        return promisify3(this.vol, "fchown")(this.fd, uid, gid);
      };
      FileHandle2.prototype.close = function() {
        return promisify3(this.vol, "close")(this.fd);
      };
      FileHandle2.prototype.datasync = function() {
        return promisify3(this.vol, "fdatasync")(this.fd);
      };
      FileHandle2.prototype.read = function(buffer2, offset, length, position) {
        return promisify3(this.vol, "read", function(bytesRead) {
          return {
            bytesRead,
            buffer: buffer2
          };
        })(this.fd, buffer2, offset, length, position);
      };
      FileHandle2.prototype.readFile = function(options) {
        return promisify3(this.vol, "readFile")(this.fd, options);
      };
      FileHandle2.prototype.stat = function(options) {
        return promisify3(this.vol, "fstat")(this.fd, options);
      };
      FileHandle2.prototype.sync = function() {
        return promisify3(this.vol, "fsync")(this.fd);
      };
      FileHandle2.prototype.truncate = function(len) {
        return promisify3(this.vol, "ftruncate")(this.fd, len);
      };
      FileHandle2.prototype.utimes = function(atime, mtime) {
        return promisify3(this.vol, "futimes")(this.fd, atime, mtime);
      };
      FileHandle2.prototype.write = function(buffer2, offset, length, position) {
        return promisify3(this.vol, "write", function(bytesWritten) {
          return {
            bytesWritten,
            buffer: buffer2
          };
        })(this.fd, buffer2, offset, length, position);
      };
      FileHandle2.prototype.writeFile = function(data, options) {
        return promisify3(this.vol, "writeFile")(this.fd, data, options);
      };
      return FileHandle2;
    }();
    exports$62.FileHandle = FileHandle;
    function createPromisesApi(vol2) {
      if (typeof Promise === "undefined")
        return null;
      return {
        FileHandle,
        access: function(path2, mode) {
          return promisify3(vol2, "access")(path2, mode);
        },
        appendFile: function(path2, data, options) {
          return promisify3(vol2, "appendFile")(path2 instanceof FileHandle ? path2.fd : path2, data, options);
        },
        chmod: function(path2, mode) {
          return promisify3(vol2, "chmod")(path2, mode);
        },
        chown: function(path2, uid, gid) {
          return promisify3(vol2, "chown")(path2, uid, gid);
        },
        copyFile: function(src, dest, flags) {
          return promisify3(vol2, "copyFile")(src, dest, flags);
        },
        lchmod: function(path2, mode) {
          return promisify3(vol2, "lchmod")(path2, mode);
        },
        lchown: function(path2, uid, gid) {
          return promisify3(vol2, "lchown")(path2, uid, gid);
        },
        link: function(existingPath, newPath) {
          return promisify3(vol2, "link")(existingPath, newPath);
        },
        lstat: function(path2, options) {
          return promisify3(vol2, "lstat")(path2, options);
        },
        mkdir: function(path2, options) {
          return promisify3(vol2, "mkdir")(path2, options);
        },
        mkdtemp: function(prefix, options) {
          return promisify3(vol2, "mkdtemp")(prefix, options);
        },
        open: function(path2, flags, mode) {
          return promisify3(vol2, "open", function(fd) {
            return new FileHandle(vol2, fd);
          })(path2, flags, mode);
        },
        readdir: function(path2, options) {
          return promisify3(vol2, "readdir")(path2, options);
        },
        readFile: function(id, options) {
          return promisify3(vol2, "readFile")(id instanceof FileHandle ? id.fd : id, options);
        },
        readlink: function(path2, options) {
          return promisify3(vol2, "readlink")(path2, options);
        },
        realpath: function(path2, options) {
          return promisify3(vol2, "realpath")(path2, options);
        },
        rename: function(oldPath, newPath) {
          return promisify3(vol2, "rename")(oldPath, newPath);
        },
        rmdir: function(path2) {
          return promisify3(vol2, "rmdir")(path2);
        },
        stat: function(path2, options) {
          return promisify3(vol2, "stat")(path2, options);
        },
        symlink: function(target, path2, type) {
          return promisify3(vol2, "symlink")(target, path2, type);
        },
        truncate: function(path2, len) {
          return promisify3(vol2, "truncate")(path2, len);
        },
        unlink: function(path2) {
          return promisify3(vol2, "unlink")(path2);
        },
        utimes: function(path2, atime, mtime) {
          return promisify3(vol2, "utimes")(path2, atime, mtime);
        },
        writeFile: function(id, data, options) {
          return promisify3(vol2, "writeFile")(id instanceof FileHandle ? id.fd : id, data, options);
        }
      };
    }
    exports$62.default = createPromisesApi;
    return exports$62;
  }
  function dew$32() {
    if (_dewExec$32)
      return exports$52;
    _dewExec$32 = true;
    var process$1 = process3;
    Object.defineProperty(exports$52, "__esModule", {
      value: true
    });
    exports$52.unixify = unixify;
    exports$52.correctPath = correctPath;
    var isWin = process$1.platform === "win32";
    function removeTrailingSeparator(str) {
      var i7 = str.length - 1;
      if (i7 < 2) {
        return str;
      }
      while (isSeparator(str, i7)) {
        i7--;
      }
      return str.substr(0, i7 + 1);
    }
    function isSeparator(str, i7) {
      var _char = str[i7];
      return i7 > 0 && (_char === "/" || isWin && _char === "\\");
    }
    function normalizePath(str, stripTrailing) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      str = str.replace(/[\\\/]+/g, "/");
      if (stripTrailing !== false) {
        str = removeTrailingSeparator(str);
      }
      return str;
    }
    function unixify(filepath) {
      var stripTrailing = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (isWin) {
        filepath = normalizePath(filepath, stripTrailing);
        return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
      }
      return filepath;
    }
    function correctPath(filepath) {
      return unixify(filepath.replace(/^\\\\\?\\.:\\/, "\\"));
    }
    return exports$52;
  }
  function dew$23() {
    if (_dewExec$23)
      return exports$42;
    _dewExec$23 = true;
    var __extends2 = exports$42 && exports$42.__extends || /* @__PURE__ */ function() {
      var extendStatics2 = function(d6, b5) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d7, b6) {
          d7.__proto__ = b6;
        } || function(d7, b6) {
          for (var p7 in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p7))
              d7[p7] = b6[p7];
        };
        return extendStatics2(d6, b5);
      };
      return function(d6, b5) {
        if (typeof b5 !== "function" && b5 !== null)
          throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
        extendStatics2(d6, b5);
        function __() {
          this.constructor = d6;
        }
        d6.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    }();
    var __spreadArray2 = exports$42 && exports$42.__spreadArray || function(to, from2, pack) {
      if (pack || arguments.length === 2)
        for (var i7 = 0, l7 = from2.length, ar; i7 < l7; i7++) {
          if (ar || !(i7 in from2)) {
            if (!ar)
              ar = Array.prototype.slice.call(from2, 0, i7);
            ar[i7] = from2[i7];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from2));
    };
    Object.defineProperty(exports$42, "__esModule", {
      value: true
    });
    exports$42.FSWatcher = exports$42.StatWatcher = exports$42.Volume = exports$42.toUnixTimestamp = exports$42.bufferToEncoding = exports$42.dataToBuffer = exports$42.dataToStr = exports$42.pathToSteps = exports$42.filenameToSteps = exports$42.pathToFilename = exports$42.flagsToNumber = exports$42.FLAGS = void 0;
    var pathModule = exports4;
    var node_1 = dew$62();
    var Stats_1 = dew$d2();
    var Dirent_1 = dew$92();
    var buffer_1 = dew$c2();
    var setImmediate_1 = dew$82();
    var process_1 = dew$72();
    var setTimeoutUnref_1 = dew$52();
    var stream_1 = exports5;
    var constants_1 = dew$f2();
    var events_1 = y;
    var encoding_1 = dew$a2();
    var errors = dew$b2();
    var util = X;
    var promises_1 = dew$42();
    var resolveCrossPlatform = pathModule.resolve;
    var O_RDONLY = constants_1.constants.O_RDONLY, O_WRONLY = constants_1.constants.O_WRONLY, O_RDWR = constants_1.constants.O_RDWR, O_CREAT = constants_1.constants.O_CREAT, O_EXCL = constants_1.constants.O_EXCL, O_TRUNC = constants_1.constants.O_TRUNC, O_APPEND = constants_1.constants.O_APPEND, O_SYNC = constants_1.constants.O_SYNC, O_DIRECTORY = constants_1.constants.O_DIRECTORY, F_OK2 = constants_1.constants.F_OK, COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL, COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
    var _a = pathModule.posix ? pathModule.posix : pathModule, sep2 = _a.sep, relative2 = _a.relative, join2 = _a.join, dirname2 = _a.dirname;
    var isWin = process_1.default.platform === "win32";
    var kMinPoolSpace = 128;
    var ERRSTR = {
      PATH_STR: "path must be a string or Buffer",
      // FD:             'file descriptor must be a unsigned 32-bit integer',
      FD: "fd must be a file descriptor",
      MODE_INT: "mode must be an int",
      CB: "callback must be a function",
      UID: "uid must be an unsigned int",
      GID: "gid must be an unsigned int",
      LEN: "len must be an integer",
      ATIME: "atime must be an integer",
      MTIME: "mtime must be an integer",
      PREFIX: "filename prefix is required",
      BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
      OFFSET: "offset must be an integer",
      LENGTH: "length must be an integer",
      POSITION: "position must be an integer"
    };
    var ERRSTR_OPTS = function(tipeof) {
      return "Expected options to be either an object or a string, but got " + tipeof + " instead";
    };
    var ENOENT = "ENOENT";
    var EBADF = "EBADF";
    var EINVAL = "EINVAL";
    var EPERM = "EPERM";
    var EPROTO = "EPROTO";
    var EEXIST = "EEXIST";
    var ENOTDIR = "ENOTDIR";
    var EMFILE = "EMFILE";
    var EACCES = "EACCES";
    var EISDIR = "EISDIR";
    var ENOTEMPTY = "ENOTEMPTY";
    var ENOSYS = "ENOSYS";
    function formatError(errorCode, func, path2, path22) {
      if (func === void 0) {
        func = "";
      }
      if (path2 === void 0) {
        path2 = "";
      }
      if (path22 === void 0) {
        path22 = "";
      }
      var pathFormatted = "";
      if (path2)
        pathFormatted = " '" + path2 + "'";
      if (path22)
        pathFormatted += " -> '" + path22 + "'";
      switch (errorCode) {
        case ENOENT:
          return "ENOENT: no such file or directory, " + func + pathFormatted;
        case EBADF:
          return "EBADF: bad file descriptor, " + func + pathFormatted;
        case EINVAL:
          return "EINVAL: invalid argument, " + func + pathFormatted;
        case EPERM:
          return "EPERM: operation not permitted, " + func + pathFormatted;
        case EPROTO:
          return "EPROTO: protocol error, " + func + pathFormatted;
        case EEXIST:
          return "EEXIST: file already exists, " + func + pathFormatted;
        case ENOTDIR:
          return "ENOTDIR: not a directory, " + func + pathFormatted;
        case EISDIR:
          return "EISDIR: illegal operation on a directory, " + func + pathFormatted;
        case EACCES:
          return "EACCES: permission denied, " + func + pathFormatted;
        case ENOTEMPTY:
          return "ENOTEMPTY: directory not empty, " + func + pathFormatted;
        case EMFILE:
          return "EMFILE: too many open files, " + func + pathFormatted;
        case ENOSYS:
          return "ENOSYS: function not implemented, " + func + pathFormatted;
        default:
          return errorCode + ": error occurred, " + func + pathFormatted;
      }
    }
    function createError(errorCode, func, path2, path22, Constructor) {
      if (func === void 0) {
        func = "";
      }
      if (path2 === void 0) {
        path2 = "";
      }
      if (path22 === void 0) {
        path22 = "";
      }
      if (Constructor === void 0) {
        Constructor = Error;
      }
      var error = new Constructor(formatError(errorCode, func, path2, path22));
      error.code = errorCode;
      return error;
    }
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["r"] = O_RDONLY] = "r";
      FLAGS2[FLAGS2["r+"] = O_RDWR] = "r+";
      FLAGS2[FLAGS2["rs"] = O_RDONLY | O_SYNC] = "rs";
      FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
      FLAGS2[FLAGS2["rs+"] = O_RDWR | O_SYNC] = "rs+";
      FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
      FLAGS2[FLAGS2["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
      FLAGS2[FLAGS2["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
      FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
      FLAGS2[FLAGS2["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
      FLAGS2[FLAGS2["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
      FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
      FLAGS2[FLAGS2["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
      FLAGS2[FLAGS2["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
      FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
      FLAGS2[FLAGS2["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
      FLAGS2[FLAGS2["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
      FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
    })(FLAGS = exports$42.FLAGS || (exports$42.FLAGS = {}));
    function flagsToNumber(flags) {
      if (typeof flags === "number")
        return flags;
      if (typeof flags === "string") {
        var flagsNum = FLAGS[flags];
        if (typeof flagsNum !== "undefined")
          return flagsNum;
      }
      throw new errors.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
    }
    exports$42.flagsToNumber = flagsToNumber;
    function getOptions(defaults, options) {
      var opts;
      if (!options)
        return defaults;
      else {
        var tipeof = typeof options;
        switch (tipeof) {
          case "string":
            opts = Object.assign({}, defaults, {
              encoding: options
            });
            break;
          case "object":
            opts = Object.assign({}, defaults, options);
            break;
          default:
            throw TypeError(ERRSTR_OPTS(tipeof));
        }
      }
      if (opts.encoding !== "buffer")
        (0, encoding_1.assertEncoding)(opts.encoding);
      return opts;
    }
    function optsGenerator(defaults) {
      return function(options) {
        return getOptions(defaults, options);
      };
    }
    function validateCallback(callback) {
      if (typeof callback !== "function")
        throw TypeError(ERRSTR.CB);
      return callback;
    }
    function optsAndCbGenerator(getOpts) {
      return function(options, callback) {
        return typeof options === "function" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
      };
    }
    var optsDefaults = {
      encoding: "utf8"
    };
    var getDefaultOpts = optsGenerator(optsDefaults);
    var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
    var readFileOptsDefaults = {
      flag: "r"
    };
    var getReadFileOptions = optsGenerator(readFileOptsDefaults);
    var writeFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: FLAGS[FLAGS.w]
    };
    var getWriteFileOptions = optsGenerator(writeFileDefaults);
    var appendFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: FLAGS[FLAGS.a]
    };
    var getAppendFileOpts = optsGenerator(appendFileDefaults);
    var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
    var realpathDefaults = optsDefaults;
    var getRealpathOptions = optsGenerator(realpathDefaults);
    var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
    var mkdirDefaults = {
      mode: 511,
      recursive: false
    };
    var getMkdirOptions = function(options) {
      if (typeof options === "number")
        return Object.assign({}, mkdirDefaults, {
          mode: options
        });
      return Object.assign({}, mkdirDefaults, options);
    };
    var rmdirDefaults = {
      recursive: false
    };
    var getRmdirOptions = function(options) {
      return Object.assign({}, rmdirDefaults, options);
    };
    var readdirDefaults = {
      encoding: "utf8",
      withFileTypes: false
    };
    var getReaddirOptions = optsGenerator(readdirDefaults);
    var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
    var statDefaults = {
      bigint: false
    };
    var getStatOptions = function(options) {
      if (options === void 0) {
        options = {};
      }
      return Object.assign({}, statDefaults, options);
    };
    var getStatOptsAndCb = function(options, callback) {
      return typeof options === "function" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
    };
    function getPathFromURLPosix2(url) {
      if (url.hostname !== "") {
        throw new errors.TypeError("ERR_INVALID_FILE_URL_HOST", process_1.default.platform);
      }
      var pathname = url.pathname;
      for (var n8 = 0; n8 < pathname.length; n8++) {
        if (pathname[n8] === "%") {
          var third = pathname.codePointAt(n8 + 2) | 32;
          if (pathname[n8 + 1] === "2" && third === 102) {
            throw new errors.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
          }
        }
      }
      return decodeURIComponent(pathname);
    }
    function pathToFilename(path2) {
      if (typeof path2 !== "string" && !buffer_1.Buffer.isBuffer(path2)) {
        try {
          if (!(path2 instanceof h7.URL))
            throw new TypeError(ERRSTR.PATH_STR);
        } catch (err) {
          throw new TypeError(ERRSTR.PATH_STR);
        }
        path2 = getPathFromURLPosix2(path2);
      }
      var pathString = String(path2);
      nullCheck(pathString);
      return pathString;
    }
    exports$42.pathToFilename = pathToFilename;
    var resolve3 = function(filename, base) {
      if (base === void 0) {
        base = process_1.default.cwd();
      }
      return resolveCrossPlatform(base, filename);
    };
    if (isWin) {
      var _resolve_1 = resolve3;
      var unixify_1 = dew$32().unixify;
      resolve3 = function(filename, base) {
        return unixify_1(_resolve_1(filename, base));
      };
    }
    function filenameToSteps(filename, base) {
      var fullPath = resolve3(filename, base);
      var fullPathSansSlash = fullPath.substr(1);
      if (!fullPathSansSlash)
        return [];
      return fullPathSansSlash.split(sep2);
    }
    exports$42.filenameToSteps = filenameToSteps;
    function pathToSteps(path2) {
      return filenameToSteps(pathToFilename(path2));
    }
    exports$42.pathToSteps = pathToSteps;
    function dataToStr(data, encoding) {
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      if (buffer_1.Buffer.isBuffer(data))
        return data.toString(encoding);
      else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data).toString(encoding);
      else
        return String(data);
    }
    exports$42.dataToStr = dataToStr;
    function dataToBuffer(data, encoding) {
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      if (buffer_1.Buffer.isBuffer(data))
        return data;
      else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data);
      else
        return (0, buffer_1.bufferFrom)(String(data), encoding);
    }
    exports$42.dataToBuffer = dataToBuffer;
    function bufferToEncoding(buffer2, encoding) {
      if (!encoding || encoding === "buffer")
        return buffer2;
      else
        return buffer2.toString(encoding);
    }
    exports$42.bufferToEncoding = bufferToEncoding;
    function nullCheck(path2, callback) {
      if (("" + path2).indexOf("\0") !== -1) {
        var er = new Error("Path must be a string without null bytes");
        er.code = ENOENT;
        if (typeof callback !== "function")
          throw er;
        process_1.default.nextTick(callback, er);
        return false;
      }
      return true;
    }
    function _modeToNumber(mode, def) {
      if (typeof mode === "number")
        return mode;
      if (typeof mode === "string")
        return parseInt(mode, 8);
      if (def)
        return modeToNumber(def);
      return void 0;
    }
    function modeToNumber(mode, def) {
      var result = _modeToNumber(mode, def);
      if (typeof result !== "number" || isNaN(result))
        throw new TypeError(ERRSTR.MODE_INT);
      return result;
    }
    function isFd(path2) {
      return path2 >>> 0 === path2;
    }
    function validateFd(fd) {
      if (!isFd(fd))
        throw TypeError(ERRSTR.FD);
    }
    function toUnixTimestamp(time) {
      if (typeof time === "string" && +time == time) {
        return +time;
      }
      if (time instanceof Date) {
        return time.getTime() / 1e3;
      }
      if (isFinite(time)) {
        if (time < 0) {
          return Date.now() / 1e3;
        }
        return time;
      }
      throw new Error("Cannot parse time: " + time);
    }
    exports$42.toUnixTimestamp = toUnixTimestamp;
    function validateUid(uid) {
      if (typeof uid !== "number")
        throw TypeError(ERRSTR.UID);
    }
    function validateGid(gid) {
      if (typeof gid !== "number")
        throw TypeError(ERRSTR.GID);
    }
    function flattenJSON(nestedJSON) {
      var flatJSON = {};
      function flatten(pathPrefix, node) {
        for (var path2 in node) {
          var contentOrNode = node[path2];
          var joinedPath = join2(pathPrefix, path2);
          if (typeof contentOrNode === "string") {
            flatJSON[joinedPath] = contentOrNode;
          } else if (typeof contentOrNode === "object" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
            flatten(joinedPath, contentOrNode);
          } else {
            flatJSON[joinedPath] = null;
          }
        }
      }
      flatten("", nestedJSON);
      return flatJSON;
    }
    var Volume = function() {
      function Volume2(props) {
        if (props === void 0) {
          props = {};
        }
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.maxFiles = 1e4;
        this.openFiles = 0;
        this.promisesApi = (0, promises_1.default)(this);
        this.statWatchers = {};
        this.props = Object.assign({
          Node: node_1.Node,
          Link: node_1.Link,
          File: node_1.File
        }, props);
        var root = this.createLink();
        root.setNode(this.createNode(true));
        var self2 = this;
        this.StatWatcher = function(_super) {
          __extends2(StatWatcher2, _super);
          function StatWatcher2() {
            return _super.call(this, self2) || this;
          }
          return StatWatcher2;
        }(StatWatcher);
        var _ReadStream = FsReadStream;
        this.ReadStream = function(_super) {
          __extends2(class_1, _super);
          function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return _super.apply(this, __spreadArray2([self2], args, false)) || this;
          }
          return class_1;
        }(_ReadStream);
        var _WriteStream = FsWriteStream;
        this.WriteStream = function(_super) {
          __extends2(class_2, _super);
          function class_2() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return _super.apply(this, __spreadArray2([self2], args, false)) || this;
          }
          return class_2;
        }(_WriteStream);
        this.FSWatcher = function(_super) {
          __extends2(FSWatcher2, _super);
          function FSWatcher2() {
            return _super.call(this, self2) || this;
          }
          return FSWatcher2;
        }(FSWatcher);
        this.root = root;
      }
      Volume2.fromJSON = function(json, cwd) {
        var vol2 = new Volume2();
        vol2.fromJSON(json, cwd);
        return vol2;
      };
      Volume2.fromNestedJSON = function(json, cwd) {
        var vol2 = new Volume2();
        vol2.fromNestedJSON(json, cwd);
        return vol2;
      };
      Object.defineProperty(Volume2.prototype, "promises", {
        get: function() {
          if (this.promisesApi === null)
            throw new Error("Promise is not supported in this environment.");
          return this.promisesApi;
        },
        enumerable: false,
        configurable: true
      });
      Volume2.prototype.createLink = function(parent, name2, isDirectory, perm) {
        if (isDirectory === void 0) {
          isDirectory = false;
        }
        if (!parent) {
          return new this.props.Link(this, null, "");
        }
        if (!name2) {
          throw new Error("createLink: name cannot be empty");
        }
        return parent.createChild(name2, this.createNode(isDirectory, perm));
      };
      Volume2.prototype.deleteLink = function(link3) {
        var parent = link3.parent;
        if (parent) {
          parent.deleteChild(link3);
          return true;
        }
        return false;
      };
      Volume2.prototype.newInoNumber = function() {
        var releasedFd = this.releasedInos.pop();
        if (releasedFd)
          return releasedFd;
        else {
          this.ino = (this.ino + 1) % 4294967295;
          return this.ino;
        }
      };
      Volume2.prototype.newFdNumber = function() {
        var releasedFd = this.releasedFds.pop();
        return typeof releasedFd === "number" ? releasedFd : Volume2.fd--;
      };
      Volume2.prototype.createNode = function(isDirectory, perm) {
        if (isDirectory === void 0) {
          isDirectory = false;
        }
        var node = new this.props.Node(this.newInoNumber(), perm);
        if (isDirectory)
          node.setIsDirectory();
        this.inodes[node.ino] = node;
        return node;
      };
      Volume2.prototype.getNode = function(ino) {
        return this.inodes[ino];
      };
      Volume2.prototype.deleteNode = function(node) {
        node.del();
        delete this.inodes[node.ino];
        this.releasedInos.push(node.ino);
      };
      Volume2.prototype.genRndStr = function() {
        var str = (Math.random() + 1).toString(36).substr(2, 6);
        if (str.length === 6)
          return str;
        else
          return this.genRndStr();
      };
      Volume2.prototype.getLink = function(steps) {
        return this.root.walk(steps);
      };
      Volume2.prototype.getLinkOrThrow = function(filename, funcName) {
        var steps = filenameToSteps(filename);
        var link3 = this.getLink(steps);
        if (!link3)
          throw createError(ENOENT, funcName, filename);
        return link3;
      };
      Volume2.prototype.getResolvedLink = function(filenameOrSteps) {
        var steps = typeof filenameOrSteps === "string" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
        var link3 = this.root;
        var i7 = 0;
        while (i7 < steps.length) {
          var step = steps[i7];
          link3 = link3.getChild(step);
          if (!link3)
            return null;
          var node = link3.getNode();
          if (node.isSymlink()) {
            steps = node.symlink.concat(steps.slice(i7 + 1));
            link3 = this.root;
            i7 = 0;
            continue;
          }
          i7++;
        }
        return link3;
      };
      Volume2.prototype.getResolvedLinkOrThrow = function(filename, funcName) {
        var link3 = this.getResolvedLink(filename);
        if (!link3)
          throw createError(ENOENT, funcName, filename);
        return link3;
      };
      Volume2.prototype.resolveSymlinks = function(link3) {
        return this.getResolvedLink(link3.steps.slice(1));
      };
      Volume2.prototype.getLinkAsDirOrThrow = function(filename, funcName) {
        var link3 = this.getLinkOrThrow(filename, funcName);
        if (!link3.getNode().isDirectory())
          throw createError(ENOTDIR, funcName, filename);
        return link3;
      };
      Volume2.prototype.getLinkParent = function(steps) {
        return this.root.walk(steps, steps.length - 1);
      };
      Volume2.prototype.getLinkParentAsDirOrThrow = function(filenameOrSteps, funcName) {
        var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
        var link3 = this.getLinkParent(steps);
        if (!link3)
          throw createError(ENOENT, funcName, sep2 + steps.join(sep2));
        if (!link3.getNode().isDirectory())
          throw createError(ENOTDIR, funcName, sep2 + steps.join(sep2));
        return link3;
      };
      Volume2.prototype.getFileByFd = function(fd) {
        return this.fds[String(fd)];
      };
      Volume2.prototype.getFileByFdOrThrow = function(fd, funcName) {
        if (!isFd(fd))
          throw TypeError(ERRSTR.FD);
        var file = this.getFileByFd(fd);
        if (!file)
          throw createError(EBADF, funcName);
        return file;
      };
      Volume2.prototype.getNodeByIdOrCreate = function(id, flags, perm) {
        if (typeof id === "number") {
          var file = this.getFileByFd(id);
          if (!file)
            throw Error("File nto found");
          return file.node;
        } else {
          var steps = pathToSteps(id);
          var link3 = this.getLink(steps);
          if (link3)
            return link3.getNode();
          if (flags & O_CREAT) {
            var dirLink = this.getLinkParent(steps);
            if (dirLink) {
              var name_1 = steps[steps.length - 1];
              link3 = this.createLink(dirLink, name_1, false, perm);
              return link3.getNode();
            }
          }
          throw createError(ENOENT, "getNodeByIdOrCreate", pathToFilename(id));
        }
      };
      Volume2.prototype.wrapAsync = function(method, args, callback) {
        var _this = this;
        validateCallback(callback);
        (0, setImmediate_1.default)(function() {
          var result;
          try {
            result = method.apply(_this, args);
          } catch (err) {
            callback(err);
            return;
          }
          callback(null, result);
        });
      };
      Volume2.prototype._toJSON = function(link3, json, path2) {
        var _a2;
        if (link3 === void 0) {
          link3 = this.root;
        }
        if (json === void 0) {
          json = {};
        }
        var isEmpty = true;
        var children = link3.children;
        if (link3.getNode().isFile()) {
          children = (_a2 = {}, _a2[link3.getName()] = link3.parent.getChild(link3.getName()), _a2);
          link3 = link3.parent;
        }
        for (var name_2 in children) {
          isEmpty = false;
          var child = link3.getChild(name_2);
          if (!child) {
            throw new Error("_toJSON: unexpected undefined");
          }
          var node = child.getNode();
          if (node.isFile()) {
            var filename = child.getPath();
            if (path2)
              filename = relative2(path2, filename);
            json[filename] = node.getString();
          } else if (node.isDirectory()) {
            this._toJSON(child, json, path2);
          }
        }
        var dirPath = link3.getPath();
        if (path2)
          dirPath = relative2(path2, dirPath);
        if (dirPath && isEmpty) {
          json[dirPath] = null;
        }
        return json;
      };
      Volume2.prototype.toJSON = function(paths, json, isRelative) {
        if (json === void 0) {
          json = {};
        }
        if (isRelative === void 0) {
          isRelative = false;
        }
        var links = [];
        if (paths) {
          if (!(paths instanceof Array))
            paths = [paths];
          for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
            var path2 = paths_1[_i];
            var filename = pathToFilename(path2);
            var link3 = this.getResolvedLink(filename);
            if (!link3)
              continue;
            links.push(link3);
          }
        } else {
          links.push(this.root);
        }
        if (!links.length)
          return json;
        for (var _a2 = 0, links_1 = links; _a2 < links_1.length; _a2++) {
          var link3 = links_1[_a2];
          this._toJSON(link3, json, isRelative ? link3.getPath() : "");
        }
        return json;
      };
      Volume2.prototype.fromJSON = function(json, cwd) {
        if (cwd === void 0) {
          cwd = process_1.default.cwd();
        }
        for (var filename in json) {
          var data = json[filename];
          filename = resolve3(filename, cwd);
          if (typeof data === "string") {
            var dir = dirname2(filename);
            this.mkdirpBase(
              dir,
              511
              /* DIR */
            );
            this.writeFileSync(filename, data);
          } else {
            this.mkdirpBase(
              filename,
              511
              /* DIR */
            );
          }
        }
      };
      Volume2.prototype.fromNestedJSON = function(json, cwd) {
        this.fromJSON(flattenJSON(json), cwd);
      };
      Volume2.prototype.reset = function() {
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.openFiles = 0;
        this.root = this.createLink();
        this.root.setNode(this.createNode(true));
      };
      Volume2.prototype.mountSync = function(mountpoint, json) {
        this.fromJSON(json, mountpoint);
      };
      Volume2.prototype.openLink = function(link3, flagsNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        if (this.openFiles >= this.maxFiles) {
          throw createError(EMFILE, "open", link3.getPath());
        }
        var realLink = link3;
        if (resolveSymlinks)
          realLink = this.resolveSymlinks(link3);
        if (!realLink)
          throw createError(ENOENT, "open", link3.getPath());
        var node = realLink.getNode();
        if (node.isDirectory()) {
          if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)
            throw createError(EISDIR, "open", link3.getPath());
        } else {
          if (flagsNum & O_DIRECTORY)
            throw createError(ENOTDIR, "open", link3.getPath());
        }
        if (!(flagsNum & O_WRONLY)) {
          if (!node.canRead()) {
            throw createError(EACCES, "open", link3.getPath());
          }
        }
        var file = new this.props.File(link3, node, flagsNum, this.newFdNumber());
        this.fds[file.fd] = file;
        this.openFiles++;
        if (flagsNum & O_TRUNC)
          file.truncate();
        return file;
      };
      Volume2.prototype.openFile = function(filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        var steps = filenameToSteps(filename);
        var link3 = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
        if (!link3 && flagsNum & O_CREAT) {
          var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
          if (!dirLink)
            throw createError(ENOENT, "open", sep2 + steps.join(sep2));
          if (flagsNum & O_CREAT && typeof modeNum === "number") {
            link3 = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
          }
        }
        if (link3)
          return this.openLink(link3, flagsNum, resolveSymlinks);
        throw createError(ENOENT, "open", filename);
      };
      Volume2.prototype.openBase = function(filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
        if (!file)
          throw createError(ENOENT, "open", filename);
        return file.fd;
      };
      Volume2.prototype.openSync = function(path2, flags, mode) {
        if (mode === void 0) {
          mode = 438;
        }
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path2);
        var flagsNum = flagsToNumber(flags);
        return this.openBase(fileName, flagsNum, modeNum);
      };
      Volume2.prototype.open = function(path2, flags, a7, b5) {
        var mode = a7;
        var callback = b5;
        if (typeof a7 === "function") {
          mode = 438;
          callback = a7;
        }
        mode = mode || 438;
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path2);
        var flagsNum = flagsToNumber(flags);
        this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
      };
      Volume2.prototype.closeFile = function(file) {
        if (!this.fds[file.fd])
          return;
        this.openFiles--;
        delete this.fds[file.fd];
        this.releasedFds.push(file.fd);
      };
      Volume2.prototype.closeSync = function(fd) {
        validateFd(fd);
        var file = this.getFileByFdOrThrow(fd, "close");
        this.closeFile(file);
      };
      Volume2.prototype.close = function(fd, callback) {
        validateFd(fd);
        this.wrapAsync(this.closeSync, [fd], callback);
      };
      Volume2.prototype.openFileOrGetById = function(id, flagsNum, modeNum) {
        if (typeof id === "number") {
          var file = this.fds[id];
          if (!file)
            throw createError(ENOENT);
          return file;
        } else {
          return this.openFile(pathToFilename(id), flagsNum, modeNum);
        }
      };
      Volume2.prototype.readBase = function(fd, buffer2, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd);
        return file.read(buffer2, Number(offset), Number(length), position);
      };
      Volume2.prototype.readSync = function(fd, buffer2, offset, length, position) {
        validateFd(fd);
        return this.readBase(fd, buffer2, offset, length, position);
      };
      Volume2.prototype.read = function(fd, buffer2, offset, length, position, callback) {
        var _this = this;
        validateCallback(callback);
        if (length === 0) {
          return process_1.default.nextTick(function() {
            if (callback)
              callback(null, 0, buffer2);
          });
        }
        (0, setImmediate_1.default)(function() {
          try {
            var bytes = _this.readBase(fd, buffer2, offset, length, position);
            callback(null, bytes, buffer2);
          } catch (err) {
            callback(err);
          }
        });
      };
      Volume2.prototype.readFileBase = function(id, flagsNum, encoding) {
        var result;
        var isUserFd = typeof id === "number";
        var userOwnsFd = isUserFd && isFd(id);
        var fd;
        if (userOwnsFd)
          fd = id;
        else {
          var filename = pathToFilename(id);
          var steps = filenameToSteps(filename);
          var link3 = this.getResolvedLink(steps);
          if (link3) {
            var node = link3.getNode();
            if (node.isDirectory())
              throw createError(EISDIR, "open", link3.getPath());
          }
          fd = this.openSync(id, flagsNum);
        }
        try {
          result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
        } finally {
          if (!userOwnsFd) {
            this.closeSync(fd);
          }
        }
        return result;
      };
      Volume2.prototype.readFileSync = function(file, options) {
        var opts = getReadFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        return this.readFileBase(file, flagsNum, opts.encoding);
      };
      Volume2.prototype.readFile = function(id, a7, b5) {
        var _a2 = optsAndCbGenerator(getReadFileOptions)(a7, b5), opts = _a2[0], callback = _a2[1];
        var flagsNum = flagsToNumber(opts.flag);
        this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
      };
      Volume2.prototype.writeBase = function(fd, buf, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd, "write");
        return file.write(buf, offset, length, position);
      };
      Volume2.prototype.writeSync = function(fd, a7, b5, c7, d6) {
        validateFd(fd);
        var encoding;
        var offset;
        var length;
        var position;
        var isBuffer3 = typeof a7 !== "string";
        if (isBuffer3) {
          offset = (b5 || 0) | 0;
          length = c7;
          position = d6;
        } else {
          position = b5;
          encoding = c7;
        }
        var buf = dataToBuffer(a7, encoding);
        if (isBuffer3) {
          if (typeof length === "undefined") {
            length = buf.length;
          }
        } else {
          offset = 0;
          length = buf.length;
        }
        return this.writeBase(fd, buf, offset, length, position);
      };
      Volume2.prototype.write = function(fd, a7, b5, c7, d6, e9) {
        var _this = this;
        validateFd(fd);
        var offset;
        var length;
        var position;
        var encoding;
        var callback;
        var tipa = typeof a7;
        var tipb = typeof b5;
        var tipc = typeof c7;
        var tipd = typeof d6;
        if (tipa !== "string") {
          if (tipb === "function") {
            callback = b5;
          } else if (tipc === "function") {
            offset = b5 | 0;
            callback = c7;
          } else if (tipd === "function") {
            offset = b5 | 0;
            length = c7;
            callback = d6;
          } else {
            offset = b5 | 0;
            length = c7;
            position = d6;
            callback = e9;
          }
        } else {
          if (tipb === "function") {
            callback = b5;
          } else if (tipc === "function") {
            position = b5;
            callback = c7;
          } else if (tipd === "function") {
            position = b5;
            encoding = c7;
            callback = d6;
          }
        }
        var buf = dataToBuffer(a7, encoding);
        if (tipa !== "string") {
          if (typeof length === "undefined")
            length = buf.length;
        } else {
          offset = 0;
          length = buf.length;
        }
        var cb = validateCallback(callback);
        (0, setImmediate_1.default)(function() {
          try {
            var bytes = _this.writeBase(fd, buf, offset, length, position);
            if (tipa !== "string") {
              cb(null, bytes, buf);
            } else {
              cb(null, bytes, a7);
            }
          } catch (err) {
            cb(err);
          }
        });
      };
      Volume2.prototype.writeFileBase = function(id, buf, flagsNum, modeNum) {
        var isUserFd = typeof id === "number";
        var fd;
        if (isUserFd)
          fd = id;
        else {
          fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
        }
        var offset = 0;
        var length = buf.length;
        var position = flagsNum & O_APPEND ? void 0 : 0;
        try {
          while (length > 0) {
            var written = this.writeSync(fd, buf, offset, length, position);
            offset += written;
            length -= written;
            if (position !== void 0)
              position += written;
          }
        } finally {
          if (!isUserFd)
            this.closeSync(fd);
        }
      };
      Volume2.prototype.writeFileSync = function(id, data, options) {
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.writeFileBase(id, buf, flagsNum, modeNum);
      };
      Volume2.prototype.writeFile = function(id, data, a7, b5) {
        var options = a7;
        var callback = b5;
        if (typeof a7 === "function") {
          options = writeFileDefaults;
          callback = a7;
        }
        var cb = validateCallback(callback);
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
      };
      Volume2.prototype.linkBase = function(filename1, filename2) {
        var steps1 = filenameToSteps(filename1);
        var link1 = this.getLink(steps1);
        if (!link1)
          throw createError(ENOENT, "link", filename1, filename2);
        var steps2 = filenameToSteps(filename2);
        var dir2 = this.getLinkParent(steps2);
        if (!dir2)
          throw createError(ENOENT, "link", filename1, filename2);
        var name2 = steps2[steps2.length - 1];
        if (dir2.getChild(name2))
          throw createError(EEXIST, "link", filename1, filename2);
        var node = link1.getNode();
        node.nlink++;
        dir2.createChild(name2, node);
      };
      Volume2.prototype.copyFileBase = function(src, dest, flags) {
        var buf = this.readFileSync(src);
        if (flags & COPYFILE_EXCL) {
          if (this.existsSync(dest)) {
            throw createError(EEXIST, "copyFile", src, dest);
          }
        }
        if (flags & COPYFILE_FICLONE_FORCE) {
          throw createError(ENOSYS, "copyFile", src, dest);
        }
        this.writeFileBase(
          dest,
          buf,
          FLAGS.w,
          438
          /* DEFAULT */
        );
      };
      Volume2.prototype.copyFileSync = function(src, dest, flags) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
      };
      Volume2.prototype.copyFile = function(src, dest, a7, b5) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        var flags;
        var callback;
        if (typeof a7 === "function") {
          flags = 0;
          callback = a7;
        } else {
          flags = a7;
          callback = b5;
        }
        validateCallback(callback);
        this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
      };
      Volume2.prototype.linkSync = function(existingPath, newPath) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.linkBase(existingPathFilename, newPathFilename);
      };
      Volume2.prototype.link = function(existingPath, newPath, callback) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
      };
      Volume2.prototype.unlinkBase = function(filename) {
        var steps = filenameToSteps(filename);
        var link3 = this.getLink(steps);
        if (!link3)
          throw createError(ENOENT, "unlink", filename);
        if (link3.length)
          throw Error("Dir not empty...");
        this.deleteLink(link3);
        var node = link3.getNode();
        node.nlink--;
        if (node.nlink <= 0) {
          this.deleteNode(node);
        }
      };
      Volume2.prototype.unlinkSync = function(path2) {
        var filename = pathToFilename(path2);
        this.unlinkBase(filename);
      };
      Volume2.prototype.unlink = function(path2, callback) {
        var filename = pathToFilename(path2);
        this.wrapAsync(this.unlinkBase, [filename], callback);
      };
      Volume2.prototype.symlinkBase = function(targetFilename, pathFilename) {
        var pathSteps = filenameToSteps(pathFilename);
        var dirLink = this.getLinkParent(pathSteps);
        if (!dirLink)
          throw createError(ENOENT, "symlink", targetFilename, pathFilename);
        var name2 = pathSteps[pathSteps.length - 1];
        if (dirLink.getChild(name2))
          throw createError(EEXIST, "symlink", targetFilename, pathFilename);
        var symlink3 = dirLink.createChild(name2);
        symlink3.getNode().makeSymlink(filenameToSteps(targetFilename));
        return symlink3;
      };
      Volume2.prototype.symlinkSync = function(target, path2, type) {
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path2);
        this.symlinkBase(targetFilename, pathFilename);
      };
      Volume2.prototype.symlink = function(target, path2, a7, b5) {
        var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path2);
        this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
      };
      Volume2.prototype.realpathBase = function(filename, encoding) {
        var steps = filenameToSteps(filename);
        var realLink = this.getResolvedLink(steps);
        if (!realLink)
          throw createError(ENOENT, "realpath", filename);
        return (0, encoding_1.strToEncoding)(realLink.getPath(), encoding);
      };
      Volume2.prototype.realpathSync = function(path2, options) {
        return this.realpathBase(pathToFilename(path2), getRealpathOptions(options).encoding);
      };
      Volume2.prototype.realpath = function(path2, a7, b5) {
        var _a2 = getRealpathOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        var pathFilename = pathToFilename(path2);
        this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
      };
      Volume2.prototype.lstatBase = function(filename, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var link3 = this.getLink(filenameToSteps(filename));
        if (!link3)
          throw createError(ENOENT, "lstat", filename);
        return Stats_1.default.build(link3.getNode(), bigint);
      };
      Volume2.prototype.lstatSync = function(path2, options) {
        return this.lstatBase(pathToFilename(path2), getStatOptions(options).bigint);
      };
      Volume2.prototype.lstat = function(path2, a7, b5) {
        var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.lstatBase, [pathToFilename(path2), opts.bigint], callback);
      };
      Volume2.prototype.statBase = function(filename, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var link3 = this.getResolvedLink(filenameToSteps(filename));
        if (!link3)
          throw createError(ENOENT, "stat", filename);
        return Stats_1.default.build(link3.getNode(), bigint);
      };
      Volume2.prototype.statSync = function(path2, options) {
        return this.statBase(pathToFilename(path2), getStatOptions(options).bigint);
      };
      Volume2.prototype.stat = function(path2, a7, b5) {
        var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.statBase, [pathToFilename(path2), opts.bigint], callback);
      };
      Volume2.prototype.fstatBase = function(fd, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var file = this.getFileByFd(fd);
        if (!file)
          throw createError(EBADF, "fstat");
        return Stats_1.default.build(file.node, bigint);
      };
      Volume2.prototype.fstatSync = function(fd, options) {
        return this.fstatBase(fd, getStatOptions(options).bigint);
      };
      Volume2.prototype.fstat = function(fd, a7, b5) {
        var _a2 = getStatOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
      };
      Volume2.prototype.renameBase = function(oldPathFilename, newPathFilename) {
        var link3 = this.getLink(filenameToSteps(oldPathFilename));
        if (!link3)
          throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
        var newPathSteps = filenameToSteps(newPathFilename);
        var newPathDirLink = this.getLinkParent(newPathSteps);
        if (!newPathDirLink)
          throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
        var oldLinkParent = link3.parent;
        if (oldLinkParent) {
          oldLinkParent.deleteChild(link3);
        }
        var name2 = newPathSteps[newPathSteps.length - 1];
        link3.steps = __spreadArray2(__spreadArray2([], newPathDirLink.steps, true), [name2], false);
        newPathDirLink.setChild(link3.getName(), link3);
      };
      Volume2.prototype.renameSync = function(oldPath, newPath) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.renameBase(oldPathFilename, newPathFilename);
      };
      Volume2.prototype.rename = function(oldPath, newPath, callback) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
      };
      Volume2.prototype.existsBase = function(filename) {
        return !!this.statBase(filename);
      };
      Volume2.prototype.existsSync = function(path2) {
        try {
          return this.existsBase(pathToFilename(path2));
        } catch (err) {
          return false;
        }
      };
      Volume2.prototype.exists = function(path2, callback) {
        var _this = this;
        var filename = pathToFilename(path2);
        if (typeof callback !== "function")
          throw Error(ERRSTR.CB);
        (0, setImmediate_1.default)(function() {
          try {
            callback(_this.existsBase(filename));
          } catch (err) {
            callback(false);
          }
        });
      };
      Volume2.prototype.accessBase = function(filename, mode) {
        this.getLinkOrThrow(filename, "access");
      };
      Volume2.prototype.accessSync = function(path2, mode) {
        if (mode === void 0) {
          mode = F_OK2;
        }
        var filename = pathToFilename(path2);
        mode = mode | 0;
        this.accessBase(filename, mode);
      };
      Volume2.prototype.access = function(path2, a7, b5) {
        var mode = F_OK2;
        var callback;
        if (typeof a7 !== "function") {
          mode = a7 | 0;
          callback = validateCallback(b5);
        } else {
          callback = a7;
        }
        var filename = pathToFilename(path2);
        this.wrapAsync(this.accessBase, [filename, mode], callback);
      };
      Volume2.prototype.appendFileSync = function(id, data, options) {
        if (options === void 0) {
          options = appendFileDefaults;
        }
        var opts = getAppendFileOpts(options);
        if (!opts.flag || isFd(id))
          opts.flag = "a";
        this.writeFileSync(id, data, opts);
      };
      Volume2.prototype.appendFile = function(id, data, a7, b5) {
        var _a2 = getAppendFileOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        if (!opts.flag || isFd(id))
          opts.flag = "a";
        this.writeFile(id, data, opts, callback);
      };
      Volume2.prototype.readdirBase = function(filename, options) {
        var steps = filenameToSteps(filename);
        var link3 = this.getResolvedLink(steps);
        if (!link3)
          throw createError(ENOENT, "readdir", filename);
        var node = link3.getNode();
        if (!node.isDirectory())
          throw createError(ENOTDIR, "scandir", filename);
        if (options.withFileTypes) {
          var list_1 = [];
          for (var name_3 in link3.children) {
            var child = link3.getChild(name_3);
            if (!child) {
              continue;
            }
            list_1.push(Dirent_1.default.build(child, options.encoding));
          }
          if (!isWin && options.encoding !== "buffer")
            list_1.sort(function(a7, b5) {
              if (a7.name < b5.name)
                return -1;
              if (a7.name > b5.name)
                return 1;
              return 0;
            });
          return list_1;
        }
        var list = [];
        for (var name_4 in link3.children) {
          list.push((0, encoding_1.strToEncoding)(name_4, options.encoding));
        }
        if (!isWin && options.encoding !== "buffer")
          list.sort();
        return list;
      };
      Volume2.prototype.readdirSync = function(path2, options) {
        var opts = getReaddirOptions(options);
        var filename = pathToFilename(path2);
        return this.readdirBase(filename, opts);
      };
      Volume2.prototype.readdir = function(path2, a7, b5) {
        var _a2 = getReaddirOptsAndCb(a7, b5), options = _a2[0], callback = _a2[1];
        var filename = pathToFilename(path2);
        this.wrapAsync(this.readdirBase, [filename, options], callback);
      };
      Volume2.prototype.readlinkBase = function(filename, encoding) {
        var link3 = this.getLinkOrThrow(filename, "readlink");
        var node = link3.getNode();
        if (!node.isSymlink())
          throw createError(EINVAL, "readlink", filename);
        var str = sep2 + node.symlink.join(sep2);
        return (0, encoding_1.strToEncoding)(str, encoding);
      };
      Volume2.prototype.readlinkSync = function(path2, options) {
        var opts = getDefaultOpts(options);
        var filename = pathToFilename(path2);
        return this.readlinkBase(filename, opts.encoding);
      };
      Volume2.prototype.readlink = function(path2, a7, b5) {
        var _a2 = getDefaultOptsAndCb(a7, b5), opts = _a2[0], callback = _a2[1];
        var filename = pathToFilename(path2);
        this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
      };
      Volume2.prototype.fsyncBase = function(fd) {
        this.getFileByFdOrThrow(fd, "fsync");
      };
      Volume2.prototype.fsyncSync = function(fd) {
        this.fsyncBase(fd);
      };
      Volume2.prototype.fsync = function(fd, callback) {
        this.wrapAsync(this.fsyncBase, [fd], callback);
      };
      Volume2.prototype.fdatasyncBase = function(fd) {
        this.getFileByFdOrThrow(fd, "fdatasync");
      };
      Volume2.prototype.fdatasyncSync = function(fd) {
        this.fdatasyncBase(fd);
      };
      Volume2.prototype.fdatasync = function(fd, callback) {
        this.wrapAsync(this.fdatasyncBase, [fd], callback);
      };
      Volume2.prototype.ftruncateBase = function(fd, len) {
        var file = this.getFileByFdOrThrow(fd, "ftruncate");
        file.truncate(len);
      };
      Volume2.prototype.ftruncateSync = function(fd, len) {
        this.ftruncateBase(fd, len);
      };
      Volume2.prototype.ftruncate = function(fd, a7, b5) {
        var len = typeof a7 === "number" ? a7 : 0;
        var callback = validateCallback(typeof a7 === "number" ? b5 : a7);
        this.wrapAsync(this.ftruncateBase, [fd, len], callback);
      };
      Volume2.prototype.truncateBase = function(path2, len) {
        var fd = this.openSync(path2, "r+");
        try {
          this.ftruncateSync(fd, len);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.truncateSync = function(id, len) {
        if (isFd(id))
          return this.ftruncateSync(id, len);
        this.truncateBase(id, len);
      };
      Volume2.prototype.truncate = function(id, a7, b5) {
        var len = typeof a7 === "number" ? a7 : 0;
        var callback = validateCallback(typeof a7 === "number" ? b5 : a7);
        if (isFd(id))
          return this.ftruncate(id, len, callback);
        this.wrapAsync(this.truncateBase, [id, len], callback);
      };
      Volume2.prototype.futimesBase = function(fd, atime, mtime) {
        var file = this.getFileByFdOrThrow(fd, "futimes");
        var node = file.node;
        node.atime = new Date(atime * 1e3);
        node.mtime = new Date(mtime * 1e3);
      };
      Volume2.prototype.futimesSync = function(fd, atime, mtime) {
        this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
      };
      Volume2.prototype.futimes = function(fd, atime, mtime, callback) {
        this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
      };
      Volume2.prototype.utimesBase = function(filename, atime, mtime) {
        var fd = this.openSync(filename, "r+");
        try {
          this.futimesBase(fd, atime, mtime);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.utimesSync = function(path2, atime, mtime) {
        this.utimesBase(pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime));
      };
      Volume2.prototype.utimes = function(path2, atime, mtime, callback) {
        this.wrapAsync(this.utimesBase, [pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
      };
      Volume2.prototype.mkdirBase = function(filename, modeNum) {
        var steps = filenameToSteps(filename);
        if (!steps.length) {
          throw createError(EEXIST, "mkdir", filename);
        }
        var dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
        var name2 = steps[steps.length - 1];
        if (dir.getChild(name2))
          throw createError(EEXIST, "mkdir", filename);
        dir.createChild(name2, this.createNode(true, modeNum));
      };
      Volume2.prototype.mkdirpBase = function(filename, modeNum) {
        var steps = filenameToSteps(filename);
        var link3 = this.root;
        for (var i7 = 0; i7 < steps.length; i7++) {
          var step = steps[i7];
          if (!link3.getNode().isDirectory())
            throw createError(ENOTDIR, "mkdir", link3.getPath());
          var child = link3.getChild(step);
          if (child) {
            if (child.getNode().isDirectory())
              link3 = child;
            else
              throw createError(ENOTDIR, "mkdir", child.getPath());
          } else {
            link3 = link3.createChild(step, this.createNode(true, modeNum));
          }
        }
      };
      Volume2.prototype.mkdirSync = function(path2, options) {
        var opts = getMkdirOptions(options);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path2);
        if (opts.recursive)
          this.mkdirpBase(filename, modeNum);
        else
          this.mkdirBase(filename, modeNum);
      };
      Volume2.prototype.mkdir = function(path2, a7, b5) {
        var opts = getMkdirOptions(a7);
        var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path2);
        if (opts.recursive)
          this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
        else
          this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
      };
      Volume2.prototype.mkdirpSync = function(path2, mode) {
        this.mkdirSync(path2, {
          mode,
          recursive: true
        });
      };
      Volume2.prototype.mkdirp = function(path2, a7, b5) {
        var mode = typeof a7 === "function" ? void 0 : a7;
        var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
        this.mkdir(path2, {
          mode,
          recursive: true
        }, callback);
      };
      Volume2.prototype.mkdtempBase = function(prefix, encoding, retry2) {
        if (retry2 === void 0) {
          retry2 = 5;
        }
        var filename = prefix + this.genRndStr();
        try {
          this.mkdirBase(
            filename,
            511
            /* DIR */
          );
          return (0, encoding_1.strToEncoding)(filename, encoding);
        } catch (err) {
          if (err.code === EEXIST) {
            if (retry2 > 1)
              return this.mkdtempBase(prefix, encoding, retry2 - 1);
            else
              throw Error("Could not create temp dir.");
          } else
            throw err;
        }
      };
      Volume2.prototype.mkdtempSync = function(prefix, options) {
        var encoding = getDefaultOpts(options).encoding;
        if (!prefix || typeof prefix !== "string")
          throw new TypeError("filename prefix is required");
        nullCheck(prefix);
        return this.mkdtempBase(prefix, encoding);
      };
      Volume2.prototype.mkdtemp = function(prefix, a7, b5) {
        var _a2 = getDefaultOptsAndCb(a7, b5), encoding = _a2[0].encoding, callback = _a2[1];
        if (!prefix || typeof prefix !== "string")
          throw new TypeError("filename prefix is required");
        if (!nullCheck(prefix))
          return;
        this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
      };
      Volume2.prototype.rmdirBase = function(filename, options) {
        var opts = getRmdirOptions(options);
        var link3 = this.getLinkAsDirOrThrow(filename, "rmdir");
        if (link3.length && !opts.recursive)
          throw createError(ENOTEMPTY, "rmdir", filename);
        this.deleteLink(link3);
      };
      Volume2.prototype.rmdirSync = function(path2, options) {
        this.rmdirBase(pathToFilename(path2), options);
      };
      Volume2.prototype.rmdir = function(path2, a7, b5) {
        var opts = getRmdirOptions(a7);
        var callback = validateCallback(typeof a7 === "function" ? a7 : b5);
        this.wrapAsync(this.rmdirBase, [pathToFilename(path2), opts], callback);
      };
      Volume2.prototype.fchmodBase = function(fd, modeNum) {
        var file = this.getFileByFdOrThrow(fd, "fchmod");
        file.chmod(modeNum);
      };
      Volume2.prototype.fchmodSync = function(fd, mode) {
        this.fchmodBase(fd, modeToNumber(mode));
      };
      Volume2.prototype.fchmod = function(fd, mode, callback) {
        this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
      };
      Volume2.prototype.chmodBase = function(filename, modeNum) {
        var fd = this.openSync(filename, "r+");
        try {
          this.fchmodBase(fd, modeNum);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.chmodSync = function(path2, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.chmodBase(filename, modeNum);
      };
      Volume2.prototype.chmod = function(path2, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
      };
      Volume2.prototype.lchmodBase = function(filename, modeNum) {
        var fd = this.openBase(filename, O_RDWR, 0, false);
        try {
          this.fchmodBase(fd, modeNum);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.lchmodSync = function(path2, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.lchmodBase(filename, modeNum);
      };
      Volume2.prototype.lchmod = function(path2, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
      };
      Volume2.prototype.fchownBase = function(fd, uid, gid) {
        this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
      };
      Volume2.prototype.fchownSync = function(fd, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.fchownBase(fd, uid, gid);
      };
      Volume2.prototype.fchown = function(fd, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
      };
      Volume2.prototype.chownBase = function(filename, uid, gid) {
        var link3 = this.getResolvedLinkOrThrow(filename, "chown");
        var node = link3.getNode();
        node.chown(uid, gid);
      };
      Volume2.prototype.chownSync = function(path2, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.chownBase(pathToFilename(path2), uid, gid);
      };
      Volume2.prototype.chown = function(path2, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.chownBase, [pathToFilename(path2), uid, gid], callback);
      };
      Volume2.prototype.lchownBase = function(filename, uid, gid) {
        this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
      };
      Volume2.prototype.lchownSync = function(path2, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.lchownBase(pathToFilename(path2), uid, gid);
      };
      Volume2.prototype.lchown = function(path2, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.lchownBase, [pathToFilename(path2), uid, gid], callback);
      };
      Volume2.prototype.watchFile = function(path2, a7, b5) {
        var filename = pathToFilename(path2);
        var options = a7;
        var listener = b5;
        if (typeof options === "function") {
          listener = a7;
          options = null;
        }
        if (typeof listener !== "function") {
          throw Error('"watchFile()" requires a listener function');
        }
        var interval = 5007;
        var persistent = true;
        if (options && typeof options === "object") {
          if (typeof options.interval === "number")
            interval = options.interval;
          if (typeof options.persistent === "boolean")
            persistent = options.persistent;
        }
        var watcher = this.statWatchers[filename];
        if (!watcher) {
          watcher = new this.StatWatcher();
          watcher.start(filename, persistent, interval);
          this.statWatchers[filename] = watcher;
        }
        watcher.addListener("change", listener);
        return watcher;
      };
      Volume2.prototype.unwatchFile = function(path2, listener) {
        var filename = pathToFilename(path2);
        var watcher = this.statWatchers[filename];
        if (!watcher)
          return;
        if (typeof listener === "function") {
          watcher.removeListener("change", listener);
        } else {
          watcher.removeAllListeners("change");
        }
        if (watcher.listenerCount("change") === 0) {
          watcher.stop();
          delete this.statWatchers[filename];
        }
      };
      Volume2.prototype.createReadStream = function(path2, options) {
        return new this.ReadStream(path2, options);
      };
      Volume2.prototype.createWriteStream = function(path2, options) {
        return new this.WriteStream(path2, options);
      };
      Volume2.prototype.watch = function(path2, options, listener) {
        var filename = pathToFilename(path2);
        var givenOptions = options;
        if (typeof options === "function") {
          listener = options;
          givenOptions = null;
        }
        var _a2 = getDefaultOpts(givenOptions), persistent = _a2.persistent, recursive = _a2.recursive, encoding = _a2.encoding;
        if (persistent === void 0)
          persistent = true;
        if (recursive === void 0)
          recursive = false;
        var watcher = new this.FSWatcher();
        watcher.start(filename, persistent, recursive, encoding);
        if (listener) {
          watcher.addListener("change", listener);
        }
        return watcher;
      };
      Volume2.fd = 2147483647;
      return Volume2;
    }();
    exports$42.Volume = Volume;
    function emitStop(self2) {
      self2.emit("stop");
    }
    var StatWatcher = function(_super) {
      __extends2(StatWatcher2, _super);
      function StatWatcher2(vol2) {
        var _this = _super.call(this) || this;
        _this.onInterval = function() {
          try {
            var stats = _this.vol.statSync(_this.filename);
            if (_this.hasChanged(stats)) {
              _this.emit("change", stats, _this.prev);
              _this.prev = stats;
            }
          } finally {
            _this.loop();
          }
        };
        _this.vol = vol2;
        return _this;
      }
      StatWatcher2.prototype.loop = function() {
        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
      };
      StatWatcher2.prototype.hasChanged = function(stats) {
        if (stats.mtimeMs > this.prev.mtimeMs)
          return true;
        if (stats.nlink !== this.prev.nlink)
          return true;
        return false;
      };
      StatWatcher2.prototype.start = function(path2, persistent, interval) {
        if (persistent === void 0) {
          persistent = true;
        }
        if (interval === void 0) {
          interval = 5007;
        }
        this.filename = pathToFilename(path2);
        this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global4) : setTimeoutUnref_1.default;
        this.interval = interval;
        this.prev = this.vol.statSync(this.filename);
        this.loop();
      };
      StatWatcher2.prototype.stop = function() {
        clearTimeout(this.timeoutRef);
        process_1.default.nextTick(emitStop, this);
      };
      return StatWatcher2;
    }(events_1.EventEmitter);
    exports$42.StatWatcher = StatWatcher;
    var pool;
    function allocNewPool(poolSize) {
      pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
      pool.used = 0;
    }
    util.inherits(FsReadStream, stream_1.Readable);
    exports$42.ReadStream = FsReadStream;
    function FsReadStream(vol2, path2, options) {
      if (!(this instanceof FsReadStream))
        return new FsReadStream(vol2, path2, options);
      this._vol = vol2;
      options = Object.assign({}, getOptions(options, {}));
      if (options.highWaterMark === void 0)
        options.highWaterMark = 64 * 1024;
      stream_1.Readable.call(this, options);
      this.path = pathToFilename(path2);
      this.fd = options.fd === void 0 ? null : options.fd;
      this.flags = options.flags === void 0 ? "r" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.end = options.end;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = void 0;
      this.bytesRead = 0;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw new TypeError('"end" option must be a Number');
        }
        if (this.start > this.end) {
          throw new Error('"start" option must be <= "end" option');
        }
        this.pos = this.start;
      }
      if (typeof this.fd !== "number")
        this.open();
      this.on("end", function() {
        if (this.autoClose) {
          if (this.destroy)
            this.destroy();
        }
      });
    }
    FsReadStream.prototype.open = function() {
      var self2 = this;
      this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
        if (er) {
          if (self2.autoClose) {
            if (self2.destroy)
              self2.destroy();
          }
          self2.emit("error", er);
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2.read();
      });
    };
    FsReadStream.prototype._read = function(n8) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._read(n8);
        });
      }
      if (this.destroyed)
        return;
      if (!pool || pool.length - pool.used < kMinPoolSpace) {
        allocNewPool(this._readableState.highWaterMark);
      }
      var thisPool = pool;
      var toRead = Math.min(pool.length - pool.used, n8);
      var start = pool.used;
      if (this.pos !== void 0)
        toRead = Math.min(this.end - this.pos + 1, toRead);
      if (toRead <= 0)
        return this.push(null);
      var self2 = this;
      this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
      if (this.pos !== void 0)
        this.pos += toRead;
      pool.used += toRead;
      function onread(er, bytesRead) {
        if (er) {
          if (self2.autoClose && self2.destroy) {
            self2.destroy();
          }
          self2.emit("error", er);
        } else {
          var b5 = null;
          if (bytesRead > 0) {
            self2.bytesRead += bytesRead;
            b5 = thisPool.slice(start, start + bytesRead);
          }
          self2.push(b5);
        }
      }
    };
    FsReadStream.prototype._destroy = function(err, cb) {
      this.close(function(err2) {
        cb(err || err2);
      });
    };
    FsReadStream.prototype.close = function(cb) {
      var _this = this;
      if (cb)
        this.once("close", cb);
      if (this.closed || typeof this.fd !== "number") {
        if (typeof this.fd !== "number") {
          this.once("open", closeOnOpen);
          return;
        }
        return process_1.default.nextTick(function() {
          return _this.emit("close");
        });
      }
      this.closed = true;
      this._vol.close(this.fd, function(er) {
        if (er)
          _this.emit("error", er);
        else
          _this.emit("close");
      });
      this.fd = null;
    };
    function closeOnOpen(fd) {
      this.close();
    }
    util.inherits(FsWriteStream, stream_1.Writable);
    exports$42.WriteStream = FsWriteStream;
    function FsWriteStream(vol2, path2, options) {
      if (!(this instanceof FsWriteStream))
        return new FsWriteStream(vol2, path2, options);
      this._vol = vol2;
      options = Object.assign({}, getOptions(options, {}));
      stream_1.Writable.call(this, options);
      this.path = pathToFilename(path2);
      this.fd = options.fd === void 0 ? null : options.fd;
      this.flags = options.flags === void 0 ? "w" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
      this.pos = void 0;
      this.bytesWritten = 0;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.start < 0) {
          throw new Error('"start" must be >= zero');
        }
        this.pos = this.start;
      }
      if (options.encoding)
        this.setDefaultEncoding(options.encoding);
      if (typeof this.fd !== "number")
        this.open();
      this.once("finish", function() {
        if (this.autoClose) {
          this.close();
        }
      });
    }
    FsWriteStream.prototype.open = function() {
      this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
        if (er) {
          if (this.autoClose && this.destroy) {
            this.destroy();
          }
          this.emit("error", er);
          return;
        }
        this.fd = fd;
        this.emit("open", fd);
      }.bind(this));
    };
    FsWriteStream.prototype._write = function(data, encoding, cb) {
      if (!(data instanceof buffer_1.Buffer))
        return this.emit("error", new Error("Invalid data"));
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._write(data, encoding, cb);
        });
      }
      var self2 = this;
      this._vol.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {
        if (er) {
          if (self2.autoClose && self2.destroy) {
            self2.destroy();
          }
          return cb(er);
        }
        self2.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0)
        this.pos += data.length;
    };
    FsWriteStream.prototype._writev = function(data, cb) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._writev(data, cb);
        });
      }
      var self2 = this;
      var len = data.length;
      var chunks = new Array(len);
      var size = 0;
      for (var i7 = 0; i7 < len; i7++) {
        var chunk = data[i7].chunk;
        chunks[i7] = chunk;
        size += chunk.length;
      }
      var buf = buffer_1.Buffer.concat(chunks);
      this._vol.write(this.fd, buf, 0, buf.length, this.pos, function(er, bytes) {
        if (er) {
          if (self2.destroy)
            self2.destroy();
          return cb(er);
        }
        self2.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0)
        this.pos += size;
    };
    FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
    FsWriteStream.prototype.close = FsReadStream.prototype.close;
    FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
    var FSWatcher = function(_super) {
      __extends2(FSWatcher2, _super);
      function FSWatcher2(vol2) {
        var _this = _super.call(this) || this;
        _this._filename = "";
        _this._filenameEncoded = "";
        _this._recursive = false;
        _this._encoding = encoding_1.ENCODING_UTF8;
        _this._onNodeChange = function() {
          _this._emit("change");
        };
        _this._onParentChild = function(link3) {
          if (link3.getName() === _this._getName()) {
            _this._emit("rename");
          }
        };
        _this._emit = function(type) {
          _this.emit("change", type, _this._filenameEncoded);
        };
        _this._persist = function() {
          _this._timer = setTimeout(_this._persist, 1e6);
        };
        _this._vol = vol2;
        return _this;
      }
      FSWatcher2.prototype._getName = function() {
        return this._steps[this._steps.length - 1];
      };
      FSWatcher2.prototype.start = function(path2, persistent, recursive, encoding) {
        if (persistent === void 0) {
          persistent = true;
        }
        if (recursive === void 0) {
          recursive = false;
        }
        if (encoding === void 0) {
          encoding = encoding_1.ENCODING_UTF8;
        }
        this._filename = pathToFilename(path2);
        this._steps = filenameToSteps(this._filename);
        this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
        this._recursive = recursive;
        this._encoding = encoding;
        try {
          this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
        } catch (err) {
          var error = new Error("watch " + this._filename + " " + err.code);
          error.code = err.code;
          error.errno = err.code;
          throw error;
        }
        this._link.getNode().on("change", this._onNodeChange);
        this._link.on("child:add", this._onNodeChange);
        this._link.on("child:delete", this._onNodeChange);
        var parent = this._link.parent;
        if (parent) {
          parent.setMaxListeners(parent.getMaxListeners() + 1);
          parent.on("child:delete", this._onParentChild);
        }
        if (persistent)
          this._persist();
      };
      FSWatcher2.prototype.close = function() {
        clearTimeout(this._timer);
        this._link.getNode().removeListener("change", this._onNodeChange);
        var parent = this._link.parent;
        if (parent) {
          parent.removeListener("child:delete", this._onParentChild);
        }
      };
      return FSWatcher2;
    }(events_1.EventEmitter);
    exports$42.FSWatcher = FSWatcher;
    return exports$42;
  }
  function dew$13() {
    if (_dewExec$13)
      return exports$33;
    _dewExec$13 = true;
    Object.defineProperty(exports$33, "__esModule", {
      value: true
    });
    exports$33.fsAsyncMethods = exports$33.fsSyncMethods = exports$33.fsProps = void 0;
    var fsProps = ["constants", "F_OK", "R_OK", "W_OK", "X_OK", "Stats"];
    exports$33.fsProps = fsProps;
    var fsSyncMethods = ["renameSync", "ftruncateSync", "truncateSync", "chownSync", "fchownSync", "lchownSync", "chmodSync", "fchmodSync", "lchmodSync", "statSync", "lstatSync", "fstatSync", "linkSync", "symlinkSync", "readlinkSync", "realpathSync", "unlinkSync", "rmdirSync", "mkdirSync", "mkdirpSync", "readdirSync", "closeSync", "openSync", "utimesSync", "futimesSync", "fsyncSync", "writeSync", "readSync", "readFileSync", "writeFileSync", "appendFileSync", "existsSync", "accessSync", "fdatasyncSync", "mkdtempSync", "copyFileSync", "createReadStream", "createWriteStream"];
    exports$33.fsSyncMethods = fsSyncMethods;
    var fsAsyncMethods = ["rename", "ftruncate", "truncate", "chown", "fchown", "lchown", "chmod", "fchmod", "lchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "mkdirp", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "exists", "access", "fdatasync", "mkdtemp", "copyFile", "watchFile", "unwatchFile", "watch"];
    exports$33.fsAsyncMethods = fsAsyncMethods;
    return exports$33;
  }
  function dew7() {
    if (_dewExec7)
      return exports$23;
    _dewExec7 = true;
    var __assign = exports$23 && exports$23.__assign || function() {
      __assign = Object.assign || function(t8) {
        for (var s6, i7 = 1, n8 = arguments.length; i7 < n8; i7++) {
          s6 = arguments[i7];
          for (var p7 in s6)
            if (Object.prototype.hasOwnProperty.call(s6, p7))
              t8[p7] = s6[p7];
        }
        return t8;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports$23, "__esModule", {
      value: true
    });
    exports$23.fs = exports$23.createFsFromVolume = exports$23.vol = exports$23.Volume = void 0;
    var Stats_1 = dew$d2();
    var Dirent_1 = dew$92();
    var volume_1 = dew$23();
    var _a = dew$13(), fsSyncMethods = _a.fsSyncMethods, fsAsyncMethods = _a.fsAsyncMethods;
    var constants_1 = dew$f2();
    var F_OK2 = constants_1.constants.F_OK, R_OK2 = constants_1.constants.R_OK, W_OK2 = constants_1.constants.W_OK, X_OK2 = constants_1.constants.X_OK;
    exports$23.Volume = volume_1.Volume;
    exports$23.vol = new volume_1.Volume();
    function createFsFromVolume2(vol2) {
      var fs3 = {
        F_OK: F_OK2,
        R_OK: R_OK2,
        W_OK: W_OK2,
        X_OK: X_OK2,
        constants: constants_1.constants,
        Stats: Stats_1.default,
        Dirent: Dirent_1.default
      };
      for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
        var method = fsSyncMethods_1[_i];
        if (typeof vol2[method] === "function")
          fs3[method] = vol2[method].bind(vol2);
      }
      for (var _a2 = 0, fsAsyncMethods_1 = fsAsyncMethods; _a2 < fsAsyncMethods_1.length; _a2++) {
        var method = fsAsyncMethods_1[_a2];
        if (typeof vol2[method] === "function")
          fs3[method] = vol2[method].bind(vol2);
      }
      fs3.StatWatcher = vol2.StatWatcher;
      fs3.FSWatcher = vol2.FSWatcher;
      fs3.WriteStream = vol2.WriteStream;
      fs3.ReadStream = vol2.ReadStream;
      fs3.promises = vol2.promises;
      fs3._toUnixTimestamp = volume_1.toUnixTimestamp;
      return fs3;
    }
    exports$23.createFsFromVolume = createFsFromVolume2;
    exports$23.fs = createFsFromVolume2(exports$23.vol);
    exports$23 = __assign(__assign({}, exports$23), exports$23.fs);
    exports$23.semantic = true;
    return exports$23;
  }
  function unimplemented(name2) {
    throw new Error(`Node.js fs ${name2} is not supported by JSPM core in the browser`);
  }
  function watchStdo(path2, fd, listener) {
    let oldSize = 0;
    const decoder = new TextDecoder();
    vol.watch(path2, "utf8", () => {
      const { size } = vol.fstatSync(fd);
      const buf = Buffer2.alloc(size - oldSize);
      vol.readSync(fd, buf, 0, buf.length, oldSize);
      oldSize = size;
      listener(decoder.decode(buf, { stream: true }));
    });
  }
  function handleFsUrl(url, isSync) {
    if (url.protocol === "file:")
      return fileURLToPath(url);
    if (url.protocol === "https:" || url.protocol === "http:") {
      const path2 = "\\\\url\\" + url.href.replaceAll(/\//g, "\\\\");
      if (existsSync(path2))
        return path2;
      if (isSync)
        throw new Error(`Cannot sync request URL ${url} via FS. JSPM FS support for network URLs requires using async FS methods or priming the MemFS cache first with an async request before a sync request.`);
      return (async () => {
        const res = await fetch(url);
        if (!res.ok)
          throw new Error(`Unable to fetch ${url.href}, ${res.status}`);
        const buf = await res.arrayBuffer();
        writeFileSync(path2, Buffer2.from(buf));
        return path2;
      })();
    }
    throw new Error("URL " + url + " not supported in JSPM FS implementation.");
  }
  function wrapFsSync(fn) {
    return function(path2, ...args) {
      if (path2 instanceof URL)
        return fn(handleFsUrl(path2, true), ...args);
      return fn(path2, ...args);
    };
  }
  function wrapFsPromise(fn) {
    return async function(path2, ...args) {
      if (path2 instanceof URL)
        return fn(await handleFsUrl(path2), ...args);
      return fn(path2, ...args);
    };
  }
  function wrapFsCallback(fn) {
    return function(path2, ...args) {
      const cb = args[args.length - 1];
      if (path2 instanceof URL && typeof cb === "function") {
        handleFsUrl(path2).then((path3) => {
          fn(path3, ...args);
        }, cb);
      } else {
        fn(path2, ...args);
      }
    };
  }
  var exports$h, _dewExec$f2, exports$g2, _dewExec$e2, exports$f2, _dewExec$d2, exports$e2, _dewExec$c2, exports$d2, _dewExec$b2, _global$3, exports$c2, _dewExec$a2, exports$b2, _dewExec$92, exports$a2, _dewExec$82, _global$22, exports$92, _dewExec$72, exports$82, _dewExec$62, exports$72, _dewExec$52, _global$12, exports$62, _dewExec$42, exports$52, _dewExec$32, exports$42, _dewExec$23, _global4, exports$33, _dewExec$13, exports$23, _dewExec7, exports$15, exports7, vol, createFsFromVolume, fs, appendFile, appendFileSync, access, accessSync, chown, chownSync, chmod, chmodSync, close, closeSync, copyFile, copyFileSync, cp, cpSync, createReadStream, createWriteStream, exists, existsSync, fchown, fchownSync, fchmod, fchmodSync, fdatasync, fdatasyncSync, fstat, fstatSync, fsync, fsyncSync, ftruncate, ftruncateSync, futimes, futimesSync, lchown, lchownSync, lchmod, lchmodSync, link, linkSync, lstat, lstatSync, mkdir, mkdirSync, mkdtemp, mkdtempSync, open, openSync, opendir, opendirSync, readdir, readdirSync, read, readSync, readv, readvSync, readFile, readFileSync, readlink, readlinkSync, realpath, realpathSync, rename, renameSync, rm, rmSync, rmdir, rmdirSync, stat, statSync, symlink, symlinkSync, truncate, truncateSync, unwatchFile, unlink, unlinkSync, utimes, utimesSync, watch, watchFile, writeFile, writeFileSync, write, writeSync, writev, writevSync, Dir, Dirent, Stats, ReadStream, WriteStream, FileReadStream, FileWriteStream, _toUnixTimestamp, F_OK, R_OK, W_OK, X_OK, constants, promises2;
  var init_fs = __esm({
    "node_modules/@jspm/core/nodelibs/browser/fs.js"() {
      init_dirname();
      init_buffer2();
      init_chunk_44e51b61();
      init_assert2();
      init_util();
      init_chunk_b4205b57();
      init_path();
      init_chunk_2eac56ff();
      init_events();
      init_chunk_4bd36a8f();
      init_stream();
      init_url();
      init_chunk_23dbec7b();
      init_chunk_6c718bbe();
      init_buffer();
      init_chunk_ce0fbc82();
      init_chunk_5decc758();
      init_chunk_4ccc3a29();
      init_chunk_924bb2e1();
      init_chunk_b04e620d();
      exports$h = {};
      _dewExec$f2 = false;
      exports$g2 = {};
      _dewExec$e2 = false;
      exports$f2 = {};
      _dewExec$d2 = false;
      exports$e2 = {};
      _dewExec$c2 = false;
      exports$d2 = {};
      _dewExec$b2 = false;
      _global$3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$c2 = {};
      _dewExec$a2 = false;
      exports$b2 = {};
      _dewExec$92 = false;
      exports$a2 = {};
      _dewExec$82 = false;
      _global$22 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$92 = {};
      _dewExec$72 = false;
      exports$82 = {};
      _dewExec$62 = false;
      exports$72 = {};
      _dewExec$52 = false;
      _global$12 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$62 = {};
      _dewExec$42 = false;
      exports$52 = {};
      _dewExec$32 = false;
      exports$42 = {};
      _dewExec$23 = false;
      _global4 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$33 = {};
      _dewExec$13 = false;
      exports$23 = {};
      _dewExec7 = false;
      exports$15 = dew7();
      exports$15["__esModule"];
      exports$15["fs"];
      exports$15["createFsFromVolume"];
      exports$15["vol"];
      exports$15["Volume"];
      exports$15["semantic"];
      exports7 = dew$23();
      exports7["__esModule"];
      exports7["FSWatcher"];
      exports7["StatWatcher"];
      exports7["Volume"];
      exports7["toUnixTimestamp"];
      exports7["bufferToEncoding"];
      exports7["dataToBuffer"];
      exports7["dataToStr"];
      exports7["pathToSteps"];
      exports7["filenameToSteps"];
      exports7["pathToFilename"];
      exports7["flagsToNumber"];
      exports7["FLAGS"];
      exports7["ReadStream"];
      exports7["WriteStream"];
      ({ vol, createFsFromVolume } = exports$15);
      vol.fromNestedJSON({
        "/dev": { stdin: "", stdout: "", stderr: "" },
        "/usr/bin": {},
        "/home": {},
        "/tmp": {}
      });
      vol.releasedFds = [2, 1, 0];
      vol.openSync("/dev/stdin", "w");
      vol.openSync("/dev/stdout", "r");
      vol.openSync("/dev/stderr", "r");
      watchStdo("/dev/stdout", 1, console.log);
      watchStdo("/dev/stderr", 2, console.error);
      fs = createFsFromVolume(vol);
      fs.opendir = () => unimplemented("opendir");
      fs.opendirSync = () => unimplemented("opendirSync");
      fs.promises.opendir = () => unimplemented("promises.opendir");
      fs.cp = () => unimplemented("cp");
      fs.cpSync = () => unimplemented("cpSync");
      fs.promises.cp = () => unimplemented("promises.cp");
      fs.readv = () => unimplemented("readv");
      fs.readvSync = () => unimplemented("readvSync");
      fs.rm = () => unimplemented("rm");
      fs.rmSync = () => unimplemented("rmSync");
      fs.promises.rm = () => unimplemented("promises.rm");
      fs.Dir = () => unimplemented("Dir");
      fs.promises.watch = () => unimplemented("promises.watch");
      fs.FileReadStream = fs.ReadStream;
      fs.FileWriteStream = fs.WriteStream;
      fs.promises.readFile = wrapFsPromise(fs.promises.readFile);
      fs.readFile = wrapFsCallback(fs.readFile);
      fs.readFileSync = wrapFsSync(fs.readFileSync);
      ({
        appendFile,
        appendFileSync,
        access,
        accessSync,
        chown,
        chownSync,
        chmod,
        chmodSync,
        close,
        closeSync,
        copyFile,
        copyFileSync,
        cp,
        cpSync,
        createReadStream,
        createWriteStream,
        exists,
        existsSync,
        fchown,
        fchownSync,
        fchmod,
        fchmodSync,
        fdatasync,
        fdatasyncSync,
        fstat,
        fstatSync,
        fsync,
        fsyncSync,
        ftruncate,
        ftruncateSync,
        futimes,
        futimesSync,
        lchown,
        lchownSync,
        lchmod,
        lchmodSync,
        link,
        linkSync,
        lstat,
        lstatSync,
        mkdir,
        mkdirSync,
        mkdtemp,
        mkdtempSync,
        open,
        openSync,
        opendir,
        opendirSync,
        readdir,
        readdirSync,
        read,
        readSync,
        readv,
        readvSync,
        readFile,
        readFileSync,
        readlink,
        readlinkSync,
        realpath,
        realpathSync,
        rename,
        renameSync,
        rm,
        rmSync,
        rmdir,
        rmdirSync,
        stat,
        statSync,
        symlink,
        symlinkSync,
        truncate,
        truncateSync,
        unwatchFile,
        unlink,
        unlinkSync,
        utimes,
        utimesSync,
        watch,
        watchFile,
        writeFile,
        writeFileSync,
        write,
        writeSync,
        writev,
        writevSync,
        Dir,
        Dirent,
        Stats,
        ReadStream,
        WriteStream,
        FileReadStream,
        FileWriteStream,
        _toUnixTimestamp,
        constants: { F_OK, R_OK, W_OK, X_OK },
        constants,
        promises: promises2
      } = fs);
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/fs/promises.js
  var promises_exports = {};
  __export(promises_exports, {
    access: () => access2,
    appendFile: () => appendFile2,
    chmod: () => chmod2,
    chown: () => chown2,
    copyFile: () => copyFile2,
    cp: () => cp2,
    default: () => promises2,
    lchmod: () => lchmod2,
    lchown: () => lchown2,
    link: () => link2,
    lstat: () => lstat2,
    mkdir: () => mkdir2,
    mkdtemp: () => mkdtemp2,
    open: () => open2,
    opendir: () => opendir2,
    readFile: () => readFile2,
    readdir: () => readdir2,
    readlink: () => readlink2,
    realpath: () => realpath2,
    rename: () => rename2,
    rm: () => rm2,
    rmdir: () => rmdir2,
    stat: () => stat2,
    symlink: () => symlink2,
    truncate: () => truncate2,
    unlink: () => unlink2,
    utimes: () => utimes2,
    watch: () => watch2,
    writeFile: () => writeFile2
  });
  var access2, copyFile2, cp2, open2, opendir2, rename2, truncate2, rm2, rmdir2, mkdir2, readdir2, readlink2, symlink2, lstat2, stat2, link2, unlink2, chmod2, lchmod2, lchown2, chown2, utimes2, realpath2, mkdtemp2, writeFile2, appendFile2, readFile2, watch2;
  var init_promises = __esm({
    "node_modules/@jspm/core/nodelibs/browser/fs/promises.js"() {
      init_dirname();
      init_buffer2();
      init_fs();
      init_fs();
      init_chunk_44e51b61();
      init_chunk_4bd36a8f();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      init_chunk_2eac56ff();
      init_chunk_4ccc3a29();
      init_assert2();
      init_util();
      init_path();
      init_chunk_23dbec7b();
      init_events();
      init_stream();
      init_chunk_6c718bbe();
      init_url();
      init_chunk_924bb2e1();
      init_chunk_b04e620d();
      init_buffer();
      ({
        access: access2,
        copyFile: copyFile2,
        cp: cp2,
        open: open2,
        opendir: opendir2,
        rename: rename2,
        truncate: truncate2,
        rm: rm2,
        rmdir: rmdir2,
        mkdir: mkdir2,
        readdir: readdir2,
        readlink: readlink2,
        symlink: symlink2,
        lstat: lstat2,
        stat: stat2,
        link: link2,
        unlink: unlink2,
        chmod: chmod2,
        lchmod: lchmod2,
        lchown: lchown2,
        chown: chown2,
        utimes: utimes2,
        realpath: realpath2,
        mkdtemp: mkdtemp2,
        writeFile: writeFile2,
        appendFile: appendFile2,
        readFile: readFile2,
        watch: watch2
      } = promises2);
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js
  function evaluationString(fun, ...args) {
    if (isString3(fun)) {
      assert(args.length === 0, "Cannot evaluate a string with arguments");
      return fun;
    }
    function serializeArgument(arg) {
      if (Object.is(arg, void 0)) {
        return "undefined";
      }
      return JSON.stringify(arg);
    }
    return `(${fun})(${args.map(serializeArgument).join(",")})`;
  }
  async function importFSPromises() {
    if (!fs2) {
      try {
        fs2 = await Promise.resolve().then(() => (init_promises(), promises_exports));
      } catch (error) {
        if (error instanceof TypeError) {
          throw new Error("Cannot write to a path outside of a Node-like environment.");
        }
        throw error;
      }
    }
    return fs2;
  }
  async function getReadableAsBuffer(readable, path2) {
    const buffers = [];
    const reader = readable.getReader();
    if (path2) {
      const fs3 = await importFSPromises();
      const fileHandle = await fs3.open(path2, "w+");
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          buffers.push(value);
          await fileHandle.writeFile(value);
        }
      } finally {
        await fileHandle.close();
      }
    } else {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        buffers.push(value);
      }
    }
    try {
      return Buffer2.concat(buffers);
    } catch (error) {
      debugError(error);
      return null;
    }
  }
  async function getReadableFromProtocolStream(client, handle) {
    return new ReadableStream({
      async pull(controller) {
        function getUnit8Array(data2, isBase64) {
          if (isBase64) {
            return Uint8Array.from(atob(data2), (m6) => {
              return m6.codePointAt(0);
            });
          }
          const encoder = new TextEncoder();
          return encoder.encode(data2);
        }
        const { data, base64Encoded, eof } = await client.send("IO.read", {
          handle
        });
        controller.enqueue(getUnit8Array(data, base64Encoded ?? false));
        if (eof) {
          await client.send("IO.close", { handle });
          controller.close();
        }
      }
    });
  }
  function validateDialogType(type) {
    let dialogType = null;
    const validDialogTypes = /* @__PURE__ */ new Set([
      "alert",
      "confirm",
      "prompt",
      "beforeunload"
    ]);
    if (validDialogTypes.has(type)) {
      dialogType = type;
    }
    assert(dialogType, `Unknown javascript dialog type: ${type}`);
    return dialogType;
  }
  function timeout(ms, cause) {
    return ms === 0 ? NEVER : timer(ms).pipe(map(() => {
      throw new TimeoutError(`Timed out after waiting ${ms}ms`, { cause });
    }));
  }
  function getSourceUrlComment(url) {
    return `//# sourceURL=${url}`;
  }
  function parsePDFOptions(options = {}, lengthUnit = "in") {
    const defaults = {
      scale: 1,
      displayHeaderFooter: false,
      headerTemplate: "",
      footerTemplate: "",
      printBackground: false,
      landscape: false,
      pageRanges: "",
      preferCSSPageSize: false,
      omitBackground: false,
      outline: false,
      tagged: true
    };
    let width = 8.5;
    let height = 11;
    if (options.format) {
      const format5 = paperFormats[options.format.toLowerCase()];
      assert(format5, "Unknown paper format: " + options.format);
      width = format5.width;
      height = format5.height;
    } else {
      width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;
      height = convertPrintParameterToInches(options.height, lengthUnit) ?? height;
    }
    const margin = {
      top: convertPrintParameterToInches(options.margin?.top, lengthUnit) || 0,
      left: convertPrintParameterToInches(options.margin?.left, lengthUnit) || 0,
      bottom: convertPrintParameterToInches(options.margin?.bottom, lengthUnit) || 0,
      right: convertPrintParameterToInches(options.margin?.right, lengthUnit) || 0
    };
    if (options.outline) {
      options.tagged = true;
    }
    return {
      ...defaults,
      ...options,
      width,
      height,
      margin
    };
  }
  function convertPrintParameterToInches(parameter, lengthUnit = "in") {
    if (typeof parameter === "undefined") {
      return void 0;
    }
    let pixels;
    if (isNumber3(parameter)) {
      pixels = parameter;
    } else if (isString3(parameter)) {
      const text = parameter;
      let unit = text.substring(text.length - 2).toLowerCase();
      let valueText = "";
      if (unit in unitToPixels) {
        valueText = text.substring(0, text.length - 2);
      } else {
        unit = "px";
        valueText = text;
      }
      const value = Number(valueText);
      assert(!isNaN(value), "Failed to parse parameter value: " + text);
      pixels = value * unitToPixels[unit];
    } else {
      throw new Error("page.pdf() Cannot handle parameter type: " + typeof parameter);
    }
    return pixels / unitToPixels[lengthUnit];
  }
  function fromEmitterEvent(emitter, eventName) {
    return new Observable((subscriber) => {
      const listener = (event) => {
        subscriber.next(event);
      };
      emitter.on(eventName, listener);
      return () => {
        emitter.off(eventName, listener);
      };
    });
  }
  function filterAsync(predicate) {
    return mergeMap((value) => {
      return from(Promise.resolve(predicate(value))).pipe(filter((isMatch) => {
        return isMatch;
      }), map(() => {
        return value;
      }));
    });
  }
  var debugError, DEFAULT_VIEWPORT, SOURCE_URL, PuppeteerURL, withSourcePuppeteerURLIfNone, getSourcePuppeteerURLIfAvailable, isString3, isNumber3, fs2, UTILITY_WORLD_NAME, SOURCE_URL_REGEX, NETWORK_IDLE_TIME, unitToPixels;
  var init_util2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js"() {
      init_dirname();
      init_buffer2();
      init_rxjs();
      init_assert();
      init_Debug();
      init_Errors();
      init_PDFOptions();
      debugError = debug("puppeteer:error");
      DEFAULT_VIEWPORT = Object.freeze({ width: 800, height: 600 });
      SOURCE_URL = Symbol("Source URL for Puppeteer evaluation scripts");
      PuppeteerURL = class _PuppeteerURL {
        static INTERNAL_URL = "pptr:internal";
        static fromCallSite(functionName, site) {
          const url = new _PuppeteerURL();
          url.#functionName = functionName;
          url.#siteString = site.toString();
          return url;
        }
        static parse = (url) => {
          url = url.slice("pptr:".length);
          const [functionName = "", siteString = ""] = url.split(";");
          const puppeteerUrl = new _PuppeteerURL();
          puppeteerUrl.#functionName = functionName;
          puppeteerUrl.#siteString = decodeURIComponent(siteString);
          return puppeteerUrl;
        };
        static isPuppeteerURL = (url) => {
          return url.startsWith("pptr:");
        };
        #functionName;
        #siteString;
        get functionName() {
          return this.#functionName;
        }
        get siteString() {
          return this.#siteString;
        }
        toString() {
          return `pptr:${[
            this.#functionName,
            encodeURIComponent(this.#siteString)
          ].join(";")}`;
        }
      };
      withSourcePuppeteerURLIfNone = (functionName, object) => {
        if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
          return object;
        }
        const original = Error.prepareStackTrace;
        Error.prepareStackTrace = (_4, stack) => {
          return stack[2];
        };
        const site = new Error().stack;
        Error.prepareStackTrace = original;
        return Object.assign(object, {
          [SOURCE_URL]: PuppeteerURL.fromCallSite(functionName, site)
        });
      };
      getSourcePuppeteerURLIfAvailable = (object) => {
        if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
          return object[SOURCE_URL];
        }
        return void 0;
      };
      isString3 = (obj) => {
        return typeof obj === "string" || obj instanceof String;
      };
      isNumber3 = (obj) => {
        return typeof obj === "number" || obj instanceof Number;
      };
      fs2 = null;
      UTILITY_WORLD_NAME = "__puppeteer_utility_world__";
      SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
      NETWORK_IDLE_TIME = 500;
      unitToPixels = {
        px: 1,
        in: 96,
        cm: 37.8,
        mm: 3.78
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/third_party/mitt/mitt.js
  function mitt_default(n8) {
    return { all: n8 = n8 || /* @__PURE__ */ new Map(), on: function(t8, e9) {
      var i7 = n8.get(t8);
      i7 ? i7.push(e9) : n8.set(t8, [e9]);
    }, off: function(t8, e9) {
      var i7 = n8.get(t8);
      i7 && (e9 ? i7.splice(i7.indexOf(e9) >>> 0, 1) : n8.set(t8, []));
    }, emit: function(t8, e9) {
      var i7 = n8.get(t8);
      i7 && i7.slice().map(function(n22) {
        n22(e9);
      }), (i7 = n8.get("*")) && i7.slice().map(function(n22) {
        n22(t8, e9);
      });
    } };
  }
  var init_mitt = __esm({
    "node_modules/puppeteer-core/lib/esm/third_party/mitt/mitt.js"() {
      init_dirname();
      init_buffer2();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js
  var disposeSymbol, asyncDisposeSymbol, DisposableStack, AsyncDisposableStack;
  var init_disposable = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js"() {
      init_dirname();
      init_buffer2();
      Symbol.dispose ??= Symbol("dispose");
      Symbol.asyncDispose ??= Symbol("asyncDispose");
      disposeSymbol = Symbol.dispose;
      asyncDisposeSymbol = Symbol.asyncDispose;
      DisposableStack = class _DisposableStack {
        #disposed = false;
        #stack = [];
        /**
         * Returns a value indicating whether this stack has been disposed.
         */
        get disposed() {
          return this.#disposed;
        }
        /**
         * Disposes each resource in the stack in the reverse order that they were added.
         */
        dispose() {
          if (this.#disposed) {
            return;
          }
          this.#disposed = true;
          for (const resource of this.#stack.reverse()) {
            resource[disposeSymbol]();
          }
        }
        /**
         * Adds a disposable resource to the stack, returning the resource.
         *
         * @param value - The resource to add. `null` and `undefined` will not be added,
         * but will be returned.
         * @returns The provided `value`.
         */
        use(value) {
          if (value) {
            this.#stack.push(value);
          }
          return value;
        }
        /**
         * Adds a value and associated disposal callback as a resource to the stack.
         *
         * @param value - The value to add.
         * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
         * method. Will be invoked with `value` as the first parameter.
         * @returns The provided `value`.
         */
        adopt(value, onDispose) {
          this.#stack.push({
            [disposeSymbol]() {
              onDispose(value);
            }
          });
          return value;
        }
        /**
         * Adds a callback to be invoked when the stack is disposed.
         */
        defer(onDispose) {
          this.#stack.push({
            [disposeSymbol]() {
              onDispose();
            }
          });
        }
        /**
         * Move all resources out of this stack and into a new `DisposableStack`, and
         * marks this stack as disposed.
         *
         * @example
         *
         * ```ts
         * class C {
         *   #res1: Disposable;
         *   #res2: Disposable;
         *   #disposables: DisposableStack;
         *   constructor() {
         *     // stack will be disposed when exiting constructor for any reason
         *     using stack = new DisposableStack();
         *
         *     // get first resource
         *     this.#res1 = stack.use(getResource1());
         *
         *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
         *     this.#res2 = stack.use(getResource2());
         *
         *     // all operations succeeded, move resources out of `stack` so that
         *     // they aren't disposed when constructor exits
         *     this.#disposables = stack.move();
         *   }
         *
         *   [disposeSymbol]() {
         *     this.#disposables.dispose();
         *   }
         * }
         * ```
         */
        move() {
          if (this.#disposed) {
            throw new ReferenceError("a disposed stack can not use anything new");
          }
          const stack = new _DisposableStack();
          stack.#stack = this.#stack;
          this.#disposed = true;
          return stack;
        }
        [disposeSymbol] = this.dispose;
        [Symbol.toStringTag] = "DisposableStack";
      };
      AsyncDisposableStack = class _AsyncDisposableStack {
        #disposed = false;
        #stack = [];
        /**
         * Returns a value indicating whether this stack has been disposed.
         */
        get disposed() {
          return this.#disposed;
        }
        /**
         * Disposes each resource in the stack in the reverse order that they were added.
         */
        async dispose() {
          if (this.#disposed) {
            return;
          }
          this.#disposed = true;
          for (const resource of this.#stack.reverse()) {
            await resource[asyncDisposeSymbol]();
          }
        }
        /**
         * Adds a disposable resource to the stack, returning the resource.
         *
         * @param value - The resource to add. `null` and `undefined` will not be added,
         * but will be returned.
         * @returns The provided `value`.
         */
        use(value) {
          if (value) {
            this.#stack.push(value);
          }
          return value;
        }
        /**
         * Adds a value and associated disposal callback as a resource to the stack.
         *
         * @param value - The value to add.
         * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
         * method. Will be invoked with `value` as the first parameter.
         * @returns The provided `value`.
         */
        adopt(value, onDispose) {
          this.#stack.push({
            [asyncDisposeSymbol]() {
              return onDispose(value);
            }
          });
          return value;
        }
        /**
         * Adds a callback to be invoked when the stack is disposed.
         */
        defer(onDispose) {
          this.#stack.push({
            [asyncDisposeSymbol]() {
              return onDispose();
            }
          });
        }
        /**
         * Move all resources out of this stack and into a new `DisposableStack`, and
         * marks this stack as disposed.
         *
         * @example
         *
         * ```ts
         * class C {
         *   #res1: Disposable;
         *   #res2: Disposable;
         *   #disposables: DisposableStack;
         *   constructor() {
         *     // stack will be disposed when exiting constructor for any reason
         *     using stack = new DisposableStack();
         *
         *     // get first resource
         *     this.#res1 = stack.use(getResource1());
         *
         *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
         *     this.#res2 = stack.use(getResource2());
         *
         *     // all operations succeeded, move resources out of `stack` so that
         *     // they aren't disposed when constructor exits
         *     this.#disposables = stack.move();
         *   }
         *
         *   [disposeSymbol]() {
         *     this.#disposables.dispose();
         *   }
         * }
         * ```
         */
        move() {
          if (this.#disposed) {
            throw new ReferenceError("a disposed stack can not use anything new");
          }
          const stack = new _AsyncDisposableStack();
          stack.#stack = this.#stack;
          this.#disposed = true;
          return stack;
        }
        [asyncDisposeSymbol] = this.dispose;
        [Symbol.toStringTag] = "AsyncDisposableStack";
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js
  var EventEmitter2, EventSubscription;
  var init_EventEmitter = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js"() {
      init_dirname();
      init_buffer2();
      init_mitt();
      init_disposable();
      EventEmitter2 = class {
        #emitter;
        #handlers = /* @__PURE__ */ new Map();
        /**
         * If you pass an emitter, the returned emitter will wrap the passed emitter.
         *
         * @internal
         */
        constructor(emitter = mitt_default(/* @__PURE__ */ new Map())) {
          this.#emitter = emitter;
        }
        /**
         * Bind an event listener to fire when an event occurs.
         * @param type - the event type you'd like to listen to. Can be a string or symbol.
         * @param handler - the function to be called when the event occurs.
         * @returns `this` to enable you to chain method calls.
         */
        on(type, handler) {
          const handlers = this.#handlers.get(type);
          if (handlers === void 0) {
            this.#handlers.set(type, [handler]);
          } else {
            handlers.push(handler);
          }
          this.#emitter.on(type, handler);
          return this;
        }
        /**
         * Remove an event listener from firing.
         * @param type - the event type you'd like to stop listening to.
         * @param handler - the function that should be removed.
         * @returns `this` to enable you to chain method calls.
         */
        off(type, handler) {
          const handlers = this.#handlers.get(type) ?? [];
          if (handler === void 0) {
            for (const handler2 of handlers) {
              this.#emitter.off(type, handler2);
            }
            this.#handlers.delete(type);
            return this;
          }
          const index = handlers.lastIndexOf(handler);
          if (index > -1) {
            this.#emitter.off(type, ...handlers.splice(index, 1));
          }
          return this;
        }
        /**
         * Emit an event and call any associated listeners.
         *
         * @param type - the event you'd like to emit
         * @param eventData - any data you'd like to emit with the event
         * @returns `true` if there are any listeners, `false` if there are not.
         */
        emit(type, event) {
          this.#emitter.emit(type, event);
          return this.listenerCount(type) > 0;
        }
        /**
         * Like `on` but the listener will only be fired once and then it will be removed.
         * @param type - the event you'd like to listen to
         * @param handler - the handler function to run when the event occurs
         * @returns `this` to enable you to chain method calls.
         */
        once(type, handler) {
          const onceHandler = (eventData) => {
            handler(eventData);
            this.off(type, onceHandler);
          };
          return this.on(type, onceHandler);
        }
        /**
         * Gets the number of listeners for a given event.
         *
         * @param type - the event to get the listener count for
         * @returns the number of listeners bound to the given event
         */
        listenerCount(type) {
          return this.#handlers.get(type)?.length || 0;
        }
        /**
         * Removes all listeners. If given an event argument, it will remove only
         * listeners for that event.
         *
         * @param type - the event to remove listeners for.
         * @returns `this` to enable you to chain method calls.
         */
        removeAllListeners(type) {
          if (type !== void 0) {
            return this.off(type);
          }
          this[disposeSymbol]();
          return this;
        }
        /**
         * @internal
         */
        [disposeSymbol]() {
          for (const [type, handlers] of this.#handlers) {
            for (const handler of handlers) {
              this.#emitter.off(type, handler);
            }
          }
          this.#handlers.clear();
        }
      };
      EventSubscription = class {
        #target;
        #type;
        #handler;
        constructor(target, type, handler) {
          this.#target = target;
          this.#type = type;
          this.#handler = handler;
          this.#target.on(this.#type, this.#handler);
        }
        [disposeSymbol]() {
          this.#target.off(this.#type, this.#handler);
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/CDPSession.js
  var CDPSessionEvent, CDPSession;
  var init_CDPSession = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/CDPSession.js"() {
      init_dirname();
      init_buffer2();
      init_EventEmitter();
      (function(CDPSessionEvent2) {
        CDPSessionEvent2.Disconnected = Symbol("CDPSession.Disconnected");
        CDPSessionEvent2.Swapped = Symbol("CDPSession.Swapped");
        CDPSessionEvent2.Ready = Symbol("CDPSession.Ready");
        CDPSessionEvent2.SessionAttached = "sessionattached";
        CDPSessionEvent2.SessionDetached = "sessiondetached";
      })(CDPSessionEvent || (CDPSessionEvent = {}));
      CDPSession = class extends EventEmitter2 {
        /**
         * @internal
         */
        constructor() {
          super();
        }
        /**
         * Parent session in terms of CDP's auto-attach mechanism.
         *
         * @internal
         */
        parentSession() {
          return void 0;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/Deferred.js
  var Deferred;
  var init_Deferred = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/Deferred.js"() {
      init_dirname();
      init_buffer2();
      init_Errors();
      Deferred = class _Deferred {
        static create(opts) {
          return new _Deferred(opts);
        }
        static async race(awaitables) {
          const deferredWithTimeout = /* @__PURE__ */ new Set();
          try {
            const promises3 = awaitables.map((value) => {
              if (value instanceof _Deferred) {
                if (value.#timeoutId) {
                  deferredWithTimeout.add(value);
                }
                return value.valueOrThrow();
              }
              return value;
            });
            return await Promise.race(promises3);
          } finally {
            for (const deferred of deferredWithTimeout) {
              deferred.reject(new Error("Timeout cleared"));
            }
          }
        }
        #isResolved = false;
        #isRejected = false;
        #value;
        // SAFETY: This is ensured by #taskPromise.
        #resolve;
        #taskPromise = new Promise((resolve3) => {
          this.#resolve = resolve3;
        });
        #timeoutId;
        #timeoutError;
        constructor(opts) {
          if (opts && opts.timeout > 0) {
            this.#timeoutError = new TimeoutError(opts.message);
            this.#timeoutId = setTimeout(() => {
              this.reject(this.#timeoutError);
            }, opts.timeout);
          }
        }
        #finish(value) {
          clearTimeout(this.#timeoutId);
          this.#value = value;
          this.#resolve();
        }
        resolve(value) {
          if (this.#isRejected || this.#isResolved) {
            return;
          }
          this.#isResolved = true;
          this.#finish(value);
        }
        reject(error) {
          if (this.#isRejected || this.#isResolved) {
            return;
          }
          this.#isRejected = true;
          this.#finish(error);
        }
        resolved() {
          return this.#isResolved;
        }
        finished() {
          return this.#isResolved || this.#isRejected;
        }
        value() {
          return this.#value;
        }
        #promise;
        valueOrThrow() {
          if (!this.#promise) {
            this.#promise = (async () => {
              await this.#taskPromise;
              if (this.#isRejected) {
                throw this.#value;
              }
              return this.#value;
            })();
          }
          return this.#promise;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/Mutex.js
  var Mutex;
  var init_Mutex = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/Mutex.js"() {
      init_dirname();
      init_buffer2();
      init_Deferred();
      init_disposable();
      Mutex = class _Mutex {
        static Guard = class Guard {
          #mutex;
          constructor(mutex) {
            this.#mutex = mutex;
          }
          [disposeSymbol]() {
            return this.#mutex.release();
          }
        };
        #locked = false;
        #acquirers = [];
        // This is FIFO.
        async acquire() {
          if (!this.#locked) {
            this.#locked = true;
            return new _Mutex.Guard(this);
          }
          const deferred = Deferred.create();
          this.#acquirers.push(deferred.resolve.bind(deferred));
          await deferred.valueOrThrow();
          return new _Mutex.Guard(this);
        }
        release() {
          const resolve3 = this.#acquirers.shift();
          if (!resolve3) {
            this.#locked = false;
            return;
          }
          resolve3();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js
  function moveable(Class, _4) {
    let hasDispose = false;
    if (Class.prototype[disposeSymbol]) {
      const dispose = Class.prototype[disposeSymbol];
      Class.prototype[disposeSymbol] = function() {
        if (instances.has(this)) {
          instances.delete(this);
          return;
        }
        return dispose.call(this);
      };
      hasDispose = true;
    }
    if (Class.prototype[asyncDisposeSymbol]) {
      const asyncDispose = Class.prototype[asyncDisposeSymbol];
      Class.prototype[asyncDisposeSymbol] = function() {
        if (instances.has(this)) {
          instances.delete(this);
          return;
        }
        return asyncDispose.call(this);
      };
      hasDispose = true;
    }
    if (hasDispose) {
      Class.prototype.move = function() {
        instances.add(this);
        return this;
      };
    }
    return Class;
  }
  function throwIfDisposed(message = (value) => {
    return `Attempted to use disposed ${value.constructor.name}.`;
  }) {
    return (target, _4) => {
      return function(...args) {
        if (this.disposed) {
          throw new Error(message(this));
        }
        return target.call(this, ...args);
      };
    };
  }
  function invokeAtMostOnceForArguments(target, _4) {
    const cache = /* @__PURE__ */ new WeakMap();
    let cacheDepth = -1;
    return function(...args) {
      if (cacheDepth === -1) {
        cacheDepth = args.length;
      }
      if (cacheDepth !== args.length) {
        throw new Error("Memoized method was called with the wrong number of arguments");
      }
      let freshArguments = false;
      let cacheIterator = cache;
      for (const arg of args) {
        if (cacheIterator.has(arg)) {
          cacheIterator = cacheIterator.get(arg);
        } else {
          freshArguments = true;
          cacheIterator.set(arg, /* @__PURE__ */ new WeakMap());
          cacheIterator = cacheIterator.get(arg);
        }
      }
      if (!freshArguments) {
        return;
      }
      return target.call(this, ...args);
    };
  }
  function guarded(getKey = function() {
    return this;
  }) {
    return (target, _4) => {
      const mutexes = /* @__PURE__ */ new WeakMap();
      return async function(...args) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const key = getKey.call(this);
          let mutex = mutexes.get(key);
          if (!mutex) {
            mutex = new Mutex();
            mutexes.set(key, mutex);
          }
          const _5 = __addDisposableResource(env_1, await mutex.acquire(), true);
          return await target.call(this, ...args);
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          const result_1 = __disposeResources(env_1);
          if (result_1)
            await result_1;
        }
      };
    };
  }
  var __addDisposableResource, __disposeResources, instances;
  var init_decorators = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js"() {
      init_dirname();
      init_buffer2();
      init_disposable();
      init_Mutex();
      __addDisposableResource = function(env, value, async2) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async2) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env.stack.push({ value, dispose, async: async2 });
        } else if (async2) {
          env.stack.push({ async: true });
        }
        return value;
      };
      __disposeResources = /* @__PURE__ */ function(SuppressedError2) {
        return function(env) {
          function fail2(e9) {
            env.error = env.hasError ? new SuppressedError2(e9, env.error, "An error was suppressed during disposal.") : e9;
            env.hasError = true;
          }
          function next() {
            while (env.stack.length) {
              var rec = env.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e9) {
                    fail2(e9);
                    return next();
                  });
              } catch (e9) {
                fail2(e9);
              }
            }
            if (env.hasError)
              throw env.error;
          }
          return next();
        };
      }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e9 = new Error(message);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      });
      instances = /* @__PURE__ */ new WeakSet();
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/child_process.js
  function unimplemented2() {
    throw new Error("Node.js child_process is not supported by JSPM core in the browser");
  }
  var init_child_process = __esm({
    "node_modules/@jspm/core/nodelibs/browser/child_process.js"() {
      init_dirname();
      init_buffer2();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/node/ScreenRecorder.js
  var ScreenRecorder_exports = {};
  __export(ScreenRecorder_exports, {
    ScreenRecorder: () => ScreenRecorder
  });
  var import_debug, __runInitializers, __esDecorate, __setFunctionName, CRF_VALUE, DEFAULT_FPS, debugFfmpeg, ScreenRecorder;
  var init_ScreenRecorder = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/node/ScreenRecorder.js"() {
      init_dirname();
      init_buffer2();
      init_child_process();
      init_stream();
      import_debug = __toESM(require_browser(), 1);
      init_rxjs();
      init_CDPSession();
      init_util2();
      init_decorators();
      init_disposable();
      __runInitializers = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i7 = 0; i7 < initializers.length; i7++) {
          value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f7) {
          if (f7 !== void 0 && typeof f7 !== "function")
            throw new TypeError("Function expected");
          return f7;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _4, done = false;
        for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
          var context2 = {};
          for (var p7 in contextIn)
            context2[p7] = p7 === "access" ? {} : contextIn[p7];
          for (var p7 in contextIn.access)
            context2.access[p7] = contextIn.access[p7];
          context2.addInitializer = function(f7) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f7 || null));
          };
          var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_4 = accept(result.get))
              descriptor.get = _4;
            if (_4 = accept(result.set))
              descriptor.set = _4;
            if (_4 = accept(result.init))
              initializers.unshift(_4);
          } else if (_4 = accept(result)) {
            if (kind === "field")
              initializers.unshift(_4);
            else
              descriptor[key] = _4;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __setFunctionName = function(f7, name2, prefix) {
        if (typeof name2 === "symbol")
          name2 = name2.description ? "[".concat(name2.description, "]") : "";
        return Object.defineProperty(f7, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
      };
      CRF_VALUE = 30;
      DEFAULT_FPS = 30;
      debugFfmpeg = (0, import_debug.default)("puppeteer:ffmpeg");
      ScreenRecorder = (() => {
        let _classSuper = PassThrough;
        let _instanceExtraInitializers = [];
        let _private_writeFrame_decorators;
        let _private_writeFrame_descriptor;
        let _stop_decorators;
        return class ScreenRecorder extends _classSuper {
          static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, _private_writeFrame_descriptor = { value: __setFunctionName(async function(buffer2) {
              const error = await new Promise((resolve3) => {
                this.#process.stdin.write(buffer2, resolve3);
              });
              if (error) {
                console.log(`ffmpeg failed to write: ${error.message}.`);
              }
            }, "#writeFrame") }, _private_writeFrame_decorators, { kind: "method", name: "#writeFrame", static: false, private: true, access: { has: (obj) => #writeFrame in obj, get: (obj) => obj.#writeFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _stop_decorators, { kind: "method", name: "stop", static: false, private: false, access: { has: (obj) => "stop" in obj, get: (obj) => obj.stop }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata)
              Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
          }
          #page = (__runInitializers(this, _instanceExtraInitializers), void 0);
          #process;
          #controller = new AbortController();
          #lastFrame;
          /**
           * @internal
           */
          constructor(page, width, height, { speed, scale, crop, format: format5, path: path2 } = {}) {
            super({ allowHalfOpen: false });
            path2 ??= "ffmpeg";
            const { error } = unimplemented2(path2);
            if (error) {
              throw error;
            }
            this.#process = unimplemented2(
              path2,
              // See https://trac.ffmpeg.org/wiki/Encode/VP9 for more information on flags.
              [
                ["-loglevel", "error"],
                // Reduces general buffering.
                ["-avioflags", "direct"],
                // Reduces initial buffering while analyzing input fps and other stats.
                [
                  "-fpsprobesize",
                  "0",
                  "-probesize",
                  "32",
                  "-analyzeduration",
                  "0",
                  "-fflags",
                  "nobuffer"
                ],
                // Forces input to be read from standard input, and forces png input
                // image format.
                ["-f", "image2pipe", "-c:v", "png", "-i", "pipe:0"],
                // Overwrite output and no audio.
                ["-y", "-an"],
                // This drastically reduces stalling when cpu is overbooked. By default
                // VP9 tries to use all available threads?
                ["-threads", "1"],
                // Specifies the frame rate we are giving ffmpeg.
                ["-framerate", `${DEFAULT_FPS}`],
                // Specifies the encoding and format we are using.
                this.#getFormatArgs(format5 ?? "webm"),
                // Disable bitrate.
                ["-b:v", "0"],
                // Filters to ensure the images are piped correctly.
                [
                  "-vf",
                  `${speed ? `setpts=${1 / speed}*PTS,` : ""}crop='min(${width},iw):min(${height},ih):0:0',pad=${width}:${height}:0:0${crop ? `,crop=${crop.width}:${crop.height}:${crop.x}:${crop.y}` : ""}${scale ? `,scale=iw*${scale}:-1` : ""}`
                ],
                "pipe:1"
              ].flat(),
              { stdio: ["pipe", "pipe", "pipe"] }
            );
            this.#process.stdout.pipe(this);
            this.#process.stderr.on("data", (data) => {
              debugFfmpeg(data.toString("utf8"));
            });
            this.#page = page;
            const { client } = this.#page.mainFrame();
            client.once(CDPSessionEvent.Disconnected, () => {
              void this.stop().catch(debugError);
            });
            this.#lastFrame = lastValueFrom(fromEmitterEvent(client, "Page.screencastFrame").pipe(tap((event) => {
              void client.send("Page.screencastFrameAck", {
                sessionId: event.sessionId
              });
            }), filter((event) => {
              return event.metadata.timestamp !== void 0;
            }), map((event) => {
              return {
                buffer: Buffer2.from(event.data, "base64"),
                timestamp: event.metadata.timestamp
              };
            }), bufferCount(2, 1), concatMap(([{ timestamp: previousTimestamp, buffer: buffer2 }, { timestamp }]) => {
              return from(Array(Math.round(DEFAULT_FPS * Math.max(timestamp - previousTimestamp, 0))).fill(buffer2));
            }), map((buffer2) => {
              void this.#writeFrame(buffer2);
              return [buffer2, performance.now()];
            }), takeUntil(fromEvent(this.#controller.signal, "abort"))), { defaultValue: [Buffer2.from([]), performance.now()] });
          }
          #getFormatArgs(format5) {
            switch (format5) {
              case "webm":
                return [
                  // Sets the codec to use.
                  ["-c:v", "vp9"],
                  // Sets the format
                  ["-f", "webm"],
                  // Sets the quality. Lower the better.
                  ["-crf", `${CRF_VALUE}`],
                  // Sets the quality and how efficient the compression will be.
                  ["-deadline", "realtime", "-cpu-used", "8"]
                ].flat();
              case "gif":
                return [
                  // Sets the frame rate and uses a custom palette generated from the
                  // input.
                  [
                    "-vf",
                    "fps=5,split[s0][s1];[s0]palettegen=stats_mode=diff[p];[s1][p]paletteuse"
                  ],
                  // Sets the format
                  ["-f", "gif"]
                ].flat();
            }
          }
          get #writeFrame() {
            return _private_writeFrame_descriptor.value;
          }
          /**
           * Stops the recorder.
           *
           * @public
           */
          async stop() {
            if (this.#controller.signal.aborted) {
              return;
            }
            await this.#page._stopScreencast().catch(debugError);
            this.#controller.abort();
            const [buffer2, timestamp] = await this.#lastFrame;
            await Promise.all(Array(Math.max(1, Math.round(DEFAULT_FPS * (performance.now() - timestamp) / 1e3))).fill(buffer2).map(this.#writeFrame.bind(this)));
            this.#process.stdin.end();
            await new Promise((resolve3) => {
              this.#process.once("close", resolve3);
            });
          }
          /**
           * @internal
           */
          async [(_private_writeFrame_decorators = [guarded()], _stop_decorators = [guarded()], asyncDisposeSymbol)]() {
            await this.stop();
          }
        };
      })();
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js
  var empty_exports = {};
  __export(empty_exports, {
    default: () => empty_default
  });
  var empty_default;
  var init_empty = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js"() {
      init_dirname();
      init_buffer2();
      empty_default = {};
    }
  });

  // src/shared/utils/function/client.ts
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserWebSocketTransport.js
  init_dirname();
  init_buffer2();
  var BrowserWebSocketTransport = class _BrowserWebSocketTransport {
    static create(url) {
      return new Promise((resolve3, reject) => {
        const ws = new WebSocket(url);
        ws.addEventListener("open", () => {
          return resolve3(new _BrowserWebSocketTransport(ws));
        });
        ws.addEventListener("error", reject);
      });
    }
    #ws;
    onmessage;
    onclose;
    constructor(ws) {
      this.#ws = ws;
      this.#ws.addEventListener("message", (event) => {
        if (this.onmessage) {
          this.onmessage.call(null, event.data);
        }
      });
      this.#ws.addEventListener("close", () => {
        if (this.onclose) {
          this.onclose.call(null);
        }
      });
      this.#ws.addEventListener("error", () => {
      });
    }
    send(message) {
      this.#ws.send(message);
    }
    close() {
      this.#ws.close();
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/BrowserConnector.js
  init_dirname();
  init_buffer2();
  init_util2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Browser.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Browser.js
  init_dirname();
  init_buffer2();
  init_rxjs();
  init_EventEmitter();
  init_util2();
  init_disposable();
  var WEB_PERMISSION_TO_PROTOCOL_PERMISSION = /* @__PURE__ */ new Map([
    ["geolocation", "geolocation"],
    ["midi", "midi"],
    ["notifications", "notifications"],
    // TODO: push isn't a valid type?
    // ['push', 'push'],
    ["camera", "videoCapture"],
    ["microphone", "audioCapture"],
    ["background-sync", "backgroundSync"],
    ["ambient-light-sensor", "sensors"],
    ["accelerometer", "sensors"],
    ["gyroscope", "sensors"],
    ["magnetometer", "sensors"],
    ["accessibility-events", "accessibilityEvents"],
    ["clipboard-read", "clipboardReadWrite"],
    ["clipboard-write", "clipboardReadWrite"],
    ["clipboard-sanitized-write", "clipboardSanitizedWrite"],
    ["payment-handler", "paymentHandler"],
    ["persistent-storage", "durableStorage"],
    ["idle-detection", "idleDetection"],
    // chrome-specific permissions we have.
    ["midi-sysex", "midiSysex"]
  ]);
  var Browser = class extends EventEmitter2 {
    /**
     * @internal
     */
    constructor() {
      super();
    }
    /**
     * Waits until a {@link Target | target} matching the given `predicate`
     * appears and returns it.
     *
     * This will look all open {@link BrowserContext | browser contexts}.
     *
     * @example Finding a target for a page opened via `window.open`:
     *
     * ```ts
     * await page.evaluate(() => window.open('https://www.example.com/'));
     * const newWindowTarget = await browser.waitForTarget(
     *   target => target.url() === 'https://www.example.com/'
     * );
     * ```
     */
    async waitForTarget(predicate, options = {}) {
      const { timeout: ms = 3e4 } = options;
      return await firstValueFrom(merge(fromEmitterEvent(
        this,
        "targetcreated"
        /* BrowserEvent.TargetCreated */
      ), fromEmitterEvent(
        this,
        "targetchanged"
        /* BrowserEvent.TargetChanged */
      ), from(this.targets())).pipe(filterAsync(predicate), raceWith(timeout(ms))));
    }
    /**
     * Gets a list of all open {@link Page | pages} inside this {@link Browser}.
     *
     * If there ar multiple {@link BrowserContext | browser contexts}, this
     * returns all {@link Page | pages} in all
     * {@link BrowserContext | browser contexts}.
     *
     * @remarks Non-visible {@link Page | pages}, such as `"background_page"`,
     * will not be listed here. You can find them using {@link Target.page}.
     */
    async pages() {
      const contextPages = await Promise.all(this.browserContexts().map((context2) => {
        return context2.pages();
      }));
      return contextPages.reduce((acc, x4) => {
        return acc.concat(x4);
      }, []);
    }
    /**
     * Whether Puppeteer is connected to this {@link Browser | browser}.
     *
     * @deprecated Use {@link Browser | Browser.connected}.
     */
    isConnected() {
      return this.connected;
    }
    /** @internal */
    [disposeSymbol]() {
      return void this.close().catch(debugError);
    }
    /** @internal */
    [asyncDisposeSymbol]() {
      return this.close();
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Browser.js
  init_CDPSession();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/BrowserContext.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js
  init_dirname();
  init_buffer2();
  init_rxjs();
  init_EventEmitter();
  init_util2();
  init_disposable();
  var BrowserContext = class extends EventEmitter2 {
    /**
     * @internal
     */
    constructor() {
      super();
    }
    /**
     * Waits until a {@link Target | target} matching the given `predicate`
     * appears and returns it.
     *
     * This will look all open {@link BrowserContext | browser contexts}.
     *
     * @example Finding a target for a page opened via `window.open`:
     *
     * ```ts
     * await page.evaluate(() => window.open('https://www.example.com/'));
     * const newWindowTarget = await browserContext.waitForTarget(
     *   target => target.url() === 'https://www.example.com/'
     * );
     * ```
     */
    async waitForTarget(predicate, options = {}) {
      const { timeout: ms = 3e4 } = options;
      return await firstValueFrom(merge(fromEmitterEvent(
        this,
        "targetcreated"
        /* BrowserContextEvent.TargetCreated */
      ), fromEmitterEvent(
        this,
        "targetchanged"
        /* BrowserContextEvent.TargetChanged */
      ), from(this.targets())).pipe(filterAsync(predicate), raceWith(timeout(ms))));
    }
    /**
     * Whether this {@link BrowserContext | browser context} is closed.
     */
    get closed() {
      return !this.browser().browserContexts().includes(this);
    }
    /**
     * Identifier for this {@link BrowserContext | browser context}.
     */
    get id() {
      return void 0;
    }
    /** @internal */
    [disposeSymbol]() {
      return void this.close().catch(debugError);
    }
    /** @internal */
    [asyncDisposeSymbol]() {
      return this.close();
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/BrowserContext.js
  init_assert();
  var CdpBrowserContext = class extends BrowserContext {
    #connection;
    #browser;
    #id;
    constructor(connection, browser, contextId) {
      super();
      this.#connection = connection;
      this.#browser = browser;
      this.#id = contextId;
    }
    get id() {
      return this.#id;
    }
    targets() {
      return this.#browser.targets().filter((target) => {
        return target.browserContext() === this;
      });
    }
    async pages() {
      const pages = await Promise.all(this.targets().filter((target) => {
        return target.type() === "page" || target.type() === "other" && this.#browser._getIsPageTargetCallback()?.(target);
      }).map((target) => {
        return target.page();
      }));
      return pages.filter((page) => {
        return !!page;
      });
    }
    isIncognito() {
      return !!this.#id;
    }
    async overridePermissions(origin, permissions) {
      const protocolPermissions = permissions.map((permission) => {
        const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
        if (!protocolPermission) {
          throw new Error("Unknown permission: " + permission);
        }
        return protocolPermission;
      });
      await this.#connection.send("Browser.grantPermissions", {
        origin,
        browserContextId: this.#id || void 0,
        permissions: protocolPermissions
      });
    }
    async clearPermissionOverrides() {
      await this.#connection.send("Browser.resetPermissions", {
        browserContextId: this.#id || void 0
      });
    }
    newPage() {
      return this.#browser._createPageInContext(this.#id);
    }
    browser() {
      return this.#browser;
    }
    async close() {
      assert(this.#id, "Non-incognito profiles cannot be closed!");
      await this.#browser._disposeContext(this.#id);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ChromeTargetManager.js
  init_dirname();
  init_buffer2();
  init_CDPSession();
  init_EventEmitter();
  init_util2();
  init_assert();
  init_Deferred();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Target.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Target.js
  init_dirname();
  init_buffer2();
  var TargetType;
  (function(TargetType2) {
    TargetType2["PAGE"] = "page";
    TargetType2["BACKGROUND_PAGE"] = "background_page";
    TargetType2["SERVICE_WORKER"] = "service_worker";
    TargetType2["SHARED_WORKER"] = "shared_worker";
    TargetType2["BROWSER"] = "browser";
    TargetType2["WEBVIEW"] = "webview";
    TargetType2["OTHER"] = "other";
    TargetType2["TAB"] = "tab";
  })(TargetType || (TargetType = {}));
  var Target = class {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
     */
    async worker() {
      return null;
    }
    /**
     * If the target is not of type `"page"`, `"webview"` or `"background_page"`,
     * returns `null`.
     */
    async page() {
      return null;
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Target.js
  init_util2();
  init_Deferred();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/CDPSession.js
  init_dirname();
  init_buffer2();
  init_CDPSession();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js
  init_dirname();
  init_buffer2();
  init_Deferred();

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js
  init_dirname();
  init_buffer2();
  function isErrorLike(obj) {
    return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
  }
  function rewriteError(error, message, originalMessage) {
    error.message = message;
    error.originalMessage = originalMessage ?? error.originalMessage;
    return error;
  }
  function createProtocolErrorMessage(object) {
    let message = object.error.message;
    if (object.error && typeof object.error === "object" && "data" in object.error) {
      message += ` ${object.error.data}`;
    }
    return message;
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js
  init_Errors();
  init_util2();
  var CallbackRegistry = class {
    #callbacks = /* @__PURE__ */ new Map();
    #idGenerator = createIncrementalIdGenerator();
    create(label, timeout2, request) {
      const callback = new Callback(this.#idGenerator(), label, timeout2);
      this.#callbacks.set(callback.id, callback);
      try {
        request(callback.id);
      } catch (error) {
        callback.promise.catch(debugError).finally(() => {
          this.#callbacks.delete(callback.id);
        });
        callback.reject(error);
        throw error;
      }
      return callback.promise.finally(() => {
        this.#callbacks.delete(callback.id);
      });
    }
    reject(id, message, originalMessage) {
      const callback = this.#callbacks.get(id);
      if (!callback) {
        return;
      }
      this._reject(callback, message, originalMessage);
    }
    _reject(callback, errorMessage, originalMessage) {
      let error;
      let message;
      if (errorMessage instanceof ProtocolError) {
        error = errorMessage;
        error.cause = callback.error;
        message = errorMessage.message;
      } else {
        error = callback.error;
        message = errorMessage;
      }
      callback.reject(rewriteError(error, `Protocol error (${callback.label}): ${message}`, originalMessage));
    }
    resolve(id, value) {
      const callback = this.#callbacks.get(id);
      if (!callback) {
        return;
      }
      callback.resolve(value);
    }
    clear() {
      for (const callback of this.#callbacks.values()) {
        this._reject(callback, new TargetCloseError("Target closed"));
      }
      this.#callbacks.clear();
    }
    /**
     * @internal
     */
    getPendingProtocolErrors() {
      const result = [];
      for (const callback of this.#callbacks.values()) {
        result.push(new Error(`${callback.label} timed out. Trace: ${callback.error.stack}`));
      }
      return result;
    }
  };
  var Callback = class {
    #id;
    #error = new ProtocolError();
    #deferred = Deferred.create();
    #timer;
    #label;
    constructor(id, label, timeout2) {
      this.#id = id;
      this.#label = label;
      if (timeout2) {
        this.#timer = setTimeout(() => {
          this.#deferred.reject(rewriteError(this.#error, `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
        }, timeout2);
      }
    }
    resolve(value) {
      clearTimeout(this.#timer);
      this.#deferred.resolve(value);
    }
    reject(error) {
      clearTimeout(this.#timer);
      this.#deferred.reject(error);
    }
    get id() {
      return this.#id;
    }
    get promise() {
      return this.#deferred.valueOrThrow();
    }
    get error() {
      return this.#error;
    }
    get label() {
      return this.#label;
    }
  };
  function createIncrementalIdGenerator() {
    let id = 0;
    return () => {
      return ++id;
    };
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/CDPSession.js
  init_Errors();
  init_assert();
  var CdpCDPSession = class extends CDPSession {
    #sessionId;
    #targetType;
    #callbacks = new CallbackRegistry();
    #connection;
    #parentSessionId;
    #target;
    /**
     * @internal
     */
    constructor(connection, targetType, sessionId, parentSessionId) {
      super();
      this.#connection = connection;
      this.#targetType = targetType;
      this.#sessionId = sessionId;
      this.#parentSessionId = parentSessionId;
    }
    /**
     * Sets the {@link CdpTarget} associated with the session instance.
     *
     * @internal
     */
    _setTarget(target) {
      this.#target = target;
    }
    /**
     * Gets the {@link CdpTarget} associated with the session instance.
     *
     * @internal
     */
    _target() {
      assert(this.#target, "Target must exist");
      return this.#target;
    }
    connection() {
      return this.#connection;
    }
    parentSession() {
      if (!this.#parentSessionId) {
        return this;
      }
      const parent = this.#connection?.session(this.#parentSessionId);
      return parent ?? void 0;
    }
    send(method, params, options) {
      if (!this.#connection) {
        return Promise.reject(new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the ${this.#targetType} has been closed.`));
      }
      return this.#connection._rawSend(this.#callbacks, method, params, this.#sessionId, options);
    }
    /**
     * @internal
     */
    _onMessage(object) {
      if (object.id) {
        if (object.error) {
          this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);
        } else {
          this.#callbacks.resolve(object.id, object.result);
        }
      } else {
        assert(!object.id);
        this.emit(object.method, object.params);
      }
    }
    /**
     * Detaches the cdpSession from the target. Once detached, the cdpSession object
     * won't emit any events and can't be used to send messages.
     */
    async detach() {
      if (!this.#connection) {
        throw new Error(`Session already detached. Most likely the ${this.#targetType} has been closed.`);
      }
      await this.#connection.send("Target.detachFromTarget", {
        sessionId: this.#sessionId
      });
    }
    /**
     * @internal
     */
    _onClosed() {
      this.#callbacks.clear();
      this.#connection = void 0;
      this.emit(CDPSessionEvent.Disconnected, void 0);
    }
    /**
     * Returns the session's id.
     */
    id() {
      return this.#sessionId;
    }
    /**
     * @internal
     */
    getPendingProtocolErrors() {
      return this.#callbacks.getPendingProtocolErrors();
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
  init_dirname();
  init_buffer2();
  init_rxjs();
  init_CDPSession();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Page.js
  init_dirname();
  init_buffer2();
  init_rxjs();
  init_Errors();
  init_EventEmitter();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js
  init_dirname();
  init_buffer2();
  var DEFAULT_TIMEOUT = 3e4;
  var TimeoutSettings = class {
    #defaultTimeout;
    #defaultNavigationTimeout;
    constructor() {
      this.#defaultTimeout = null;
      this.#defaultNavigationTimeout = null;
    }
    setDefaultTimeout(timeout2) {
      this.#defaultTimeout = timeout2;
    }
    setDefaultNavigationTimeout(timeout2) {
      this.#defaultNavigationTimeout = timeout2;
    }
    navigationTimeout() {
      if (this.#defaultNavigationTimeout !== null) {
        return this.#defaultNavigationTimeout;
      }
      if (this.#defaultTimeout !== null) {
        return this.#defaultTimeout;
      }
      return DEFAULT_TIMEOUT;
    }
    timeout() {
      if (this.#defaultTimeout !== null) {
        return this.#defaultTimeout;
      }
      return DEFAULT_TIMEOUT;
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Page.js
  init_util2();
  init_decorators();
  init_disposable();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/locators/locators.js
  init_dirname();
  init_buffer2();
  init_rxjs();
  init_EventEmitter();
  init_util2();
  var __addDisposableResource2 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async2) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources2 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail2(e9) {
        env.error = env.hasError ? new SuppressedError2(e9, env.error, "An error was suppressed during disposal.") : e9;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  var LocatorEvent;
  (function(LocatorEvent2) {
    LocatorEvent2["Action"] = "action";
  })(LocatorEvent || (LocatorEvent = {}));
  var Locator = class extends EventEmitter2 {
    /**
     * Creates a race between multiple locators but ensures that only a single one
     * acts.
     *
     * @public
     */
    static race(locators) {
      return RaceLocator.create(locators);
    }
    /**
     * @internal
     */
    visibility = null;
    /**
     * @internal
     */
    _timeout = 3e4;
    #ensureElementIsInTheViewport = true;
    #waitForEnabled = true;
    #waitForStableBoundingBox = true;
    /**
     * @internal
     */
    operators = {
      conditions: (conditions, signal) => {
        return mergeMap((handle) => {
          return merge(...conditions.map((condition) => {
            return condition(handle, signal);
          })).pipe(defaultIfEmpty(handle));
        });
      },
      retryAndRaceWithSignalAndTimer: (signal, cause) => {
        const candidates = [];
        if (signal) {
          candidates.push(fromEvent(signal, "abort").pipe(map(() => {
            if (signal.reason instanceof Error) {
              signal.reason.cause = cause;
            }
            throw signal.reason;
          })));
        }
        candidates.push(timeout(this._timeout, cause));
        return pipe(retry({ delay: RETRY_DELAY }), raceWith(...candidates));
      }
    };
    // Determines when the locator will timeout for actions.
    get timeout() {
      return this._timeout;
    }
    setTimeout(timeout2) {
      const locator = this._clone();
      locator._timeout = timeout2;
      return locator;
    }
    setVisibility(visibility) {
      const locator = this._clone();
      locator.visibility = visibility;
      return locator;
    }
    setWaitForEnabled(value) {
      const locator = this._clone();
      locator.#waitForEnabled = value;
      return locator;
    }
    setEnsureElementIsInTheViewport(value) {
      const locator = this._clone();
      locator.#ensureElementIsInTheViewport = value;
      return locator;
    }
    setWaitForStableBoundingBox(value) {
      const locator = this._clone();
      locator.#waitForStableBoundingBox = value;
      return locator;
    }
    /**
     * @internal
     */
    copyOptions(locator) {
      this._timeout = locator._timeout;
      this.visibility = locator.visibility;
      this.#waitForEnabled = locator.#waitForEnabled;
      this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;
      this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;
      return this;
    }
    /**
     * If the element has a "disabled" property, wait for the element to be
     * enabled.
     */
    #waitForEnabledIfNeeded = (handle, signal) => {
      if (!this.#waitForEnabled) {
        return EMPTY;
      }
      return from(handle.frame.waitForFunction((element) => {
        if (!(element instanceof HTMLElement)) {
          return true;
        }
        const isNativeFormControl = [
          "BUTTON",
          "INPUT",
          "SELECT",
          "TEXTAREA",
          "OPTION",
          "OPTGROUP"
        ].includes(element.nodeName);
        return !isNativeFormControl || !element.hasAttribute("disabled");
      }, {
        timeout: this._timeout,
        signal
      }, handle)).pipe(ignoreElements());
    };
    /**
     * Compares the bounding box of the element for two consecutive animation
     * frames and waits till they are the same.
     */
    #waitForStableBoundingBoxIfNeeded = (handle) => {
      if (!this.#waitForStableBoundingBox) {
        return EMPTY;
      }
      return defer(() => {
        return from(handle.evaluate((element) => {
          return new Promise((resolve3) => {
            window.requestAnimationFrame(() => {
              const rect1 = element.getBoundingClientRect();
              window.requestAnimationFrame(() => {
                const rect2 = element.getBoundingClientRect();
                resolve3([
                  {
                    x: rect1.x,
                    y: rect1.y,
                    width: rect1.width,
                    height: rect1.height
                  },
                  {
                    x: rect2.x,
                    y: rect2.y,
                    width: rect2.width,
                    height: rect2.height
                  }
                ]);
              });
            });
          });
        }));
      }).pipe(first(([rect1, rect2]) => {
        return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
      }), retry({ delay: RETRY_DELAY }), ignoreElements());
    };
    /**
     * Checks if the element is in the viewport and auto-scrolls it if it is not.
     */
    #ensureElementIsInTheViewportIfNeeded = (handle) => {
      if (!this.#ensureElementIsInTheViewport) {
        return EMPTY;
      }
      return from(handle.isIntersectingViewport({ threshold: 0 })).pipe(filter((isIntersectingViewport) => {
        return !isIntersectingViewport;
      }), mergeMap(() => {
        return from(handle.scrollIntoView());
      }), mergeMap(() => {
        return defer(() => {
          return from(handle.isIntersectingViewport({ threshold: 0 }));
        }).pipe(first(identity), retry({ delay: RETRY_DELAY }), ignoreElements());
      }));
    };
    #click(options) {
      const signal = options?.signal;
      const cause = new Error("Locator.click");
      return this._wait(options).pipe(this.operators.conditions([
        this.#ensureElementIsInTheViewportIfNeeded,
        this.#waitForStableBoundingBoxIfNeeded,
        this.#waitForEnabledIfNeeded
      ], signal), tap(() => {
        return this.emit(LocatorEvent.Action, void 0);
      }), mergeMap((handle) => {
        return from(handle.click(options)).pipe(catchError((err) => {
          void handle.dispose().catch(debugError);
          throw err;
        }));
      }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
    }
    #fill(value, options) {
      const signal = options?.signal;
      const cause = new Error("Locator.fill");
      return this._wait(options).pipe(this.operators.conditions([
        this.#ensureElementIsInTheViewportIfNeeded,
        this.#waitForStableBoundingBoxIfNeeded,
        this.#waitForEnabledIfNeeded
      ], signal), tap(() => {
        return this.emit(LocatorEvent.Action, void 0);
      }), mergeMap((handle) => {
        return from(handle.evaluate((el) => {
          if (el instanceof HTMLSelectElement) {
            return "select";
          }
          if (el instanceof HTMLTextAreaElement) {
            return "typeable-input";
          }
          if (el instanceof HTMLInputElement) {
            if ((/* @__PURE__ */ new Set([
              "textarea",
              "text",
              "url",
              "tel",
              "search",
              "password",
              "number",
              "email"
            ])).has(el.type)) {
              return "typeable-input";
            } else {
              return "other-input";
            }
          }
          if (el.isContentEditable) {
            return "contenteditable";
          }
          return "unknown";
        })).pipe(mergeMap((inputType) => {
          switch (inputType) {
            case "select":
              return from(handle.select(value).then(noop));
            case "contenteditable":
            case "typeable-input":
              return from(handle.evaluate((input, newValue) => {
                const currentValue = input.isContentEditable ? input.innerText : input.value;
                if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {
                  if (input.isContentEditable) {
                    input.innerText = "";
                  } else {
                    input.value = "";
                  }
                  return newValue;
                }
                const originalValue = input.isContentEditable ? input.innerText : input.value;
                if (input.isContentEditable) {
                  input.innerText = "";
                  input.innerText = originalValue;
                } else {
                  input.value = "";
                  input.value = originalValue;
                }
                return newValue.substring(originalValue.length);
              }, value)).pipe(mergeMap((textToType) => {
                return from(handle.type(textToType));
              }));
            case "other-input":
              return from(handle.focus()).pipe(mergeMap(() => {
                return from(handle.evaluate((input, value2) => {
                  input.value = value2;
                  input.dispatchEvent(new Event("input", { bubbles: true }));
                  input.dispatchEvent(new Event("change", { bubbles: true }));
                }, value));
              }));
            case "unknown":
              throw new Error(`Element cannot be filled out.`);
          }
        })).pipe(catchError((err) => {
          void handle.dispose().catch(debugError);
          throw err;
        }));
      }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
    }
    #hover(options) {
      const signal = options?.signal;
      const cause = new Error("Locator.hover");
      return this._wait(options).pipe(this.operators.conditions([
        this.#ensureElementIsInTheViewportIfNeeded,
        this.#waitForStableBoundingBoxIfNeeded
      ], signal), tap(() => {
        return this.emit(LocatorEvent.Action, void 0);
      }), mergeMap((handle) => {
        return from(handle.hover()).pipe(catchError((err) => {
          void handle.dispose().catch(debugError);
          throw err;
        }));
      }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
    }
    #scroll(options) {
      const signal = options?.signal;
      const cause = new Error("Locator.scroll");
      return this._wait(options).pipe(this.operators.conditions([
        this.#ensureElementIsInTheViewportIfNeeded,
        this.#waitForStableBoundingBoxIfNeeded
      ], signal), tap(() => {
        return this.emit(LocatorEvent.Action, void 0);
      }), mergeMap((handle) => {
        return from(handle.evaluate((el, scrollTop, scrollLeft) => {
          if (scrollTop !== void 0) {
            el.scrollTop = scrollTop;
          }
          if (scrollLeft !== void 0) {
            el.scrollLeft = scrollLeft;
          }
        }, options?.scrollTop, options?.scrollLeft)).pipe(catchError((err) => {
          void handle.dispose().catch(debugError);
          throw err;
        }));
      }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
    }
    /**
     * Clones the locator.
     */
    clone() {
      return this._clone();
    }
    /**
     * Waits for the locator to get a handle from the page.
     *
     * @public
     */
    async waitHandle(options) {
      const cause = new Error("Locator.waitHandle");
      return await firstValueFrom(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options?.signal, cause)));
    }
    /**
     * Waits for the locator to get the serialized value from the page.
     *
     * Note this requires the value to be JSON-serializable.
     *
     * @public
     */
    async wait(options) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource2(env_1, await this.waitHandle(options), false);
        return await handle.jsonValue();
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources2(env_1);
      }
    }
    /**
     * Maps the locator using the provided mapper.
     *
     * @public
     */
    map(mapper) {
      return new MappedLocator(this._clone(), (handle) => {
        return handle.evaluateHandle(mapper);
      });
    }
    /**
     * Creates an expectation that is evaluated against located values.
     *
     * If the expectations do not match, then the locator will retry.
     *
     * @public
     */
    filter(predicate) {
      return new FilteredLocator(this._clone(), async (handle, signal) => {
        await handle.frame.waitForFunction(predicate, { signal, timeout: this._timeout }, handle);
        return true;
      });
    }
    /**
     * Creates an expectation that is evaluated against located handles.
     *
     * If the expectations do not match, then the locator will retry.
     *
     * @internal
     */
    filterHandle(predicate) {
      return new FilteredLocator(this._clone(), predicate);
    }
    /**
     * Maps the locator using the provided mapper.
     *
     * @internal
     */
    mapHandle(mapper) {
      return new MappedLocator(this._clone(), mapper);
    }
    click(options) {
      return firstValueFrom(this.#click(options));
    }
    /**
     * Fills out the input identified by the locator using the provided value. The
     * type of the input is determined at runtime and the appropriate fill-out
     * method is chosen based on the type. contenteditable, selector, inputs are
     * supported.
     */
    fill(value, options) {
      return firstValueFrom(this.#fill(value, options));
    }
    hover(options) {
      return firstValueFrom(this.#hover(options));
    }
    scroll(options) {
      return firstValueFrom(this.#scroll(options));
    }
  };
  var FunctionLocator = class _FunctionLocator extends Locator {
    static create(pageOrFrame, func) {
      return new _FunctionLocator(pageOrFrame, func).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
    }
    #pageOrFrame;
    #func;
    constructor(pageOrFrame, func) {
      super();
      this.#pageOrFrame = pageOrFrame;
      this.#func = func;
    }
    _clone() {
      return new _FunctionLocator(this.#pageOrFrame, this.#func);
    }
    _wait(options) {
      const signal = options?.signal;
      return defer(() => {
        return from(this.#pageOrFrame.waitForFunction(this.#func, {
          timeout: this.timeout,
          signal
        }));
      }).pipe(throwIfEmpty());
    }
  };
  var DelegatedLocator = class extends Locator {
    #delegate;
    constructor(delegate) {
      super();
      this.#delegate = delegate;
      this.copyOptions(this.#delegate);
    }
    get delegate() {
      return this.#delegate;
    }
    setTimeout(timeout2) {
      const locator = super.setTimeout(timeout2);
      locator.#delegate = this.#delegate.setTimeout(timeout2);
      return locator;
    }
    setVisibility(visibility) {
      const locator = super.setVisibility(visibility);
      locator.#delegate = locator.#delegate.setVisibility(visibility);
      return locator;
    }
    setWaitForEnabled(value) {
      const locator = super.setWaitForEnabled(value);
      locator.#delegate = this.#delegate.setWaitForEnabled(value);
      return locator;
    }
    setEnsureElementIsInTheViewport(value) {
      const locator = super.setEnsureElementIsInTheViewport(value);
      locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value);
      return locator;
    }
    setWaitForStableBoundingBox(value) {
      const locator = super.setWaitForStableBoundingBox(value);
      locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value);
      return locator;
    }
  };
  var FilteredLocator = class _FilteredLocator extends DelegatedLocator {
    #predicate;
    constructor(base, predicate) {
      super(base);
      this.#predicate = predicate;
    }
    _clone() {
      return new _FilteredLocator(this.delegate.clone(), this.#predicate).copyOptions(this);
    }
    _wait(options) {
      return this.delegate._wait(options).pipe(mergeMap((handle) => {
        return from(Promise.resolve(this.#predicate(handle, options?.signal))).pipe(filter((value) => {
          return value;
        }), map(() => {
          return handle;
        }));
      }), throwIfEmpty());
    }
  };
  var MappedLocator = class _MappedLocator extends DelegatedLocator {
    #mapper;
    constructor(base, mapper) {
      super(base);
      this.#mapper = mapper;
    }
    _clone() {
      return new _MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(this);
    }
    _wait(options) {
      return this.delegate._wait(options).pipe(mergeMap((handle) => {
        return from(Promise.resolve(this.#mapper(handle, options?.signal)));
      }));
    }
  };
  var NodeLocator = class _NodeLocator extends Locator {
    static create(pageOrFrame, selector) {
      return new _NodeLocator(pageOrFrame, selector).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
    }
    #pageOrFrame;
    #selector;
    constructor(pageOrFrame, selector) {
      super();
      this.#pageOrFrame = pageOrFrame;
      this.#selector = selector;
    }
    /**
     * Waits for the element to become visible or hidden. visibility === 'visible'
     * means that the element has a computed style, the visibility property other
     * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===
     * 'hidden' means the opposite of that.
     */
    #waitForVisibilityIfNeeded = (handle) => {
      if (!this.visibility) {
        return EMPTY;
      }
      return (() => {
        switch (this.visibility) {
          case "hidden":
            return defer(() => {
              return from(handle.isHidden());
            });
          case "visible":
            return defer(() => {
              return from(handle.isVisible());
            });
        }
      })().pipe(first(identity), retry({ delay: RETRY_DELAY }), ignoreElements());
    };
    _clone() {
      return new _NodeLocator(this.#pageOrFrame, this.#selector).copyOptions(this);
    }
    _wait(options) {
      const signal = options?.signal;
      return defer(() => {
        return from(this.#pageOrFrame.waitForSelector(this.#selector, {
          visible: false,
          timeout: this._timeout,
          signal
        }));
      }).pipe(filter((value) => {
        return value !== null;
      }), throwIfEmpty(), this.operators.conditions([this.#waitForVisibilityIfNeeded], signal));
    }
  };
  function checkLocatorArray(locators) {
    for (const locator of locators) {
      if (!(locator instanceof Locator)) {
        throw new Error("Unknown locator for race candidate");
      }
    }
    return locators;
  }
  var RaceLocator = class _RaceLocator extends Locator {
    static create(locators) {
      const array = checkLocatorArray(locators);
      return new _RaceLocator(array);
    }
    #locators;
    constructor(locators) {
      super();
      this.#locators = locators;
    }
    _clone() {
      return new _RaceLocator(this.#locators.map((locator) => {
        return locator.clone();
      })).copyOptions(this);
    }
    _wait(options) {
      return race(...this.#locators.map((locator) => {
        return locator._wait(options);
      }));
    }
  };
  var RETRY_DELAY = 100;

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Page.js
  var __runInitializers2 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i7 = 0; i7 < initializers.length; i7++) {
      value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f7) {
      if (f7 !== void 0 && typeof f7 !== "function")
        throw new TypeError("Function expected");
      return f7;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _4, done = false;
    for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
      var context2 = {};
      for (var p7 in contextIn)
        context2[p7] = p7 === "access" ? {} : contextIn[p7];
      for (var p7 in contextIn.access)
        context2.access[p7] = contextIn.access[p7];
      context2.addInitializer = function(f7) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f7 || null));
      };
      var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_4 = accept(result.get))
          descriptor.get = _4;
        if (_4 = accept(result.set))
          descriptor.set = _4;
        if (_4 = accept(result.init))
          initializers.unshift(_4);
      } else if (_4 = accept(result)) {
        if (kind === "field")
          initializers.unshift(_4);
        else
          descriptor[key] = _4;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource3 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async2) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources3 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail2(e9) {
        env.error = env.hasError ? new SuppressedError2(e9, env.error, "An error was suppressed during disposal.") : e9;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  function setDefaultScreenshotOptions(options) {
    options.optimizeForSpeed ??= false;
    options.type ??= "png";
    options.fromSurface ??= true;
    options.fullPage ??= false;
    options.omitBackground ??= false;
    options.encoding ??= "binary";
    options.captureBeyondViewport ??= true;
  }
  var Page = (() => {
    let _classSuper = EventEmitter2;
    let _instanceExtraInitializers = [];
    let _screenshot_decorators;
    return class Page extends _classSuper {
      static {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
        __esDecorate2(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
        if (_metadata)
          Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      }
      /**
       * @internal
       */
      _isDragging = (__runInitializers2(this, _instanceExtraInitializers), false);
      /**
       * @internal
       */
      _timeoutSettings = new TimeoutSettings();
      #requestHandlers = /* @__PURE__ */ new WeakMap();
      #inflight$ = new ReplaySubject(1);
      /**
       * @internal
       */
      constructor() {
        super();
        fromEmitterEvent(
          this,
          "request"
          /* PageEvent.Request */
        ).pipe(mergeMap((originalRequest) => {
          return concat(of(1), merge(fromEmitterEvent(
            this,
            "requestfailed"
            /* PageEvent.RequestFailed */
          ), fromEmitterEvent(
            this,
            "requestfinished"
            /* PageEvent.RequestFinished */
          ), fromEmitterEvent(
            this,
            "response"
            /* PageEvent.Response */
          ).pipe(map((response) => {
            return response.request();
          }))).pipe(filter((request) => {
            return request.id === originalRequest.id;
          }), take(1), map(() => {
            return -1;
          })));
        }), mergeScan((acc, addend) => {
          return of(acc + addend);
        }, 0), takeUntil(fromEmitterEvent(
          this,
          "close"
          /* PageEvent.Close */
        )), startWith(0)).subscribe(this.#inflight$);
      }
      /**
       * Listen to page events.
       *
       * @remarks
       * This method exists to define event typings and handle proper wireup of
       * cooperative request interception. Actual event listening and dispatching is
       * delegated to {@link EventEmitter}.
       *
       * @internal
       */
      on(type, handler) {
        if (type !== "request") {
          return super.on(type, handler);
        }
        let wrapper = this.#requestHandlers.get(handler);
        if (wrapper === void 0) {
          wrapper = (event) => {
            event.enqueueInterceptAction(() => {
              return handler(event);
            });
          };
          this.#requestHandlers.set(handler, wrapper);
        }
        return super.on(type, wrapper);
      }
      /**
       * @internal
       */
      off(type, handler) {
        if (type === "request") {
          handler = this.#requestHandlers.get(handler) || handler;
        }
        return super.off(type, handler);
      }
      locator(selectorOrFunc) {
        if (typeof selectorOrFunc === "string") {
          return NodeLocator.create(this, selectorOrFunc);
        } else {
          return FunctionLocator.create(this, selectorOrFunc);
        }
      }
      /**
       * A shortcut for {@link Locator.race} that does not require static imports.
       *
       * @internal
       */
      locatorRace(locators) {
        return Locator.race(locators);
      }
      /**
       * Runs `document.querySelector` within the page. If no element matches the
       * selector, the return value resolves to `null`.
       *
       * @param selector - A `selector` to query page for
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
       * to query page for.
       */
      async $(selector) {
        return await this.mainFrame().$(selector);
      }
      /**
       * The method runs `document.querySelectorAll` within the page. If no elements
       * match the selector, the return value resolves to `[]`.
       *
       * @param selector - A `selector` to query page for
       *
       * @remarks
       *
       * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.
       */
      async $$(selector) {
        return await this.mainFrame().$$(selector);
      }
      /**
       * @remarks
       *
       * The only difference between {@link Page.evaluate | page.evaluate} and
       * `page.evaluateHandle` is that `evaluateHandle` will return the value
       * wrapped in an in-page object.
       *
       * If the function passed to `page.evaluateHandle` returns a Promise, the
       * function will wait for the promise to resolve and return its value.
       *
       * You can pass a string instead of a function (although functions are
       * recommended as they are easier to debug and use with TypeScript):
       *
       * @example
       *
       * ```ts
       * const aHandle = await page.evaluateHandle('document');
       * ```
       *
       * @example
       * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:
       *
       * ```ts
       * const aHandle = await page.evaluateHandle(() => document.body);
       * const resultHandle = await page.evaluateHandle(
       *   body => body.innerHTML,
       *   aHandle
       * );
       * console.log(await resultHandle.jsonValue());
       * await resultHandle.dispose();
       * ```
       *
       * Most of the time this function returns a {@link JSHandle},
       * but if `pageFunction` returns a reference to an element,
       * you instead get an {@link ElementHandle} back:
       *
       * @example
       *
       * ```ts
       * const button = await page.evaluateHandle(() =>
       *   document.querySelector('button')
       * );
       * // can call `click` because `button` is an `ElementHandle`
       * await button.click();
       * ```
       *
       * The TypeScript definitions assume that `evaluateHandle` returns
       * a `JSHandle`, but if you know it's going to return an
       * `ElementHandle`, pass it as the generic argument:
       *
       * ```ts
       * const button = await page.evaluateHandle<ElementHandle>(...);
       * ```
       *
       * @param pageFunction - a function that is run within the page
       * @param args - arguments to be passed to the pageFunction
       */
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.mainFrame().evaluateHandle(pageFunction, ...args);
      }
      /**
       * This method runs `document.querySelector` within the page and passes the
       * result as the first argument to the `pageFunction`.
       *
       * @remarks
       *
       * If no element is found matching `selector`, the method will throw an error.
       *
       * If `pageFunction` returns a promise `$eval` will wait for the promise to
       * resolve and then return its value.
       *
       * @example
       *
       * ```ts
       * const searchValue = await page.$eval('#search', el => el.value);
       * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
       * const html = await page.$eval('.main-container', el => el.outerHTML);
       * ```
       *
       * If you are using TypeScript, you may have to provide an explicit type to the
       * first argument of the `pageFunction`.
       * By default it is typed as `Element`, but you may need to provide a more
       * specific sub-type:
       *
       * @example
       *
       * ```ts
       * // if you don't provide HTMLInputElement here, TS will error
       * // as `value` is not on `Element`
       * const searchValue = await page.$eval(
       *   '#search',
       *   (el: HTMLInputElement) => el.value
       * );
       * ```
       *
       * The compiler should be able to infer the return type
       * from the `pageFunction` you provide. If it is unable to, you can use the generic
       * type to tell the compiler what return type you expect from `$eval`:
       *
       * @example
       *
       * ```ts
       * // The compiler can infer the return type in this case, but if it can't
       * // or if you want to be more explicit, provide it as the generic type.
       * const searchValue = await page.$eval<string>(
       *   '#search',
       *   (el: HTMLInputElement) => el.value
       * );
       * ```
       *
       * @param selector - the
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
       * to query for
       * @param pageFunction - the function to be evaluated in the page context.
       * Will be passed the result of `document.querySelector(selector)` as its
       * first argument.
       * @param args - any additional arguments to pass through to `pageFunction`.
       *
       * @returns The result of calling `pageFunction`. If it returns an element it
       * is wrapped in an {@link ElementHandle}, else the raw value itself is
       * returned.
       */
      async $eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
        return await this.mainFrame().$eval(selector, pageFunction, ...args);
      }
      /**
       * This method runs `Array.from(document.querySelectorAll(selector))` within
       * the page and passes the result as the first argument to the `pageFunction`.
       *
       * @remarks
       * If `pageFunction` returns a promise `$$eval` will wait for the promise to
       * resolve and then return its value.
       *
       * @example
       *
       * ```ts
       * // get the amount of divs on the page
       * const divCount = await page.$$eval('div', divs => divs.length);
       *
       * // get the text content of all the `.options` elements:
       * const options = await page.$$eval('div > span.options', options => {
       *   return options.map(option => option.textContent);
       * });
       * ```
       *
       * If you are using TypeScript, you may have to provide an explicit type to the
       * first argument of the `pageFunction`.
       * By default it is typed as `Element[]`, but you may need to provide a more
       * specific sub-type:
       *
       * @example
       *
       * ```ts
       * // if you don't provide HTMLInputElement here, TS will error
       * // as `value` is not on `Element`
       * await page.$$eval('input', (elements: HTMLInputElement[]) => {
       *   return elements.map(e => e.value);
       * });
       * ```
       *
       * The compiler should be able to infer the return type
       * from the `pageFunction` you provide. If it is unable to, you can use the generic
       * type to tell the compiler what return type you expect from `$$eval`:
       *
       * @example
       *
       * ```ts
       * // The compiler can infer the return type in this case, but if it can't
       * // or if you want to be more explicit, provide it as the generic type.
       * const allInputValues = await page.$$eval<string[]>(
       *   'input',
       *   (elements: HTMLInputElement[]) => elements.map(e => e.textContent)
       * );
       * ```
       *
       * @param selector - the
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
       * to query for
       * @param pageFunction - the function to be evaluated in the page context.
       * Will be passed the result of
       * `Array.from(document.querySelectorAll(selector))` as its first argument.
       * @param args - any additional arguments to pass through to `pageFunction`.
       *
       * @returns The result of calling `pageFunction`. If it returns an element it
       * is wrapped in an {@link ElementHandle}, else the raw value itself is
       * returned.
       */
      async $$eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
        return await this.mainFrame().$$eval(selector, pageFunction, ...args);
      }
      /**
       * Adds a `<script>` tag into the page with the desired URL or content.
       *
       * @remarks
       * Shortcut for
       * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.
       *
       * @param options - Options for the script.
       * @returns An {@link ElementHandle | element handle} to the injected
       * `<script>` element.
       */
      async addScriptTag(options) {
        return await this.mainFrame().addScriptTag(options);
      }
      async addStyleTag(options) {
        return await this.mainFrame().addStyleTag(options);
      }
      /**
       * The page's URL.
       *
       * @remarks
       *
       * Shortcut for {@link Frame.url | page.mainFrame().url()}.
       */
      url() {
        return this.mainFrame().url();
      }
      /**
       * The full HTML contents of the page, including the DOCTYPE.
       */
      async content() {
        return await this.mainFrame().content();
      }
      /**
       * Set the content of the page.
       *
       * @param html - HTML markup to assign to the page.
       * @param options - Parameters that has some properties.
       *
       * @remarks
       *
       * The parameter `options` might have the following options.
       *
       * - `timeout` : Maximum time in milliseconds for resources to load, defaults
       *   to 30 seconds, pass `0` to disable timeout. The default value can be
       *   changed by using the {@link Page.setDefaultNavigationTimeout} or
       *   {@link Page.setDefaultTimeout} methods.
       *
       * - `waitUntil`: When to consider setting markup succeeded, defaults to
       *   `load`. Given an array of event strings, setting content is considered
       *   to be successful after all events have been fired. Events can be
       *   either:<br/>
       * - `load` : consider setting content to be finished when the `load` event
       *   is fired.<br/>
       * - `domcontentloaded` : consider setting content to be finished when the
       *   `DOMContentLoaded` event is fired.<br/>
       * - `networkidle0` : consider setting content to be finished when there are
       *   no more than 0 network connections for at least `500` ms.<br/>
       * - `networkidle2` : consider setting content to be finished when there are
       *   no more than 2 network connections for at least `500` ms.
       */
      async setContent(html, options) {
        await this.mainFrame().setContent(html, options);
      }
      /**
       * Navigates the page to the given `url`.
       *
       * @remarks
       *
       * Navigation to `about:blank` or navigation to the same URL with a different
       * hash will succeed and return `null`.
       *
       * :::warning
       *
       * Headless mode doesn't support navigation to a PDF document. See the {@link
       * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream
       * issue}.
       *
       * :::
       *
       * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.
       *
       * @param url - URL to navigate page to. The URL should include scheme, e.g.
       * `https://`
       * @param options - Options to configure waiting behavior.
       * @returns A promise which resolves to the main resource response. In case of
       * multiple redirects, the navigation will resolve with the response of the
       * last redirect.
       * @throws If:
       *
       * - there's an SSL error (e.g. in case of self-signed certificates).
       * - target URL is invalid.
       * - the timeout is exceeded during navigation.
       * - the remote server does not respond or is unreachable.
       * - the main resource failed to load.
       *
       * This method will not throw an error when any valid HTTP status code is
       * returned by the remote server, including 404 "Not Found" and 500 "Internal
       * Server Error". The status code for such responses can be retrieved by
       * calling {@link HTTPResponse.status}.
       */
      async goto(url, options) {
        return await this.mainFrame().goto(url, options);
      }
      /**
       * Waits for the page to navigate to a new URL or to reload. It is useful when
       * you run code that will indirectly cause the page to navigate.
       *
       * @example
       *
       * ```ts
       * const [response] = await Promise.all([
       *   page.waitForNavigation(), // The promise resolves after navigation has finished
       *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation
       * ]);
       * ```
       *
       * @remarks
       *
       * Usage of the
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}
       * to change the URL is considered a navigation.
       *
       * @param options - Navigation parameters which might have the following
       * properties:
       * @returns A `Promise` which resolves to the main resource response.
       *
       * - In case of multiple redirects, the navigation will resolve with the
       *   response of the last redirect.
       * - In case of navigation to a different anchor or navigation due to History
       *   API usage, the navigation will resolve with `null`.
       */
      async waitForNavigation(options = {}) {
        return await this.mainFrame().waitForNavigation(options);
      }
      /**
       * @param urlOrPredicate - A URL or predicate to wait for
       * @param options - Optional waiting parameters
       * @returns Promise which resolves to the matched request
       * @example
       *
       * ```ts
       * const firstRequest = await page.waitForRequest(
       *   'https://example.com/resource'
       * );
       * const finalRequest = await page.waitForRequest(
       *   request => request.url() === 'https://example.com'
       * );
       * return finalRequest.response()?.ok();
       * ```
       *
       * @remarks
       * Optional Waiting Parameters have:
       *
       * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass
       *   `0` to disable the timeout. The default value can be changed by using the
       *   {@link Page.setDefaultTimeout} method.
       */
      waitForRequest(urlOrPredicate, options = {}) {
        const { timeout: ms = this._timeoutSettings.timeout() } = options;
        if (typeof urlOrPredicate === "string") {
          const url = urlOrPredicate;
          urlOrPredicate = (request) => {
            return request.url() === url;
          };
        }
        const observable$ = fromEmitterEvent(
          this,
          "request"
          /* PageEvent.Request */
        ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromEmitterEvent(
          this,
          "close"
          /* PageEvent.Close */
        ).pipe(map(() => {
          throw new TargetCloseError("Page closed!");
        }))));
        return firstValueFrom(observable$);
      }
      /**
       * @param urlOrPredicate - A URL or predicate to wait for.
       * @param options - Optional waiting parameters
       * @returns Promise which resolves to the matched response.
       * @example
       *
       * ```ts
       * const firstResponse = await page.waitForResponse(
       *   'https://example.com/resource'
       * );
       * const finalResponse = await page.waitForResponse(
       *   response =>
       *     response.url() === 'https://example.com' && response.status() === 200
       * );
       * const finalResponse = await page.waitForResponse(async response => {
       *   return (await response.text()).includes('<html>');
       * });
       * return finalResponse.ok();
       * ```
       *
       * @remarks
       * Optional Parameter have:
       *
       * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,
       *   pass `0` to disable the timeout. The default value can be changed by using
       *   the {@link Page.setDefaultTimeout} method.
       */
      waitForResponse(urlOrPredicate, options = {}) {
        const { timeout: ms = this._timeoutSettings.timeout() } = options;
        if (typeof urlOrPredicate === "string") {
          const url = urlOrPredicate;
          urlOrPredicate = (response) => {
            return response.url() === url;
          };
        }
        const observable$ = fromEmitterEvent(
          this,
          "response"
          /* PageEvent.Response */
        ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromEmitterEvent(
          this,
          "close"
          /* PageEvent.Close */
        ).pipe(map(() => {
          throw new TargetCloseError("Page closed!");
        }))));
        return firstValueFrom(observable$);
      }
      /**
       * Waits for the network to be idle.
       *
       * @param options - Options to configure waiting behavior.
       * @returns A promise which resolves once the network is idle.
       */
      waitForNetworkIdle(options = {}) {
        return firstValueFrom(this.waitForNetworkIdle$(options));
      }
      /**
       * @internal
       */
      waitForNetworkIdle$(options = {}) {
        const { timeout: ms = this._timeoutSettings.timeout(), idleTime = NETWORK_IDLE_TIME, concurrency = 0 } = options;
        return this.#inflight$.pipe(switchMap((inflight) => {
          if (inflight > concurrency) {
            return EMPTY;
          }
          return timer(idleTime);
        }), map(() => {
        }), raceWith(timeout(ms), fromEmitterEvent(
          this,
          "close"
          /* PageEvent.Close */
        ).pipe(map(() => {
          throw new TargetCloseError("Page closed!");
        }))));
      }
      /**
       * Waits for a frame matching the given conditions to appear.
       *
       * @example
       *
       * ```ts
       * const frame = await page.waitForFrame(async frame => {
       *   return frame.name() === 'Test';
       * });
       * ```
       */
      async waitForFrame(urlOrPredicate, options = {}) {
        const { timeout: ms = this.getDefaultTimeout() } = options;
        if (isString3(urlOrPredicate)) {
          urlOrPredicate = (frame) => {
            return urlOrPredicate === frame.url();
          };
        }
        return await firstValueFrom(merge(fromEmitterEvent(
          this,
          "frameattached"
          /* PageEvent.FrameAttached */
        ), fromEmitterEvent(
          this,
          "framenavigated"
          /* PageEvent.FrameNavigated */
        ), from(this.frames())).pipe(filterAsync(urlOrPredicate), first(), raceWith(timeout(ms), fromEmitterEvent(
          this,
          "close"
          /* PageEvent.Close */
        ).pipe(map(() => {
          throw new TargetCloseError("Page closed.");
        })))));
      }
      /**
       * Emulates a given device's metrics and user agent.
       *
       * To aid emulation, Puppeteer provides a list of known devices that can be
       * via {@link KnownDevices}.
       *
       * @remarks
       * This method is a shortcut for calling two methods:
       * {@link Page.setUserAgent} and {@link Page.setViewport}.
       *
       * This method will resize the page. A lot of websites don't expect phones to
       * change size, so you should emulate before navigating to the page.
       *
       * @example
       *
       * ```ts
       * import {KnownDevices} from 'puppeteer';
       * const iPhone = KnownDevices['iPhone 6'];
       *
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   await page.emulate(iPhone);
       *   await page.goto('https://www.google.com');
       *   // other actions...
       *   await browser.close();
       * })();
       * ```
       */
      async emulate(device) {
        await Promise.all([
          this.setUserAgent(device.userAgent),
          this.setViewport(device.viewport)
        ]);
      }
      /**
       * Evaluates a function in the page's context and returns the result.
       *
       * If the function passed to `page.evaluate` returns a Promise, the
       * function will wait for the promise to resolve and return its value.
       *
       * @example
       *
       * ```ts
       * const result = await frame.evaluate(() => {
       *   return Promise.resolve(8 * 7);
       * });
       * console.log(result); // prints "56"
       * ```
       *
       * You can pass a string instead of a function (although functions are
       * recommended as they are easier to debug and use with TypeScript):
       *
       * @example
       *
       * ```ts
       * const aHandle = await page.evaluate('1 + 2');
       * ```
       *
       * To get the best TypeScript experience, you should pass in as the
       * generic the type of `pageFunction`:
       *
       * ```ts
       * const aHandle = await page.evaluate(() => 2);
       * ```
       *
       * @example
       *
       * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed
       * as arguments to the `pageFunction`:
       *
       * ```ts
       * const bodyHandle = await page.$('body');
       * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
       * await bodyHandle.dispose();
       * ```
       *
       * @param pageFunction - a function that is run within the page
       * @param args - arguments to be passed to the pageFunction
       *
       * @returns the return value of `pageFunction`.
       */
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.mainFrame().evaluate(pageFunction, ...args);
      }
      /**
       * @internal
       */
      async _maybeWriteBufferToFile(path2, buffer2) {
        if (!path2) {
          return;
        }
        const fs3 = await importFSPromises();
        await fs3.writeFile(path2, buffer2);
      }
      /**
       * Captures a screencast of this {@link Page | page}.
       *
       * @example
       * Recording a {@link Page | page}:
       *
       * ```
       * import puppeteer from 'puppeteer';
       *
       * // Launch a browser
       * const browser = await puppeteer.launch();
       *
       * // Create a new page
       * const page = await browser.newPage();
       *
       * // Go to your site.
       * await page.goto("https://www.example.com");
       *
       * // Start recording.
       * const recorder = await page.screencast({path: 'recording.webm'});
       *
       * // Do something.
       *
       * // Stop recording.
       * await recorder.stop();
       *
       * browser.close();
       * ```
       *
       * @param options - Configures screencast behavior.
       *
       * @experimental
       *
       * @remarks
       *
       * All recordings will be {@link https://www.webmproject.org/ | WebM} format using
       * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.
       *
       * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.
       */
      async screencast(options = {}) {
        const [{ ScreenRecorder: ScreenRecorder2 }, [width, height, devicePixelRatio]] = await Promise.all([
          Promise.resolve().then(() => (init_ScreenRecorder(), ScreenRecorder_exports)),
          this.#getNativePixelDimensions()
        ]);
        let crop;
        if (options.crop) {
          const { x: x4, y: y6, width: cropWidth, height: cropHeight } = roundRectangle(normalizeRectangle(options.crop));
          if (x4 < 0 || y6 < 0) {
            throw new Error(`\`crop.x\` and \`crop.y\` must be greater than or equal to 0.`);
          }
          if (cropWidth <= 0 || cropHeight <= 0) {
            throw new Error(`\`crop.height\` and \`crop.width\` must be greater than or equal to 0.`);
          }
          const viewportWidth = width / devicePixelRatio;
          const viewportHeight = height / devicePixelRatio;
          if (x4 + cropWidth > viewportWidth) {
            throw new Error(`\`crop.width\` cannot be larger than the viewport width (${viewportWidth}).`);
          }
          if (y6 + cropHeight > viewportHeight) {
            throw new Error(`\`crop.height\` cannot be larger than the viewport height (${viewportHeight}).`);
          }
          crop = {
            x: x4 * devicePixelRatio,
            y: y6 * devicePixelRatio,
            width: cropWidth * devicePixelRatio,
            height: cropHeight * devicePixelRatio
          };
        }
        if (options.speed !== void 0 && options.speed <= 0) {
          throw new Error(`\`speed\` must be greater than 0.`);
        }
        if (options.scale !== void 0 && options.scale <= 0) {
          throw new Error(`\`scale\` must be greater than 0.`);
        }
        const recorder = new ScreenRecorder2(this, width, height, {
          ...options,
          path: options.ffmpegPath,
          crop
        });
        try {
          await this._startScreencast();
        } catch (error) {
          void recorder.stop();
          throw error;
        }
        if (options.path) {
          const { createWriteStream: createWriteStream2 } = await Promise.resolve().then(() => (init_empty(), empty_exports));
          const stream = createWriteStream2(options.path, "binary");
          recorder.pipe(stream);
        }
        return recorder;
      }
      #screencastSessionCount = 0;
      #startScreencastPromise;
      /**
       * @internal
       */
      async _startScreencast() {
        ++this.#screencastSessionCount;
        if (!this.#startScreencastPromise) {
          this.#startScreencastPromise = this.mainFrame().client.send("Page.startScreencast", { format: "png" }).then(() => {
            return new Promise((resolve3) => {
              return this.mainFrame().client.once("Page.screencastFrame", () => {
                return resolve3();
              });
            });
          });
        }
        await this.#startScreencastPromise;
      }
      /**
       * @internal
       */
      async _stopScreencast() {
        --this.#screencastSessionCount;
        if (!this.#startScreencastPromise) {
          return;
        }
        this.#startScreencastPromise = void 0;
        if (this.#screencastSessionCount === 0) {
          await this.mainFrame().client.send("Page.stopScreencast");
        }
      }
      /**
       * Gets the native, non-emulated dimensions of the viewport.
       */
      async #getNativePixelDimensions() {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const viewport = this.viewport();
          const stack = __addDisposableResource3(env_1, new DisposableStack(), false);
          if (viewport && viewport.deviceScaleFactor !== 0) {
            await this.setViewport({ ...viewport, deviceScaleFactor: 0 });
            stack.defer(() => {
              void this.setViewport(viewport).catch(debugError);
            });
          }
          return await this.mainFrame().isolatedRealm().evaluate(() => {
            return [
              window.visualViewport.width * window.devicePixelRatio,
              window.visualViewport.height * window.devicePixelRatio,
              window.devicePixelRatio
            ];
          });
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources3(env_1);
        }
      }
      async screenshot(userOptions = {}) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
          await this.bringToFront();
          const options = {
            ...userOptions,
            clip: userOptions.clip ? {
              ...userOptions.clip
            } : void 0
          };
          if (options.type === void 0 && options.path !== void 0) {
            const filePath = options.path;
            const extension = filePath.slice(filePath.lastIndexOf(".") + 1).toLowerCase();
            switch (extension) {
              case "png":
                options.type = "png";
                break;
              case "jpeg":
              case "jpg":
                options.type = "jpeg";
                break;
              case "webp":
                options.type = "webp";
                break;
            }
          }
          if (options.quality !== void 0) {
            if (options.quality < 0 && options.quality > 100) {
              throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);
            }
            if (options.type === void 0 || !["jpeg", "webp"].includes(options.type)) {
              throw new Error(`${options.type ?? "png"} screenshots do not support 'quality'.`);
            }
          }
          if (options.clip) {
            if (options.clip.width <= 0) {
              throw new Error("'width' in 'clip' must be positive.");
            }
            if (options.clip.height <= 0) {
              throw new Error("'height' in 'clip' must be positive.");
            }
          }
          setDefaultScreenshotOptions(options);
          const stack = __addDisposableResource3(env_2, new AsyncDisposableStack(), true);
          if (options.clip) {
            if (options.fullPage) {
              throw new Error("'clip' and 'fullPage' are mutually exclusive");
            }
            options.clip = roundRectangle(normalizeRectangle(options.clip));
          } else {
            if (options.fullPage) {
              if (!options.captureBeyondViewport) {
                const scrollDimensions = await this.mainFrame().isolatedRealm().evaluate(() => {
                  const element = document.documentElement;
                  return {
                    width: element.scrollWidth,
                    height: element.scrollHeight
                  };
                });
                const viewport = this.viewport();
                await this.setViewport({
                  ...viewport,
                  ...scrollDimensions
                });
                stack.defer(async () => {
                  if (viewport) {
                    await this.setViewport(viewport).catch(debugError);
                  } else {
                    await this.setViewport({
                      width: 0,
                      height: 0
                    }).catch(debugError);
                  }
                });
              }
            } else {
              options.captureBeyondViewport = false;
            }
          }
          const data = await this._screenshot(options);
          if (options.encoding === "base64") {
            return data;
          }
          const buffer2 = Buffer2.from(data, "base64");
          await this._maybeWriteBufferToFile(options.path, buffer2);
          return buffer2;
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          const result_1 = __disposeResources3(env_2);
          if (result_1)
            await result_1;
        }
      }
      /**
       * The page's title
       *
       * @remarks
       *
       * Shortcut for {@link Frame.title | page.mainFrame().title()}.
       */
      async title() {
        return await this.mainFrame().title();
      }
      /**
       * This method fetches an element with `selector`, scrolls it into view if
       * needed, and then uses {@link Page | Page.mouse} to click in the center of the
       * element. If there's no element matching `selector`, the method throws an
       * error.
       *
       * @remarks
       *
       * Bear in mind that if `click()` triggers a navigation event and
       * there's a separate `page.waitForNavigation()` promise to be resolved, you
       * may end up with a race condition that yields unexpected results. The
       * correct pattern for click and wait for navigation is the following:
       *
       * ```ts
       * const [response] = await Promise.all([
       *   page.waitForNavigation(waitOptions),
       *   page.click(selector, clickOptions),
       * ]);
       * ```
       *
       * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.
       * @param selector - A `selector` to search for element to click. If there are
       * multiple elements satisfying the `selector`, the first will be clicked
       * @param options - `Object`
       * @returns Promise which resolves when the element matching `selector` is
       * successfully clicked. The Promise will be rejected if there is no element
       * matching `selector`.
       */
      click(selector, options) {
        return this.mainFrame().click(selector, options);
      }
      /**
       * This method fetches an element with `selector` and focuses it. If there's no
       * element matching `selector`, the method throws an error.
       * @param selector - A
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }
       * of an element to focus. If there are multiple elements satisfying the
       * selector, the first will be focused.
       * @returns Promise which resolves when the element matching selector is
       * successfully focused. The promise will be rejected if there is no element
       * matching selector.
       *
       * @remarks
       *
       * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.
       */
      focus(selector) {
        return this.mainFrame().focus(selector);
      }
      /**
       * This method fetches an element with `selector`, scrolls it into view if
       * needed, and then uses {@link Page | Page.mouse}
       * to hover over the center of the element.
       * If there's no element matching `selector`, the method throws an error.
       * @param selector - A
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
       * to search for element to hover. If there are multiple elements satisfying
       * the selector, the first will be hovered.
       * @returns Promise which resolves when the element matching `selector` is
       * successfully hovered. Promise gets rejected if there's no element matching
       * `selector`.
       *
       * @remarks
       *
       * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.
       */
      hover(selector) {
        return this.mainFrame().hover(selector);
      }
      /**
       * Triggers a `change` and `input` event once all the provided options have been
       * selected. If there's no `<select>` element matching `selector`, the method
       * throws an error.
       *
       * @example
       *
       * ```ts
       * page.select('select#colors', 'blue'); // single selection
       * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections
       * ```
       *
       * @param selector - A
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
       * to query the page for
       * @param values - Values of options to select. If the `<select>` has the
       * `multiple` attribute, all values are considered, otherwise only the first one
       * is taken into account.
       * @returns
       *
       * @remarks
       *
       * Shortcut for {@link Frame.select | page.mainFrame().select()}
       */
      select(selector, ...values) {
        return this.mainFrame().select(selector, ...values);
      }
      /**
       * This method fetches an element with `selector`, scrolls it into view if
       * needed, and then uses {@link Page | Page.touchscreen}
       * to tap in the center of the element.
       * If there's no element matching `selector`, the method throws an error.
       * @param selector - A
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
       * to search for element to tap. If there are multiple elements satisfying the
       * selector, the first will be tapped.
       *
       * @remarks
       *
       * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.
       */
      tap(selector) {
        return this.mainFrame().tap(selector);
      }
      /**
       * Sends a `keydown`, `keypress/input`, and `keyup` event for each character
       * in the text.
       *
       * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.
       * @example
       *
       * ```ts
       * await page.type('#mytextarea', 'Hello');
       * // Types instantly
       * await page.type('#mytextarea', 'World', {delay: 100});
       * // Types slower, like a user
       * ```
       *
       * @param selector - A
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
       * of an element to type into. If there are multiple elements satisfying the
       * selector, the first will be used.
       * @param text - A text to type into a focused element.
       * @param options - have property `delay` which is the Time to wait between
       * key presses in milliseconds. Defaults to `0`.
       * @returns
       */
      type(selector, text, options) {
        return this.mainFrame().type(selector, text, options);
      }
      /**
       * Wait for the `selector` to appear in page. If at the moment of calling the
       * method the `selector` already exists, the method will return immediately. If
       * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the
       * function will throw.
       *
       * @example
       * This method works across navigations:
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   let currentURL;
       *   page
       *     .waitForSelector('img')
       *     .then(() => console.log('First URL with image: ' + currentURL));
       *   for (currentURL of [
       *     'https://example.com',
       *     'https://google.com',
       *     'https://bbc.com',
       *   ]) {
       *     await page.goto(currentURL);
       *   }
       *   await browser.close();
       * })();
       * ```
       *
       * @param selector - A
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
       * of an element to wait for
       * @param options - Optional waiting parameters
       * @returns Promise which resolves when element specified by selector string
       * is added to DOM. Resolves to `null` if waiting for hidden: `true` and
       * selector is not found in DOM.
       *
       * @remarks
       * The optional Parameter in Arguments `options` are:
       *
       * - `visible`: A boolean wait for element to be present in DOM and to be
       *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
       *   properties. Defaults to `false`.
       *
       * - `hidden`: Wait for element to not be found in the DOM or to be hidden,
       *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to
       *   `false`.
       *
       * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`
       *   (30 seconds). Pass `0` to disable timeout. The default value can be changed
       *   by using the {@link Page.setDefaultTimeout} method.
       */
      async waitForSelector(selector, options = {}) {
        return await this.mainFrame().waitForSelector(selector, options);
      }
      /**
       * Waits for the provided function, `pageFunction`, to return a truthy value when
       * evaluated in the page's context.
       *
       * @example
       * {@link Page.waitForFunction} can be used to observe a viewport size change:
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   const watchDog = page.waitForFunction('window.innerWidth < 100');
       *   await page.setViewport({width: 50, height: 50});
       *   await watchDog;
       *   await browser.close();
       * })();
       * ```
       *
       * @example
       * Arguments can be passed from Node.js to `pageFunction`:
       *
       * ```ts
       * const selector = '.foo';
       * await page.waitForFunction(
       *   selector => !!document.querySelector(selector),
       *   {},
       *   selector
       * );
       * ```
       *
       * @example
       * The provided `pageFunction` can be asynchronous:
       *
       * ```ts
       * const username = 'github-username';
       * await page.waitForFunction(
       *   async username => {
       *     const githubResponse = await fetch(
       *       `https://api.github.com/users/${username}`
       *     );
       *     const githubUser = await githubResponse.json();
       *     // show the avatar
       *     const img = document.createElement('img');
       *     img.src = githubUser.avatar_url;
       *     // wait 3 seconds
       *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));
       *     img.remove();
       *   },
       *   {},
       *   username
       * );
       * ```
       *
       * @param pageFunction - Function to be evaluated in browser context until it returns a
       * truthy value.
       * @param options - Options for configuring waiting behavior.
       */
      waitForFunction(pageFunction, options, ...args) {
        return this.mainFrame().waitForFunction(pageFunction, options, ...args);
      }
      /** @internal */
      [(_screenshot_decorators = [guarded(function() {
        return this.browser();
      })], disposeSymbol)]() {
        return void this.close().catch(debugError);
      }
      /** @internal */
      [asyncDisposeSymbol]() {
        return this.close();
      }
    };
  })();
  function normalizeRectangle(clip) {
    return {
      ...clip,
      ...clip.width < 0 ? {
        x: clip.x + clip.width,
        width: -clip.width
      } : {
        x: clip.x,
        width: clip.width
      },
      ...clip.height < 0 ? {
        y: clip.y + clip.height,
        height: -clip.height
      } : {
        y: clip.y,
        height: clip.height
      }
    };
  }
  function roundRectangle(clip) {
    const x4 = Math.round(clip.x);
    const y6 = Math.round(clip.y);
    const width = Math.round(clip.width + clip.x - x4);
    const height = Math.round(clip.height + clip.y - y6);
    return { ...clip, x: x4, y: y6, width, height };
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js
  init_dirname();
  init_buffer2();
  var ConsoleMessage = class {
    #type;
    #text;
    #args;
    #stackTraceLocations;
    /**
     * @public
     */
    constructor(type, text, args, stackTraceLocations) {
      this.#type = type;
      this.#text = text;
      this.#args = args;
      this.#stackTraceLocations = stackTraceLocations;
    }
    /**
     * The type of the console message.
     */
    type() {
      return this.#type;
    }
    /**
     * The text of the console message.
     */
    text() {
      return this.#text;
    }
    /**
     * An array of arguments passed to the console.
     */
    args() {
      return this.#args;
    }
    /**
     * The location of the console message.
     */
    location() {
      return this.#stackTraceLocations[0] ?? {};
    }
    /**
     * The array of locations on the stack of the console message.
     */
    stackTrace() {
      return this.#stackTraceLocations;
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
  init_Errors();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/FileChooser.js
  init_dirname();
  init_buffer2();
  init_assert();
  var FileChooser = class {
    #element;
    #multiple;
    #handled = false;
    /**
     * @internal
     */
    constructor(element, event) {
      this.#element = element;
      this.#multiple = event.mode !== "selectSingle";
    }
    /**
     * Whether file chooser allow for
     * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#attr-multiple | multiple}
     * file selection.
     */
    isMultiple() {
      return this.#multiple;
    }
    /**
     * Accept the file chooser request with the given file paths.
     *
     * @remarks This will not validate whether the file paths exists. Also, if a
     * path is relative, then it is resolved against the
     * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.
     * For locals script connecting to remote chrome environments, paths must be
     * absolute.
     */
    async accept(paths) {
      assert(!this.#handled, "Cannot accept FileChooser which is already handled!");
      this.#handled = true;
      await this.#element.uploadFile(...paths);
    }
    /**
     * Closes the file chooser without selecting any files.
     */
    async cancel() {
      assert(!this.#handled, "Cannot cancel FileChooser which is already handled!");
      this.#handled = true;
      await this.#element.evaluate((element) => {
        element.dispatchEvent(new Event("cancel", { bubbles: true }));
      });
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkManagerEvents.js
  init_dirname();
  init_buffer2();
  var NetworkManagerEvent;
  (function(NetworkManagerEvent2) {
    NetworkManagerEvent2.Request = Symbol("NetworkManager.Request");
    NetworkManagerEvent2.RequestServedFromCache = Symbol("NetworkManager.RequestServedFromCache");
    NetworkManagerEvent2.Response = Symbol("NetworkManager.Response");
    NetworkManagerEvent2.RequestFailed = Symbol("NetworkManager.RequestFailed");
    NetworkManagerEvent2.RequestFinished = Symbol("NetworkManager.RequestFinished");
  })(NetworkManagerEvent || (NetworkManagerEvent = {}));

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
  init_util2();
  init_assert();
  init_Deferred();
  init_disposable();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js
  init_dirname();
  init_buffer2();
  var Accessibility = class {
    #client;
    /**
     * @internal
     */
    constructor(client) {
      this.#client = client;
    }
    /**
     * @internal
     */
    updateClient(client) {
      this.#client = client;
    }
    /**
     * Captures the current state of the accessibility tree.
     * The returned object represents the root accessible node of the page.
     *
     * @remarks
     *
     * **NOTE** The Chrome accessibility tree contains nodes that go unused on
     * most platforms and by most screen readers. Puppeteer will discard them as
     * well for an easier to process tree, unless `interestingOnly` is set to
     * `false`.
     *
     * @example
     * An example of dumping the entire accessibility tree:
     *
     * ```ts
     * const snapshot = await page.accessibility.snapshot();
     * console.log(snapshot);
     * ```
     *
     * @example
     * An example of logging the focused node's name:
     *
     * ```ts
     * const snapshot = await page.accessibility.snapshot();
     * const node = findFocusedNode(snapshot);
     * console.log(node && node.name);
     *
     * function findFocusedNode(node) {
     *   if (node.focused) return node;
     *   for (const child of node.children || []) {
     *     const foundNode = findFocusedNode(child);
     *     return foundNode;
     *   }
     *   return null;
     * }
     * ```
     *
     * @returns An AXNode object representing the snapshot.
     */
    async snapshot(options = {}) {
      const { interestingOnly = true, root = null } = options;
      const { nodes } = await this.#client.send("Accessibility.getFullAXTree");
      let backendNodeId;
      if (root) {
        const { node } = await this.#client.send("DOM.describeNode", {
          objectId: root.id
        });
        backendNodeId = node.backendNodeId;
      }
      const defaultRoot = AXNode.createTree(nodes);
      let needle = defaultRoot;
      if (backendNodeId) {
        needle = defaultRoot.find((node) => {
          return node.payload.backendDOMNodeId === backendNodeId;
        });
        if (!needle) {
          return null;
        }
      }
      if (!interestingOnly) {
        return this.serializeTree(needle)[0] ?? null;
      }
      const interestingNodes = /* @__PURE__ */ new Set();
      this.collectInterestingNodes(interestingNodes, defaultRoot, false);
      if (!interestingNodes.has(needle)) {
        return null;
      }
      return this.serializeTree(needle, interestingNodes)[0] ?? null;
    }
    serializeTree(node, interestingNodes) {
      const children = [];
      for (const child of node.children) {
        children.push(...this.serializeTree(child, interestingNodes));
      }
      if (interestingNodes && !interestingNodes.has(node)) {
        return children;
      }
      const serializedNode = node.serialize();
      if (children.length) {
        serializedNode.children = children;
      }
      return [serializedNode];
    }
    collectInterestingNodes(collection, node, insideControl) {
      if (node.isInteresting(insideControl)) {
        collection.add(node);
      }
      if (node.isLeafNode()) {
        return;
      }
      insideControl = insideControl || node.isControl();
      for (const child of node.children) {
        this.collectInterestingNodes(collection, child, insideControl);
      }
    }
  };
  var AXNode = class _AXNode {
    payload;
    children = [];
    #richlyEditable = false;
    #editable = false;
    #focusable = false;
    #hidden = false;
    #name;
    #role;
    #ignored;
    #cachedHasFocusableChild;
    constructor(payload) {
      this.payload = payload;
      this.#name = this.payload.name ? this.payload.name.value : "";
      this.#role = this.payload.role ? this.payload.role.value : "Unknown";
      this.#ignored = this.payload.ignored;
      for (const property of this.payload.properties || []) {
        if (property.name === "editable") {
          this.#richlyEditable = property.value.value === "richtext";
          this.#editable = true;
        }
        if (property.name === "focusable") {
          this.#focusable = property.value.value;
        }
        if (property.name === "hidden") {
          this.#hidden = property.value.value;
        }
      }
    }
    #isPlainTextField() {
      if (this.#richlyEditable) {
        return false;
      }
      if (this.#editable) {
        return true;
      }
      return this.#role === "textbox" || this.#role === "searchbox";
    }
    #isTextOnlyObject() {
      const role = this.#role;
      return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
    }
    #hasFocusableChild() {
      if (this.#cachedHasFocusableChild === void 0) {
        this.#cachedHasFocusableChild = false;
        for (const child of this.children) {
          if (child.#focusable || child.#hasFocusableChild()) {
            this.#cachedHasFocusableChild = true;
            break;
          }
        }
      }
      return this.#cachedHasFocusableChild;
    }
    find(predicate) {
      if (predicate(this)) {
        return this;
      }
      for (const child of this.children) {
        const result = child.find(predicate);
        if (result) {
          return result;
        }
      }
      return null;
    }
    isLeafNode() {
      if (!this.children.length) {
        return true;
      }
      if (this.#isPlainTextField() || this.#isTextOnlyObject()) {
        return true;
      }
      switch (this.#role) {
        case "doc-cover":
        case "graphics-symbol":
        case "img":
        case "image":
        case "Meter":
        case "scrollbar":
        case "slider":
        case "separator":
        case "progressbar":
          return true;
        default:
          break;
      }
      if (this.#hasFocusableChild()) {
        return false;
      }
      if (this.#focusable && this.#name) {
        return true;
      }
      if (this.#role === "heading" && this.#name) {
        return true;
      }
      return false;
    }
    isControl() {
      switch (this.#role) {
        case "button":
        case "checkbox":
        case "ColorWell":
        case "combobox":
        case "DisclosureTriangle":
        case "listbox":
        case "menu":
        case "menubar":
        case "menuitem":
        case "menuitemcheckbox":
        case "menuitemradio":
        case "radio":
        case "scrollbar":
        case "searchbox":
        case "slider":
        case "spinbutton":
        case "switch":
        case "tab":
        case "textbox":
        case "tree":
        case "treeitem":
          return true;
        default:
          return false;
      }
    }
    isInteresting(insideControl) {
      const role = this.#role;
      if (role === "Ignored" || this.#hidden || this.#ignored) {
        return false;
      }
      if (this.#focusable || this.#richlyEditable) {
        return true;
      }
      if (this.isControl()) {
        return true;
      }
      if (insideControl) {
        return false;
      }
      return this.isLeafNode() && !!this.#name;
    }
    serialize() {
      const properties = /* @__PURE__ */ new Map();
      for (const property of this.payload.properties || []) {
        properties.set(property.name.toLowerCase(), property.value.value);
      }
      if (this.payload.name) {
        properties.set("name", this.payload.name.value);
      }
      if (this.payload.value) {
        properties.set("value", this.payload.value.value);
      }
      if (this.payload.description) {
        properties.set("description", this.payload.description.value);
      }
      const node = {
        role: this.#role
      };
      const userStringProperties = [
        "name",
        "value",
        "description",
        "keyshortcuts",
        "roledescription",
        "valuetext"
      ];
      const getUserStringPropertyValue = (key) => {
        return properties.get(key);
      };
      for (const userStringProperty of userStringProperties) {
        if (!properties.has(userStringProperty)) {
          continue;
        }
        node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
      }
      const booleanProperties = [
        "disabled",
        "expanded",
        "focused",
        "modal",
        "multiline",
        "multiselectable",
        "readonly",
        "required",
        "selected"
      ];
      const getBooleanPropertyValue = (key) => {
        return properties.get(key);
      };
      for (const booleanProperty of booleanProperties) {
        if (booleanProperty === "focused" && this.#role === "RootWebArea") {
          continue;
        }
        const value = getBooleanPropertyValue(booleanProperty);
        if (!value) {
          continue;
        }
        node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
      }
      const tristateProperties = ["checked", "pressed"];
      for (const tristateProperty of tristateProperties) {
        if (!properties.has(tristateProperty)) {
          continue;
        }
        const value = properties.get(tristateProperty);
        node[tristateProperty] = value === "mixed" ? "mixed" : value === "true" ? true : false;
      }
      const numericalProperties = [
        "level",
        "valuemax",
        "valuemin"
      ];
      const getNumericalPropertyValue = (key) => {
        return properties.get(key);
      };
      for (const numericalProperty of numericalProperties) {
        if (!properties.has(numericalProperty)) {
          continue;
        }
        node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
      }
      const tokenProperties = [
        "autocomplete",
        "haspopup",
        "invalid",
        "orientation"
      ];
      const getTokenPropertyValue = (key) => {
        return properties.get(key);
      };
      for (const tokenProperty of tokenProperties) {
        const value = getTokenPropertyValue(tokenProperty);
        if (!value || value === "false") {
          continue;
        }
        node[tokenProperty] = getTokenPropertyValue(tokenProperty);
      }
      return node;
    }
    static createTree(payloads) {
      const nodeById = /* @__PURE__ */ new Map();
      for (const payload of payloads) {
        nodeById.set(payload.nodeId, new _AXNode(payload));
      }
      for (const node of nodeById.values()) {
        for (const childId of node.payload.childIds || []) {
          const child = nodeById.get(childId);
          if (child) {
            node.children.push(child);
          }
        }
      }
      return nodeById.values().next().value;
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Binding.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/JSHandle.js
  init_dirname();
  init_buffer2();
  init_util2();
  init_decorators();
  init_disposable();
  var __runInitializers3 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i7 = 0; i7 < initializers.length; i7++) {
      value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate3 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f7) {
      if (f7 !== void 0 && typeof f7 !== "function")
        throw new TypeError("Function expected");
      return f7;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _4, done = false;
    for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
      var context2 = {};
      for (var p7 in contextIn)
        context2[p7] = p7 === "access" ? {} : contextIn[p7];
      for (var p7 in contextIn.access)
        context2.access[p7] = contextIn.access[p7];
      context2.addInitializer = function(f7) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f7 || null));
      };
      var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_4 = accept(result.get))
          descriptor.get = _4;
        if (_4 = accept(result.set))
          descriptor.set = _4;
        if (_4 = accept(result.init))
          initializers.unshift(_4);
      } else if (_4 = accept(result)) {
        if (kind === "field")
          initializers.unshift(_4);
        else
          descriptor[key] = _4;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource4 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async2) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources4 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail2(e9) {
        env.error = env.hasError ? new SuppressedError2(e9, env.error, "An error was suppressed during disposal.") : e9;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  var JSHandle = (() => {
    let _classDecorators = [moveable];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _instanceExtraInitializers = [];
    let _getProperty_decorators;
    let _getProperties_decorators;
    var JSHandle2 = class {
      static {
        _classThis = this;
      }
      static {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
        __esDecorate3(this, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate3(this, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate3(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
        JSHandle2 = _classThis = _classDescriptor.value;
        if (_metadata)
          Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        __runInitializers3(_classThis, _classExtraInitializers);
      }
      /**
       * @internal
       */
      constructor() {
        __runInitializers3(this, _instanceExtraInitializers);
      }
      /**
       * Evaluates the given function with the current handle as its first argument.
       */
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.realm.evaluate(pageFunction, this, ...args);
      }
      /**
       * Evaluates the given function with the current handle as its first argument.
       *
       */
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.realm.evaluateHandle(pageFunction, this, ...args);
      }
      /**
       * @internal
       */
      async getProperty(propertyName) {
        return await this.evaluateHandle((object, propertyName2) => {
          return object[propertyName2];
        }, propertyName);
      }
      /**
       * Gets a map of handles representing the properties of the current handle.
       *
       * @example
       *
       * ```ts
       * const listHandle = await page.evaluateHandle(() => document.body.children);
       * const properties = await listHandle.getProperties();
       * const children = [];
       * for (const property of properties.values()) {
       *   const element = property.asElement();
       *   if (element) {
       *     children.push(element);
       *   }
       * }
       * children; // holds elementHandles to all children of document.body
       * ```
       */
      async getProperties() {
        const propertyNames = await this.evaluate((object) => {
          const enumerableProperties = [];
          const descriptors = Object.getOwnPropertyDescriptors(object);
          for (const propertyName in descriptors) {
            if (descriptors[propertyName]?.enumerable) {
              enumerableProperties.push(propertyName);
            }
          }
          return enumerableProperties;
        });
        const map2 = /* @__PURE__ */ new Map();
        const results = await Promise.all(propertyNames.map((key) => {
          return this.getProperty(key);
        }));
        for (const [key, value] of Object.entries(propertyNames)) {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource4(env_1, results[key], false);
            if (handle) {
              map2.set(value, handle.move());
            }
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources4(env_1);
          }
        }
        return map2;
      }
      /** @internal */
      [(_getProperty_decorators = [throwIfDisposed()], _getProperties_decorators = [throwIfDisposed()], disposeSymbol)]() {
        return void this.dispose().catch(debugError);
      }
      /** @internal */
      [asyncDisposeSymbol]() {
        return this.dispose();
      }
    };
    return JSHandle2 = _classThis;
  })();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Binding.js
  init_util2();
  init_disposable();
  var __addDisposableResource5 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async2) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources5 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail2(e9) {
        env.error = env.hasError ? new SuppressedError2(e9, env.error, "An error was suppressed during disposal.") : e9;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  var Binding = class {
    #name;
    #fn;
    constructor(name2, fn) {
      this.#name = name2;
      this.#fn = fn;
    }
    get name() {
      return this.#name;
    }
    /**
     * @param context - Context to run the binding in; the context should have
     * the binding added to it beforehand.
     * @param id - ID of the call. This should come from the CDP
     * `onBindingCalled` response.
     * @param args - Plain arguments from CDP.
     */
    async run(context2, id, args, isTrivial) {
      const stack = new DisposableStack();
      try {
        if (!isTrivial) {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const handles = __addDisposableResource5(env_1, await context2.evaluateHandle((name2, seq) => {
              return globalThis[name2].args.get(seq);
            }, this.#name, id), false);
            const properties = await handles.getProperties();
            for (const [index, handle] of properties) {
              if (index in args) {
                switch (handle.remoteObject().subtype) {
                  case "node":
                    args[+index] = handle;
                    break;
                  default:
                    stack.use(handle);
                }
              } else {
                stack.use(handle);
              }
            }
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources5(env_1);
          }
        }
        await context2.evaluate((name2, seq, result) => {
          const callbacks = globalThis[name2].callbacks;
          callbacks.get(seq).resolve(result);
          callbacks.delete(seq);
        }, this.#name, id, await this.#fn(...args));
        for (const arg of args) {
          if (arg instanceof JSHandle) {
            stack.use(arg);
          }
        }
      } catch (error) {
        if (isErrorLike(error)) {
          await context2.evaluate((name2, seq, message, stack2) => {
            const error2 = new Error(message);
            error2.stack = stack2;
            const callbacks = globalThis[name2].callbacks;
            callbacks.get(seq).reject(error2);
            callbacks.delete(seq);
          }, this.#name, id, error.message, error.stack).catch(debugError);
        } else {
          await context2.evaluate((name2, seq, error2) => {
            const callbacks = globalThis[name2].callbacks;
            callbacks.get(seq).reject(error2);
            callbacks.delete(seq);
          }, this.#name, id, error).catch(debugError);
        }
      }
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Connection.js
  init_dirname();
  init_buffer2();
  init_CDPSession();
  init_Debug();
  init_Errors();
  init_EventEmitter();
  var debugProtocolSend = debug("puppeteer:protocol:SEND \u25BA");
  var debugProtocolReceive = debug("puppeteer:protocol:RECV \u25C0");
  var Connection = class extends EventEmitter2 {
    #url;
    #transport;
    #delay;
    #timeout;
    #sessions = /* @__PURE__ */ new Map();
    #closed = false;
    #manuallyAttached = /* @__PURE__ */ new Set();
    #callbacks = new CallbackRegistry();
    constructor(url, transport, delay = 0, timeout2) {
      super();
      this.#url = url;
      this.#delay = delay;
      this.#timeout = timeout2 ?? 18e4;
      this.#transport = transport;
      this.#transport.onmessage = this.onMessage.bind(this);
      this.#transport.onclose = this.#onClose.bind(this);
    }
    static fromSession(session) {
      return session.connection();
    }
    get timeout() {
      return this.#timeout;
    }
    /**
     * @internal
     */
    get _closed() {
      return this.#closed;
    }
    /**
     * @internal
     */
    get _sessions() {
      return this.#sessions;
    }
    /**
     * @param sessionId - The session id
     * @returns The current CDP session if it exists
     */
    session(sessionId) {
      return this.#sessions.get(sessionId) || null;
    }
    url() {
      return this.#url;
    }
    send(method, params, options) {
      return this._rawSend(this.#callbacks, method, params, void 0, options);
    }
    /**
     * @internal
     */
    _rawSend(callbacks, method, params, sessionId, options) {
      return callbacks.create(method, options?.timeout ?? this.#timeout, (id) => {
        const stringifiedMessage = JSON.stringify({
          method,
          params,
          id,
          sessionId
        });
        debugProtocolSend(stringifiedMessage);
        this.#transport.send(stringifiedMessage);
      });
    }
    /**
     * @internal
     */
    async closeBrowser() {
      await this.send("Browser.close");
    }
    /**
     * @internal
     */
    async onMessage(message) {
      if (this.#delay) {
        await new Promise((r9) => {
          return setTimeout(r9, this.#delay);
        });
      }
      debugProtocolReceive(message);
      const object = JSON.parse(message);
      if (object.method === "Target.attachedToTarget") {
        const sessionId = object.params.sessionId;
        const session = new CdpCDPSession(this, object.params.targetInfo.type, sessionId, object.sessionId);
        this.#sessions.set(sessionId, session);
        this.emit(CDPSessionEvent.SessionAttached, session);
        const parentSession = this.#sessions.get(object.sessionId);
        if (parentSession) {
          parentSession.emit(CDPSessionEvent.SessionAttached, session);
        }
      } else if (object.method === "Target.detachedFromTarget") {
        const session = this.#sessions.get(object.params.sessionId);
        if (session) {
          session._onClosed();
          this.#sessions.delete(object.params.sessionId);
          this.emit(CDPSessionEvent.SessionDetached, session);
          const parentSession = this.#sessions.get(object.sessionId);
          if (parentSession) {
            parentSession.emit(CDPSessionEvent.SessionDetached, session);
          }
        }
      }
      if (object.sessionId) {
        const session = this.#sessions.get(object.sessionId);
        if (session) {
          session._onMessage(object);
        }
      } else if (object.id) {
        if (object.error) {
          this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);
        } else {
          this.#callbacks.resolve(object.id, object.result);
        }
      } else {
        this.emit(object.method, object.params);
      }
    }
    #onClose() {
      if (this.#closed) {
        return;
      }
      this.#closed = true;
      this.#transport.onmessage = void 0;
      this.#transport.onclose = void 0;
      this.#callbacks.clear();
      for (const session of this.#sessions.values()) {
        session._onClosed();
      }
      this.#sessions.clear();
      this.emit(CDPSessionEvent.Disconnected, void 0);
    }
    dispose() {
      this.#onClose();
      this.#transport.close();
    }
    /**
     * @internal
     */
    isAutoAttached(targetId) {
      return !this.#manuallyAttached.has(targetId);
    }
    /**
     * @internal
     */
    async _createSession(targetInfo, isAutoAttachEmulated = true) {
      if (!isAutoAttachEmulated) {
        this.#manuallyAttached.add(targetInfo.targetId);
      }
      const { sessionId } = await this.send("Target.attachToTarget", {
        targetId: targetInfo.targetId,
        flatten: true
      });
      this.#manuallyAttached.delete(targetInfo.targetId);
      const session = this.#sessions.get(sessionId);
      if (!session) {
        throw new Error("CDPSession creation failed.");
      }
      return session;
    }
    /**
     * @param targetInfo - The target info
     * @returns The CDP session that is created
     */
    async createSession(targetInfo) {
      return await this._createSession(targetInfo, false);
    }
    /**
     * @internal
     */
    getPendingProtocolErrors() {
      const result = [];
      result.push(...this.#callbacks.getPendingProtocolErrors());
      for (const session of this.#sessions.values()) {
        result.push(...session.getPendingProtocolErrors());
      }
      return result;
    }
  };
  function isTargetClosedError(error) {
    return error instanceof TargetCloseError;
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js
  init_dirname();
  init_buffer2();
  init_EventEmitter();
  init_util2();
  init_assert();
  init_disposable();
  var Coverage = class {
    #jsCoverage;
    #cssCoverage;
    constructor(client) {
      this.#jsCoverage = new JSCoverage(client);
      this.#cssCoverage = new CSSCoverage(client);
    }
    /**
     * @internal
     */
    updateClient(client) {
      this.#jsCoverage.updateClient(client);
      this.#cssCoverage.updateClient(client);
    }
    /**
     * @param options - Set of configurable options for coverage defaults to
     * `resetOnNavigation : true, reportAnonymousScripts : false,`
     * `includeRawScriptCoverage : false, useBlockCoverage : true`
     * @returns Promise that resolves when coverage is started.
     *
     * @remarks
     * Anonymous scripts are ones that don't have an associated url. These are
     * scripts that are dynamically created on the page using `eval` or
     * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
     * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL
     * comment is present, in which case that will the be URL).
     */
    async startJSCoverage(options = {}) {
      return await this.#jsCoverage.start(options);
    }
    /**
     * Promise that resolves to the array of coverage reports for
     * all scripts.
     *
     * @remarks
     * JavaScript Coverage doesn't include anonymous scripts by default.
     * However, scripts with sourceURLs are reported.
     */
    async stopJSCoverage() {
      return await this.#jsCoverage.stop();
    }
    /**
     * @param options - Set of configurable options for coverage, defaults to
     * `resetOnNavigation : true`
     * @returns Promise that resolves when coverage is started.
     */
    async startCSSCoverage(options = {}) {
      return await this.#cssCoverage.start(options);
    }
    /**
     * Promise that resolves to the array of coverage reports
     * for all stylesheets.
     *
     * @remarks
     * CSS Coverage doesn't include dynamically injected style tags
     * without sourceURLs.
     */
    async stopCSSCoverage() {
      return await this.#cssCoverage.stop();
    }
  };
  var JSCoverage = class {
    #client;
    #enabled = false;
    #scriptURLs = /* @__PURE__ */ new Map();
    #scriptSources = /* @__PURE__ */ new Map();
    #subscriptions;
    #resetOnNavigation = false;
    #reportAnonymousScripts = false;
    #includeRawScriptCoverage = false;
    constructor(client) {
      this.#client = client;
    }
    /**
     * @internal
     */
    updateClient(client) {
      this.#client = client;
    }
    async start(options = {}) {
      assert(!this.#enabled, "JSCoverage is already enabled");
      const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true } = options;
      this.#resetOnNavigation = resetOnNavigation;
      this.#reportAnonymousScripts = reportAnonymousScripts;
      this.#includeRawScriptCoverage = includeRawScriptCoverage;
      this.#enabled = true;
      this.#scriptURLs.clear();
      this.#scriptSources.clear();
      this.#subscriptions = new DisposableStack();
      this.#subscriptions.use(new EventSubscription(this.#client, "Debugger.scriptParsed", this.#onScriptParsed.bind(this)));
      this.#subscriptions.use(new EventSubscription(this.#client, "Runtime.executionContextsCleared", this.#onExecutionContextsCleared.bind(this)));
      await Promise.all([
        this.#client.send("Profiler.enable"),
        this.#client.send("Profiler.startPreciseCoverage", {
          callCount: this.#includeRawScriptCoverage,
          detailed: useBlockCoverage
        }),
        this.#client.send("Debugger.enable"),
        this.#client.send("Debugger.setSkipAllPauses", { skip: true })
      ]);
    }
    #onExecutionContextsCleared() {
      if (!this.#resetOnNavigation) {
        return;
      }
      this.#scriptURLs.clear();
      this.#scriptSources.clear();
    }
    async #onScriptParsed(event) {
      if (PuppeteerURL.isPuppeteerURL(event.url)) {
        return;
      }
      if (!event.url && !this.#reportAnonymousScripts) {
        return;
      }
      try {
        const response = await this.#client.send("Debugger.getScriptSource", {
          scriptId: event.scriptId
        });
        this.#scriptURLs.set(event.scriptId, event.url);
        this.#scriptSources.set(event.scriptId, response.scriptSource);
      } catch (error) {
        debugError(error);
      }
    }
    async stop() {
      assert(this.#enabled, "JSCoverage is not enabled");
      this.#enabled = false;
      const result = await Promise.all([
        this.#client.send("Profiler.takePreciseCoverage"),
        this.#client.send("Profiler.stopPreciseCoverage"),
        this.#client.send("Profiler.disable"),
        this.#client.send("Debugger.disable")
      ]);
      this.#subscriptions?.dispose();
      const coverage = [];
      const profileResponse = result[0];
      for (const entry of profileResponse.result) {
        let url = this.#scriptURLs.get(entry.scriptId);
        if (!url && this.#reportAnonymousScripts) {
          url = "debugger://VM" + entry.scriptId;
        }
        const text = this.#scriptSources.get(entry.scriptId);
        if (text === void 0 || url === void 0) {
          continue;
        }
        const flattenRanges = [];
        for (const func of entry.functions) {
          flattenRanges.push(...func.ranges);
        }
        const ranges = convertToDisjointRanges(flattenRanges);
        if (!this.#includeRawScriptCoverage) {
          coverage.push({ url, ranges, text });
        } else {
          coverage.push({ url, ranges, text, rawScriptCoverage: entry });
        }
      }
      return coverage;
    }
  };
  var CSSCoverage = class {
    #client;
    #enabled = false;
    #stylesheetURLs = /* @__PURE__ */ new Map();
    #stylesheetSources = /* @__PURE__ */ new Map();
    #eventListeners;
    #resetOnNavigation = false;
    constructor(client) {
      this.#client = client;
    }
    /**
     * @internal
     */
    updateClient(client) {
      this.#client = client;
    }
    async start(options = {}) {
      assert(!this.#enabled, "CSSCoverage is already enabled");
      const { resetOnNavigation = true } = options;
      this.#resetOnNavigation = resetOnNavigation;
      this.#enabled = true;
      this.#stylesheetURLs.clear();
      this.#stylesheetSources.clear();
      this.#eventListeners = new DisposableStack();
      this.#eventListeners.use(new EventSubscription(this.#client, "CSS.styleSheetAdded", this.#onStyleSheet.bind(this)));
      this.#eventListeners.use(new EventSubscription(this.#client, "Runtime.executionContextsCleared", this.#onExecutionContextsCleared.bind(this)));
      await Promise.all([
        this.#client.send("DOM.enable"),
        this.#client.send("CSS.enable"),
        this.#client.send("CSS.startRuleUsageTracking")
      ]);
    }
    #onExecutionContextsCleared() {
      if (!this.#resetOnNavigation) {
        return;
      }
      this.#stylesheetURLs.clear();
      this.#stylesheetSources.clear();
    }
    async #onStyleSheet(event) {
      const header = event.header;
      if (!header.sourceURL) {
        return;
      }
      try {
        const response = await this.#client.send("CSS.getStyleSheetText", {
          styleSheetId: header.styleSheetId
        });
        this.#stylesheetURLs.set(header.styleSheetId, header.sourceURL);
        this.#stylesheetSources.set(header.styleSheetId, response.text);
      } catch (error) {
        debugError(error);
      }
    }
    async stop() {
      assert(this.#enabled, "CSSCoverage is not enabled");
      this.#enabled = false;
      const ruleTrackingResponse = await this.#client.send("CSS.stopRuleUsageTracking");
      await Promise.all([
        this.#client.send("CSS.disable"),
        this.#client.send("DOM.disable")
      ]);
      this.#eventListeners?.dispose();
      const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
      for (const entry of ruleTrackingResponse.ruleUsage) {
        let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
        if (!ranges) {
          ranges = [];
          styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
        }
        ranges.push({
          startOffset: entry.startOffset,
          endOffset: entry.endOffset,
          count: entry.used ? 1 : 0
        });
      }
      const coverage = [];
      for (const styleSheetId of this.#stylesheetURLs.keys()) {
        const url = this.#stylesheetURLs.get(styleSheetId);
        assert(typeof url !== "undefined", `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
        const text = this.#stylesheetSources.get(styleSheetId);
        assert(typeof text !== "undefined", `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
        const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
        coverage.push({ url, ranges, text });
      }
      return coverage;
    }
  };
  function convertToDisjointRanges(nestedRanges) {
    const points = [];
    for (const range of nestedRanges) {
      points.push({ offset: range.startOffset, type: 0, range });
      points.push({ offset: range.endOffset, type: 1, range });
    }
    points.sort((a7, b5) => {
      if (a7.offset !== b5.offset) {
        return a7.offset - b5.offset;
      }
      if (a7.type !== b5.type) {
        return b5.type - a7.type;
      }
      const aLength = a7.range.endOffset - a7.range.startOffset;
      const bLength = b5.range.endOffset - b5.range.startOffset;
      if (a7.type === 0) {
        return bLength - aLength;
      }
      return aLength - bLength;
    });
    const hitCountStack = [];
    const results = [];
    let lastOffset = 0;
    for (const point of points) {
      if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
        const lastResult = results[results.length - 1];
        if (lastResult && lastResult.end === lastOffset) {
          lastResult.end = point.offset;
        } else {
          results.push({ start: lastOffset, end: point.offset });
        }
      }
      lastOffset = point.offset;
      if (point.type === 0) {
        hitCountStack.push(point.range.count);
      } else {
        hitCountStack.pop();
      }
    }
    return results.filter((range) => {
      return range.end - range.start > 0;
    });
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Dialog.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Dialog.js
  init_dirname();
  init_buffer2();
  init_assert();
  var Dialog = class {
    #type;
    #message;
    #defaultValue;
    #handled = false;
    /**
     * @internal
     */
    constructor(type, message, defaultValue = "") {
      this.#type = type;
      this.#message = message;
      this.#defaultValue = defaultValue;
    }
    /**
     * The type of the dialog.
     */
    type() {
      return this.#type;
    }
    /**
     * The message displayed in the dialog.
     */
    message() {
      return this.#message;
    }
    /**
     * The default value of the prompt, or an empty string if the dialog
     * is not a `prompt`.
     */
    defaultValue() {
      return this.#defaultValue;
    }
    /**
     * A promise that resolves when the dialog has been accepted.
     *
     * @param promptText - optional text that will be entered in the dialog
     * prompt. Has no effect if the dialog's type is not `prompt`.
     *
     */
    async accept(promptText) {
      assert(!this.#handled, "Cannot accept dialog which is already handled!");
      this.#handled = true;
      await this.handle({
        accept: true,
        text: promptText
      });
    }
    /**
     * A promise which will resolve once the dialog has been dismissed
     */
    async dismiss() {
      assert(!this.#handled, "Cannot dismiss dialog which is already handled!");
      this.#handled = true;
      await this.handle({
        accept: false
      });
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Dialog.js
  var CdpDialog = class extends Dialog {
    #client;
    constructor(client, type, message, defaultValue = "") {
      super(type, message, defaultValue);
      this.#client = client;
    }
    async handle(options) {
      await this.#client.send("Page.handleJavaScriptDialog", {
        accept: options.accept,
        promptText: options.text
      });
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/EmulationManager.js
  init_dirname();
  init_buffer2();
  init_CDPSession();
  init_util2();
  init_assert();
  init_decorators();
  var __runInitializers4 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i7 = 0; i7 < initializers.length; i7++) {
      value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate4 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f7) {
      if (f7 !== void 0 && typeof f7 !== "function")
        throw new TypeError("Function expected");
      return f7;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _4, done = false;
    for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
      var context2 = {};
      for (var p7 in contextIn)
        context2[p7] = p7 === "access" ? {} : contextIn[p7];
      for (var p7 in contextIn.access)
        context2.access[p7] = contextIn.access[p7];
      context2.addInitializer = function(f7) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f7 || null));
      };
      var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_4 = accept(result.get))
          descriptor.get = _4;
        if (_4 = accept(result.set))
          descriptor.set = _4;
        if (_4 = accept(result.init))
          initializers.unshift(_4);
      } else if (_4 = accept(result)) {
        if (kind === "field")
          initializers.unshift(_4);
        else
          descriptor[key] = _4;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __setFunctionName2 = function(f7, name2, prefix) {
    if (typeof name2 === "symbol")
      name2 = name2.description ? "[".concat(name2.description, "]") : "";
    return Object.defineProperty(f7, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
  };
  var EmulatedState = class {
    #state;
    #clientProvider;
    #updater;
    constructor(initialState, clientProvider, updater) {
      this.#state = initialState;
      this.#clientProvider = clientProvider;
      this.#updater = updater;
      this.#clientProvider.registerState(this);
    }
    async setState(state) {
      this.#state = state;
      await this.sync();
    }
    get state() {
      return this.#state;
    }
    async sync() {
      await Promise.all(this.#clientProvider.clients().map((client) => {
        return this.#updater(client, this.#state);
      }));
    }
  };
  var EmulationManager = (() => {
    let _instanceExtraInitializers = [];
    let _private_applyViewport_decorators;
    let _private_applyViewport_descriptor;
    let _private_emulateIdleState_decorators;
    let _private_emulateIdleState_descriptor;
    let _private_emulateTimezone_decorators;
    let _private_emulateTimezone_descriptor;
    let _private_emulateVisionDeficiency_decorators;
    let _private_emulateVisionDeficiency_descriptor;
    let _private_emulateCpuThrottling_decorators;
    let _private_emulateCpuThrottling_descriptor;
    let _private_emulateMediaFeatures_decorators;
    let _private_emulateMediaFeatures_descriptor;
    let _private_emulateMediaType_decorators;
    let _private_emulateMediaType_descriptor;
    let _private_setGeolocation_decorators;
    let _private_setGeolocation_descriptor;
    let _private_setDefaultBackgroundColor_decorators;
    let _private_setDefaultBackgroundColor_descriptor;
    let _private_setJavaScriptEnabled_decorators;
    let _private_setJavaScriptEnabled_descriptor;
    return class EmulationManager {
      static {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
        _private_applyViewport_decorators = [invokeAtMostOnceForArguments];
        _private_emulateIdleState_decorators = [invokeAtMostOnceForArguments];
        _private_emulateTimezone_decorators = [invokeAtMostOnceForArguments];
        _private_emulateVisionDeficiency_decorators = [invokeAtMostOnceForArguments];
        _private_emulateCpuThrottling_decorators = [invokeAtMostOnceForArguments];
        _private_emulateMediaFeatures_decorators = [invokeAtMostOnceForArguments];
        _private_emulateMediaType_decorators = [invokeAtMostOnceForArguments];
        _private_setGeolocation_decorators = [invokeAtMostOnceForArguments];
        _private_setDefaultBackgroundColor_decorators = [invokeAtMostOnceForArguments];
        _private_setJavaScriptEnabled_decorators = [invokeAtMostOnceForArguments];
        __esDecorate4(this, _private_applyViewport_descriptor = { value: __setFunctionName2(async function(client, viewportState) {
          if (!viewportState.viewport) {
            return;
          }
          const { viewport } = viewportState;
          const mobile = viewport.isMobile || false;
          const width = viewport.width;
          const height = viewport.height;
          const deviceScaleFactor = viewport.deviceScaleFactor ?? 1;
          const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
          const hasTouch = viewport.hasTouch || false;
          await Promise.all([
            client.send("Emulation.setDeviceMetricsOverride", {
              mobile,
              width,
              height,
              deviceScaleFactor,
              screenOrientation
            }).catch((err) => {
              if (err.message.includes("Target does not support metrics override")) {
                debugError(err);
                return;
              }
              throw err;
            }),
            client.send("Emulation.setTouchEmulationEnabled", {
              enabled: hasTouch
            })
          ]);
        }, "#applyViewport") }, _private_applyViewport_decorators, { kind: "method", name: "#applyViewport", static: false, private: true, access: { has: (obj) => #applyViewport in obj, get: (obj) => obj.#applyViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate4(this, _private_emulateIdleState_descriptor = { value: __setFunctionName2(async function(client, idleStateState) {
          if (!idleStateState.active) {
            return;
          }
          if (idleStateState.overrides) {
            await client.send("Emulation.setIdleOverride", {
              isUserActive: idleStateState.overrides.isUserActive,
              isScreenUnlocked: idleStateState.overrides.isScreenUnlocked
            });
          } else {
            await client.send("Emulation.clearIdleOverride");
          }
        }, "#emulateIdleState") }, _private_emulateIdleState_decorators, { kind: "method", name: "#emulateIdleState", static: false, private: true, access: { has: (obj) => #emulateIdleState in obj, get: (obj) => obj.#emulateIdleState }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate4(this, _private_emulateTimezone_descriptor = { value: __setFunctionName2(async function(client, timezoneState) {
          if (!timezoneState.active) {
            return;
          }
          try {
            await client.send("Emulation.setTimezoneOverride", {
              timezoneId: timezoneState.timezoneId || ""
            });
          } catch (error) {
            if (isErrorLike(error) && error.message.includes("Invalid timezone")) {
              throw new Error(`Invalid timezone ID: ${timezoneState.timezoneId}`);
            }
            throw error;
          }
        }, "#emulateTimezone") }, _private_emulateTimezone_decorators, { kind: "method", name: "#emulateTimezone", static: false, private: true, access: { has: (obj) => #emulateTimezone in obj, get: (obj) => obj.#emulateTimezone }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate4(this, _private_emulateVisionDeficiency_descriptor = { value: __setFunctionName2(async function(client, visionDeficiency) {
          if (!visionDeficiency.active) {
            return;
          }
          await client.send("Emulation.setEmulatedVisionDeficiency", {
            type: visionDeficiency.visionDeficiency || "none"
          });
        }, "#emulateVisionDeficiency") }, _private_emulateVisionDeficiency_decorators, { kind: "method", name: "#emulateVisionDeficiency", static: false, private: true, access: { has: (obj) => #emulateVisionDeficiency in obj, get: (obj) => obj.#emulateVisionDeficiency }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate4(this, _private_emulateCpuThrottling_descriptor = { value: __setFunctionName2(async function(client, state) {
          if (!state.active) {
            return;
          }
          await client.send("Emulation.setCPUThrottlingRate", {
            rate: state.factor ?? 1
          });
        }, "#emulateCpuThrottling") }, _private_emulateCpuThrottling_decorators, { kind: "method", name: "#emulateCpuThrottling", static: false, private: true, access: { has: (obj) => #emulateCpuThrottling in obj, get: (obj) => obj.#emulateCpuThrottling }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate4(this, _private_emulateMediaFeatures_descriptor = { value: __setFunctionName2(async function(client, state) {
          if (!state.active) {
            return;
          }
          await client.send("Emulation.setEmulatedMedia", {
            features: state.mediaFeatures
          });
        }, "#emulateMediaFeatures") }, _private_emulateMediaFeatures_decorators, { kind: "method", name: "#emulateMediaFeatures", static: false, private: true, access: { has: (obj) => #emulateMediaFeatures in obj, get: (obj) => obj.#emulateMediaFeatures }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate4(this, _private_emulateMediaType_descriptor = { value: __setFunctionName2(async function(client, state) {
          if (!state.active) {
            return;
          }
          await client.send("Emulation.setEmulatedMedia", {
            media: state.type || ""
          });
        }, "#emulateMediaType") }, _private_emulateMediaType_decorators, { kind: "method", name: "#emulateMediaType", static: false, private: true, access: { has: (obj) => #emulateMediaType in obj, get: (obj) => obj.#emulateMediaType }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate4(this, _private_setGeolocation_descriptor = { value: __setFunctionName2(async function(client, state) {
          if (!state.active) {
            return;
          }
          await client.send("Emulation.setGeolocationOverride", state.geoLocation ? {
            longitude: state.geoLocation.longitude,
            latitude: state.geoLocation.latitude,
            accuracy: state.geoLocation.accuracy
          } : void 0);
        }, "#setGeolocation") }, _private_setGeolocation_decorators, { kind: "method", name: "#setGeolocation", static: false, private: true, access: { has: (obj) => #setGeolocation in obj, get: (obj) => obj.#setGeolocation }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate4(this, _private_setDefaultBackgroundColor_descriptor = { value: __setFunctionName2(async function(client, state) {
          if (!state.active) {
            return;
          }
          await client.send("Emulation.setDefaultBackgroundColorOverride", {
            color: state.color
          });
        }, "#setDefaultBackgroundColor") }, _private_setDefaultBackgroundColor_decorators, { kind: "method", name: "#setDefaultBackgroundColor", static: false, private: true, access: { has: (obj) => #setDefaultBackgroundColor in obj, get: (obj) => obj.#setDefaultBackgroundColor }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate4(this, _private_setJavaScriptEnabled_descriptor = { value: __setFunctionName2(async function(client, state) {
          if (!state.active) {
            return;
          }
          await client.send("Emulation.setScriptExecutionDisabled", {
            value: !state.javaScriptEnabled
          });
        }, "#setJavaScriptEnabled") }, _private_setJavaScriptEnabled_decorators, { kind: "method", name: "#setJavaScriptEnabled", static: false, private: true, access: { has: (obj) => #setJavaScriptEnabled in obj, get: (obj) => obj.#setJavaScriptEnabled }, metadata: _metadata }, null, _instanceExtraInitializers);
        if (_metadata)
          Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      }
      #client = (__runInitializers4(this, _instanceExtraInitializers), void 0);
      #emulatingMobile = false;
      #hasTouch = false;
      #states = [];
      #viewportState = new EmulatedState({
        active: false
      }, this, this.#applyViewport);
      #idleOverridesState = new EmulatedState({
        active: false
      }, this, this.#emulateIdleState);
      #timezoneState = new EmulatedState({
        active: false
      }, this, this.#emulateTimezone);
      #visionDeficiencyState = new EmulatedState({
        active: false
      }, this, this.#emulateVisionDeficiency);
      #cpuThrottlingState = new EmulatedState({
        active: false
      }, this, this.#emulateCpuThrottling);
      #mediaFeaturesState = new EmulatedState({
        active: false
      }, this, this.#emulateMediaFeatures);
      #mediaTypeState = new EmulatedState({
        active: false
      }, this, this.#emulateMediaType);
      #geoLocationState = new EmulatedState({
        active: false
      }, this, this.#setGeolocation);
      #defaultBackgroundColorState = new EmulatedState({
        active: false
      }, this, this.#setDefaultBackgroundColor);
      #javascriptEnabledState = new EmulatedState({
        javaScriptEnabled: true,
        active: false
      }, this, this.#setJavaScriptEnabled);
      #secondaryClients = /* @__PURE__ */ new Set();
      constructor(client) {
        this.#client = client;
      }
      updateClient(client) {
        this.#client = client;
        this.#secondaryClients.delete(client);
      }
      registerState(state) {
        this.#states.push(state);
      }
      clients() {
        return [this.#client, ...Array.from(this.#secondaryClients)];
      }
      async registerSpeculativeSession(client) {
        this.#secondaryClients.add(client);
        client.once(CDPSessionEvent.Disconnected, () => {
          this.#secondaryClients.delete(client);
        });
        void Promise.all(this.#states.map((s6) => {
          return s6.sync().catch(debugError);
        }));
      }
      get javascriptEnabled() {
        return this.#javascriptEnabledState.state.javaScriptEnabled;
      }
      async emulateViewport(viewport) {
        await this.#viewportState.setState({
          viewport,
          active: true
        });
        const mobile = viewport.isMobile || false;
        const hasTouch = viewport.hasTouch || false;
        const reloadNeeded = this.#emulatingMobile !== mobile || this.#hasTouch !== hasTouch;
        this.#emulatingMobile = mobile;
        this.#hasTouch = hasTouch;
        return reloadNeeded;
      }
      get #applyViewport() {
        return _private_applyViewport_descriptor.value;
      }
      async emulateIdleState(overrides) {
        await this.#idleOverridesState.setState({
          active: true,
          overrides
        });
      }
      get #emulateIdleState() {
        return _private_emulateIdleState_descriptor.value;
      }
      get #emulateTimezone() {
        return _private_emulateTimezone_descriptor.value;
      }
      async emulateTimezone(timezoneId) {
        await this.#timezoneState.setState({
          timezoneId,
          active: true
        });
      }
      get #emulateVisionDeficiency() {
        return _private_emulateVisionDeficiency_descriptor.value;
      }
      async emulateVisionDeficiency(type) {
        const visionDeficiencies = /* @__PURE__ */ new Set([
          "none",
          "achromatopsia",
          "blurredVision",
          "deuteranopia",
          "protanopia",
          "tritanopia"
        ]);
        assert(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
        await this.#visionDeficiencyState.setState({
          active: true,
          visionDeficiency: type
        });
      }
      get #emulateCpuThrottling() {
        return _private_emulateCpuThrottling_descriptor.value;
      }
      async emulateCPUThrottling(factor) {
        assert(factor === null || factor >= 1, "Throttling rate should be greater or equal to 1");
        await this.#cpuThrottlingState.setState({
          active: true,
          factor: factor ?? void 0
        });
      }
      get #emulateMediaFeatures() {
        return _private_emulateMediaFeatures_descriptor.value;
      }
      async emulateMediaFeatures(features) {
        if (Array.isArray(features)) {
          for (const mediaFeature of features) {
            const name2 = mediaFeature.name;
            assert(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name2), "Unsupported media feature: " + name2);
          }
        }
        await this.#mediaFeaturesState.setState({
          active: true,
          mediaFeatures: features
        });
      }
      get #emulateMediaType() {
        return _private_emulateMediaType_descriptor.value;
      }
      async emulateMediaType(type) {
        assert(type === "screen" || type === "print" || (type ?? void 0) === void 0, "Unsupported media type: " + type);
        await this.#mediaTypeState.setState({
          type,
          active: true
        });
      }
      get #setGeolocation() {
        return _private_setGeolocation_descriptor.value;
      }
      async setGeolocation(options) {
        const { longitude, latitude, accuracy = 0 } = options;
        if (longitude < -180 || longitude > 180) {
          throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
        }
        if (latitude < -90 || latitude > 90) {
          throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
        }
        if (accuracy < 0) {
          throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
        }
        await this.#geoLocationState.setState({
          active: true,
          geoLocation: {
            longitude,
            latitude,
            accuracy
          }
        });
      }
      get #setDefaultBackgroundColor() {
        return _private_setDefaultBackgroundColor_descriptor.value;
      }
      /**
       * Resets default white background
       */
      async resetDefaultBackgroundColor() {
        await this.#defaultBackgroundColorState.setState({
          active: true,
          color: void 0
        });
      }
      /**
       * Hides default white background
       */
      async setTransparentBackgroundColor() {
        await this.#defaultBackgroundColorState.setState({
          active: true,
          color: { r: 0, g: 0, b: 0, a: 0 }
        });
      }
      get #setJavaScriptEnabled() {
        return _private_setJavaScriptEnabled_descriptor.value;
      }
      async setJavaScriptEnabled(enabled) {
        await this.#javascriptEnabledState.setState({
          active: true,
          javaScriptEnabled: enabled
        });
      }
    };
  })();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ExecutionContext.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/LazyArg.js
  init_dirname();
  init_buffer2();
  var LazyArg = class _LazyArg {
    static create = (get) => {
      return new _LazyArg(get);
    };
    #get;
    constructor(get) {
      this.#get = get;
    }
    async get(context2) {
      return await this.#get(context2);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/generated/injected.js
  init_dirname();
  init_buffer2();
  var source = '"use strict";var v=Object.defineProperty;var re=Object.getOwnPropertyDescriptor;var ne=Object.getOwnPropertyNames;var oe=Object.prototype.hasOwnProperty;var u=(t,e)=>{for(var n in e)v(t,n,{get:e[n],enumerable:!0})},se=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of ne(e))!oe.call(t,o)&&o!==n&&v(t,o,{get:()=>e[o],enumerable:!(r=re(e,o))||r.enumerable});return t};var ie=t=>se(v({},"__esModule",{value:!0}),t);var Re={};u(Re,{default:()=>ke});module.exports=ie(Re);var C=class extends Error{constructor(e,n){super(e,n),this.name=this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}},b=class extends C{};var f=class t{static create(e){return new t(e)}static async race(e){let n=new Set;try{let r=e.map(o=>o instanceof t?(o.#s&&n.add(o),o.valueOrThrow()):o);return await Promise.race(r)}finally{for(let r of n)r.reject(new Error("Timeout cleared"))}}#e=!1;#r=!1;#n;#t;#o=new Promise(e=>{this.#t=e});#s;#l;constructor(e){e&&e.timeout>0&&(this.#l=new b(e.message),this.#s=setTimeout(()=>{this.reject(this.#l)},e.timeout))}#a(e){clearTimeout(this.#s),this.#n=e,this.#t()}resolve(e){this.#r||this.#e||(this.#e=!0,this.#a(e))}reject(e){this.#r||this.#e||(this.#r=!0,this.#a(e))}resolved(){return this.#e}finished(){return this.#e||this.#r}value(){return this.#n}#i;valueOrThrow(){return this.#i||(this.#i=(async()=>{if(await this.#o,this.#r)throw this.#n;return this.#n})()),this.#i}};var X=new Map,z=t=>{let e=X.get(t);return e||(e=new Function(`return ${t}`)(),X.set(t,e),e)};var k={};u(k,{ariaQuerySelector:()=>le,ariaQuerySelectorAll:()=>I});var le=(t,e)=>window.__ariaQuerySelector(t,e),I=async function*(t,e){yield*await window.__ariaQuerySelectorAll(t,e)};var M={};u(M,{customQuerySelectors:()=>O});var R=class{#e=new Map;register(e,n){if(!n.queryOne&&n.queryAll){let r=n.queryAll;n.queryOne=(o,i)=>{for(let s of r(o,i))return s;return null}}else if(n.queryOne&&!n.queryAll){let r=n.queryOne;n.queryAll=(o,i)=>{let s=r(o,i);return s?[s]:[]}}else if(!n.queryOne||!n.queryAll)throw new Error("At least one query method must be defined.");this.#e.set(e,{querySelector:n.queryOne,querySelectorAll:n.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},O=new R;var q={};u(q,{pierceQuerySelector:()=>ae,pierceQuerySelectorAll:()=>ce});var ae=(t,e)=>{let n=null,r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&!n&&s.matches(e)&&(n=s)}while(!n&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n},ce=(t,e)=>{let n=[],r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&s.matches(e)&&n.push(s)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n};var m=(t,e)=>{if(!t)throw new Error(e)};var T=class{#e;#r;#n;#t;constructor(e,n){this.#e=e,this.#r=n}async start(){let e=this.#t=f.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=new MutationObserver(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())}),this.#n.observe(this.#r,{childList:!0,subtree:!0,attributes:!0})}async stop(){m(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#n&&(this.#n.disconnect(),this.#n=void 0)}result(){return m(this.#t,"Polling never started."),this.#t.valueOrThrow()}},E=class{#e;#r;constructor(e){this.#e=e}async start(){let e=this.#r=f.create(),n=await this.#e();if(n){e.resolve(n);return}let r=async()=>{if(e.finished())return;let o=await this.#e();if(!o){window.requestAnimationFrame(r);return}e.resolve(o),await this.stop()};window.requestAnimationFrame(r)}async stop(){m(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped"))}result(){return m(this.#r,"Polling never started."),this.#r.valueOrThrow()}},P=class{#e;#r;#n;#t;constructor(e,n){this.#e=e,this.#r=n}async start(){let e=this.#t=f.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=setInterval(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())},this.#r)}async stop(){m(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#n&&(clearInterval(this.#n),this.#n=void 0)}result(){return m(this.#t,"Polling never started."),this.#t.valueOrThrow()}};var V={};u(V,{pQuerySelector:()=>Ce,pQuerySelectorAll:()=>te});var c=class{static async*map(e,n){for await(let r of e)yield await n(r)}static async*flatMap(e,n){for await(let r of e)yield*n(r)}static async collect(e){let n=[];for await(let r of e)n.push(r);return n}static async first(e){for await(let n of e)return n}};var p={attribute:/\\[\\s*(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,id:/#(?<name>[-\\w\\P{ASCII}]+)/gu,class:/\\.(?<name>[-\\w\\P{ASCII}]+)/gu,comma:/\\s*,\\s*/g,combinator:/\\s*[\\s>+~]\\s*/g,"pseudo-element":/::(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>\xB6*)\\))?/gu,"pseudo-class":/:(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>\xB6*)\\))?/gu,universal:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?\\*/gu,type:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)/gu},ue=new Set(["combinator","comma"]);var fe=t=>{switch(t){case"pseudo-element":case"pseudo-class":return new RegExp(p[t].source.replace("(?<argument>\\xB6*)","(?<argument>.*)"),"gu");default:return p[t]}};function de(t,e){let n=0,r="";for(;e<t.length;e++){let o=t[e];switch(o){case"(":++n;break;case")":--n;break}if(r+=o,n===0)return r}return r}function me(t,e=p){if(!t)return[];let n=[t];for(let[o,i]of Object.entries(e))for(let s=0;s<n.length;s++){let l=n[s];if(typeof l!="string")continue;i.lastIndex=0;let a=i.exec(l);if(!a)continue;let h=a.index-1,d=[],W=a[0],H=l.slice(0,h+1);H&&d.push(H),d.push({...a.groups,type:o,content:W});let B=l.slice(h+W.length+1);B&&d.push(B),n.splice(s,1,...d)}let r=0;for(let o of n)switch(typeof o){case"string":throw new Error(`Unexpected sequence ${o} found at index ${r}`);case"object":r+=o.content.length,o.pos=[r-o.content.length,r],ue.has(o.type)&&(o.content=o.content.trim()||" ");break}return n}var he=/([\'"])([^\\\\\\n]+?)\\1/g,pe=/\\\\./g;function G(t,e=p){if(t=t.trim(),t==="")return[];let n=[];t=t.replace(pe,(i,s)=>(n.push({value:i,offset:s}),"\\uE000".repeat(i.length))),t=t.replace(he,(i,s,l,a)=>(n.push({value:i,offset:a}),`${s}${"\\uE001".repeat(l.length)}${s}`));{let i=0,s;for(;(s=t.indexOf("(",i))>-1;){let l=de(t,s);n.push({value:l,offset:s}),t=`${t.substring(0,s)}(${"\\xB6".repeat(l.length-2)})${t.substring(s+l.length)}`,i=s+l.length}}let r=me(t,e),o=new Set;for(let i of n.reverse())for(let s of r){let{offset:l,value:a}=i;if(!(s.pos[0]<=l&&l+a.length<=s.pos[1]))continue;let{content:h}=s,d=l-s.pos[0];s.content=h.slice(0,d)+a+h.slice(d+a.length),s.content!==h&&o.add(s)}for(let i of o){let s=fe(i.type);if(!s)throw new Error(`Unknown token type: ${i.type}`);s.lastIndex=0;let l=s.exec(i.content);if(!l)throw new Error(`Unable to parse content for ${i.type}: ${i.content}`);Object.assign(i,l.groups)}return r}function*x(t,e){switch(t.type){case"list":for(let n of t.list)yield*x(n,t);break;case"complex":yield*x(t.left,t),yield*x(t.right,t);break;case"compound":yield*t.list.map(n=>[n,t]);break;default:yield[t,e]}}function y(t){let e;return Array.isArray(t)?e=t:e=[...x(t)].map(([n])=>n),e.map(n=>n.content).join("")}p.combinator=/\\s*(>>>>?|[\\s>+~])\\s*/g;var ye=/\\\\[\\s\\S]/g,ge=t=>t.length<=1?t:((t[0]===\'"\'||t[0]==="\'")&&t.endsWith(t[0])&&(t=t.slice(1,-1)),t.replace(ye,e=>e[1]));function K(t){let e=!0,n=G(t);if(n.length===0)return[[],e];let r=[],o=[r],i=[o],s=[];for(let l of n){switch(l.type){case"combinator":switch(l.content){case">>>":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(">>>"),o.push(r);continue;case">>>>":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(">>>>"),o.push(r);continue}break;case"pseudo-element":if(!l.name.startsWith("-p-"))break;e=!1,s.length&&(r.push(y(s)),s.splice(0)),r.push({name:l.name.slice(3),value:ge(l.argument??"")});continue;case"comma":s.length&&(r.push(y(s)),s.splice(0)),r=[],o=[r],i.push(o);continue}s.push(l)}return s.length&&r.push(y(s)),[i,e]}var _={};u(_,{textQuerySelectorAll:()=>S});var we=new Set(["checkbox","image","radio"]),Se=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!we.has(t.type),be=new Set(["SCRIPT","STYLE"]),w=t=>!be.has(t.nodeName)&&!document.head?.contains(t),D=new WeakMap,J=t=>{for(;t;)D.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},Y=new WeakSet,Te=new MutationObserver(t=>{for(let e of t)J(e.target)}),g=t=>{let e=D.get(t);if(e||(e={full:"",immediate:[]},!w(t)))return e;let n="";if(Se(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener("input",r=>{J(r.target)},{once:!0,capture:!0});else{for(let r=t.firstChild;r;r=r.nextSibling){if(r.nodeType===Node.TEXT_NODE){e.full+=r.nodeValue??"",n+=r.nodeValue??"";continue}n&&e.immediate.push(n),n="",r.nodeType===Node.ELEMENT_NODE&&(e.full+=g(r).full)}n&&e.immediate.push(n),t instanceof Element&&t.shadowRoot&&(e.full+=g(t.shadowRoot).full),Y.has(t)||(Te.observe(t,{childList:!0,characterData:!0,subtree:!0}),Y.add(t))}return D.set(t,e),e};var S=function*(t,e){let n=!1;for(let r of t.childNodes)if(r instanceof Element&&w(r)){let o;r.shadowRoot?o=S(r.shadowRoot,e):o=S(r,e);for(let i of o)yield i,n=!0}n||t instanceof Element&&w(t)&&g(t).full.includes(e)&&(yield t)};var L={};u(L,{checkVisibility:()=>Pe,pierce:()=>N,pierceAll:()=>Q});var Ee=["hidden","collapse"],Pe=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let n=t.nodeType===Node.TEXT_NODE?t.parentElement:t,r=window.getComputedStyle(n),o=r&&!Ee.includes(r.visibility)&&!xe(n);return e===o?t:!1};function xe(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var Ne=t=>"shadowRoot"in t&&t.shadowRoot instanceof ShadowRoot;function*N(t){Ne(t)?yield t.shadowRoot:yield t}function*Q(t){t=N(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let n of e){let r;for(;r=n.nextNode();)r.shadowRoot&&(yield r.shadowRoot,e.push(document.createTreeWalker(r.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var j={};u(j,{xpathQuerySelectorAll:()=>$});var $=function*(t,e,n=-1){let o=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),i=[],s;for(;(s=o.iterateNext())&&(i.push(s),!(n&&i.length===n)););for(let l=0;l<i.length;l++)s=i[l],yield s,delete i[l]};var Ae=/[-\\w\\P{ASCII}*]/,Z=t=>"querySelectorAll"in t,A=class extends Error{constructor(e,n){super(`${e} is not a valid selector: ${n}`)}},U=class{#e;#r;#n=[];#t=void 0;elements;constructor(e,n,r){this.elements=[e],this.#e=n,this.#r=r,this.#o()}async run(){if(typeof this.#t=="string")switch(this.#t.trimStart()){case":scope":this.#o();break}for(;this.#t!==void 0;this.#o()){let e=this.#t,n=this.#e;typeof e=="string"?e[0]&&Ae.test(e[0])?this.elements=c.flatMap(this.elements,async function*(r){Z(r)&&(yield*r.querySelectorAll(e))}):this.elements=c.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!Z(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let i of r.parentElement.children)if(++o,i===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=c.flatMap(this.elements,async function*(r){switch(e.name){case"text":yield*S(r,e.value);break;case"xpath":yield*$(r,e.value);break;case"aria":yield*I(r,e.value);break;default:let o=O.get(e.name);if(!o)throw new A(n,`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#o(){if(this.#n.length!==0){this.#t=this.#n.shift();return}if(this.#r.length===0){this.#t=void 0;return}let e=this.#r.shift();switch(e){case">>>>":{this.elements=c.flatMap(this.elements,N),this.#o();break}case">>>":{this.elements=c.flatMap(this.elements,Q),this.#o();break}default:this.#n=e,this.#o();break}}},F=class{#e=new WeakMap;calculate(e,n=[]){if(e===null)return n;e instanceof ShadowRoot&&(e=e.host);let r=this.#e.get(e);if(r)return[...r,...n];let o=0;for(let s=e.previousSibling;s;s=s.previousSibling)++o;let i=this.calculate(e.parentNode,[o]);return this.#e.set(e,i),[...i,...n]}},ee=(t,e)=>{if(t.length+e.length===0)return 0;let[n=-1,...r]=t,[o=-1,...i]=e;return n===o?ee(r,i):n<o?-1:1},ve=async function*(t){let e=new Set;for await(let r of t)e.add(r);let n=new F;yield*[...e.values()].map(r=>[r,n.calculate(r)]).sort(([,r],[,o])=>ee(r,o)).map(([r])=>r)},te=function(t,e){let n,r;try{[n,r]=K(e)}catch{return t.querySelectorAll(e)}if(r)return t.querySelectorAll(e);if(n.some(o=>{let i=0;return o.some(s=>(typeof s=="string"?++i:i=0,i>1))}))throw new A(e,"Multiple deep combinators found in sequence.");return ve(c.flatMap(n,o=>{let i=new U(t,e,o);return i.run(),i.elements}))},Ce=async function(t,e){for await(let n of te(t,e))return n;return null};var Ie=Object.freeze({...k,...M,...q,...V,..._,...L,...j,Deferred:f,createFunction:z,createTextContent:g,IntervalPoller:P,isSuitableNodeForTextMatching:w,MutationPoller:T,RAFPoller:E}),ke=Ie;\n/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2024 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n';

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js
  var ScriptInjector = class {
    #updated = false;
    #amendments = /* @__PURE__ */ new Set();
    // Appends a statement of the form `(PuppeteerUtil) => {...}`.
    append(statement) {
      this.#update(() => {
        this.#amendments.add(statement);
      });
    }
    pop(statement) {
      this.#update(() => {
        this.#amendments.delete(statement);
      });
    }
    inject(inject, force = false) {
      if (this.#updated || force) {
        inject(this.#get());
      }
      this.#updated = false;
    }
    #update(callback) {
      callback();
      this.#updated = true;
    }
    #get() {
      return `(() => {
      const module = {};
      ${source}
      ${[...this.#amendments].map((statement) => {
        return `(${statement})(module.exports.default);`;
      }).join("")}
      return module.exports.default;
    })()`;
    }
  };
  var scriptInjector = new ScriptInjector();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ExecutionContext.js
  init_util2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/AsyncIterableUtil.js
  init_dirname();
  init_buffer2();
  var AsyncIterableUtil = class {
    static async *map(iterable, map2) {
      for await (const value of iterable) {
        yield await map2(value);
      }
    }
    static async *flatMap(iterable, map2) {
      for await (const value of iterable) {
        yield* map2(value);
      }
    }
    static async collect(iterable) {
      const result = [];
      for await (const value of iterable) {
        result.push(value);
      }
      return result;
    }
    static async first(iterable) {
      for await (const value of iterable) {
        return value;
      }
      return;
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/Function.js
  init_dirname();
  init_buffer2();
  var createdFunctions = /* @__PURE__ */ new Map();
  var createFunction = (functionValue) => {
    let fn = createdFunctions.get(functionValue);
    if (fn) {
      return fn;
    }
    fn = new Function(`return ${functionValue}`)();
    createdFunctions.set(functionValue, fn);
    return fn;
  };
  function stringifyFunction(fn) {
    let value = fn.toString();
    try {
      new Function(`(${value})`);
    } catch {
      let prefix = "function ";
      if (value.startsWith("async ")) {
        prefix = `async ${prefix}`;
        value = value.substring("async ".length);
      }
      value = `${prefix}${value}`;
      try {
        new Function(`(${value})`);
      } catch {
        throw new Error("Passed function cannot be serialized!");
      }
    }
    return value;
  }
  var interpolateFunction = (fn, replacements) => {
    let value = stringifyFunction(fn);
    for (const [name2, jsValue] of Object.entries(replacements)) {
      value = value.replace(
        new RegExp(`PLACEHOLDER\\(\\s*(?:'${name2}'|"${name2}")\\s*\\)`, "g"),
        // Wrapping this ensures tersers that accidently inline PLACEHOLDER calls
        // are still valid. Without, we may get calls like ()=>{...}() which is
        // not valid.
        `(${jsValue})`
      );
    }
    return createFunction(value);
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandleSymbol.js
  init_dirname();
  init_buffer2();
  var _isElementHandle = Symbol("_isElementHandle");

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/HandleIterator.js
  init_dirname();
  init_buffer2();
  init_disposable();
  var __addDisposableResource6 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async2) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources6 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail2(e9) {
        env.error = env.hasError ? new SuppressedError2(e9, env.error, "An error was suppressed during disposal.") : e9;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  var DEFAULT_BATCH_SIZE = 20;
  async function* fastTransposeIteratorHandle(iterator2, size) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const array = __addDisposableResource6(env_1, await iterator2.evaluateHandle(async (iterator3, size2) => {
        const results = [];
        while (results.length < size2) {
          const result = await iterator3.next();
          if (result.done) {
            break;
          }
          results.push(result.value);
        }
        return results;
      }, size), false);
      const properties = await array.getProperties();
      const handles = properties.values();
      const stack = __addDisposableResource6(env_1, new DisposableStack(), false);
      stack.defer(() => {
        for (const handle_1 of handles) {
          const env_2 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource6(env_2, handle_1, false);
            handle[disposeSymbol]();
          } catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
          } finally {
            __disposeResources6(env_2);
          }
        }
      });
      yield* handles;
      return properties.size === 0;
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources6(env_1);
    }
  }
  async function* transposeIteratorHandle(iterator2) {
    let size = DEFAULT_BATCH_SIZE;
    while (!(yield* fastTransposeIteratorHandle(iterator2, size))) {
      size <<= 1;
    }
  }
  async function* transposeIterableHandle(handle) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      const generatorHandle = __addDisposableResource6(env_3, await handle.evaluateHandle((iterable) => {
        return async function* () {
          yield* iterable;
        }();
      }), false);
      yield* transposeIteratorHandle(generatorHandle);
    } catch (e_3) {
      env_3.error = e_3;
      env_3.hasError = true;
    } finally {
      __disposeResources6(env_3);
    }
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js
  var __addDisposableResource7 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async2) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources7 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail2(e9) {
        env.error = env.hasError ? new SuppressedError2(e9, env.error, "An error was suppressed during disposal.") : e9;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  var QueryHandler = class {
    // Either one of these may be implemented, but at least one must be.
    static querySelectorAll;
    static querySelector;
    static get _querySelector() {
      if (this.querySelector) {
        return this.querySelector;
      }
      if (!this.querySelectorAll) {
        throw new Error("Cannot create default `querySelector`.");
      }
      return this.querySelector = interpolateFunction(async (node, selector, PuppeteerUtil) => {
        const querySelectorAll = PLACEHOLDER("querySelectorAll");
        const results = querySelectorAll(node, selector, PuppeteerUtil);
        for await (const result of results) {
          return result;
        }
        return null;
      }, {
        querySelectorAll: stringifyFunction(this.querySelectorAll)
      });
    }
    static get _querySelectorAll() {
      if (this.querySelectorAll) {
        return this.querySelectorAll;
      }
      if (!this.querySelector) {
        throw new Error("Cannot create default `querySelectorAll`.");
      }
      return this.querySelectorAll = interpolateFunction(async function* (node, selector, PuppeteerUtil) {
        const querySelector = PLACEHOLDER("querySelector");
        const result = await querySelector(node, selector, PuppeteerUtil);
        if (result) {
          yield result;
        }
      }, {
        querySelector: stringifyFunction(this.querySelector)
      });
    }
    /**
     * Queries for multiple nodes given a selector and {@link ElementHandle}.
     *
     * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll | Document.querySelectorAll()}.
     */
    static async *queryAll(element, selector) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource7(env_1, await element.evaluateHandle(this._querySelectorAll, selector, LazyArg.create((context2) => {
          return context2.puppeteerUtil;
        })), false);
        yield* transposeIterableHandle(handle);
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources7(env_1);
      }
    }
    /**
     * Queries for a single node given a selector and {@link ElementHandle}.
     *
     * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector}.
     */
    static async queryOne(element, selector) {
      const env_2 = { stack: [], error: void 0, hasError: false };
      try {
        const result = __addDisposableResource7(env_2, await element.evaluateHandle(this._querySelector, selector, LazyArg.create((context2) => {
          return context2.puppeteerUtil;
        })), false);
        if (!(_isElementHandle in result)) {
          return null;
        }
        return result.move();
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        __disposeResources7(env_2);
      }
    }
    /**
     * Waits until a single node appears for a given selector and
     * {@link ElementHandle}.
     *
     * This will always query the handle in the Puppeteer world and migrate the
     * result to the main world.
     */
    static async waitFor(elementOrFrame, selector, options) {
      const env_3 = { stack: [], error: void 0, hasError: false };
      try {
        let frame;
        const element = __addDisposableResource7(env_3, await (async () => {
          if (!(_isElementHandle in elementOrFrame)) {
            frame = elementOrFrame;
            return;
          }
          frame = elementOrFrame.frame;
          return await frame.isolatedRealm().adoptHandle(elementOrFrame);
        })(), false);
        const { visible = false, hidden = false, timeout: timeout2, signal } = options;
        try {
          const env_4 = { stack: [], error: void 0, hasError: false };
          try {
            signal?.throwIfAborted();
            const handle = __addDisposableResource7(env_4, await frame.isolatedRealm().waitForFunction(async (PuppeteerUtil, query, selector2, root, visible2) => {
              const querySelector = PuppeteerUtil.createFunction(query);
              const node = await querySelector(root ?? document, selector2, PuppeteerUtil);
              return PuppeteerUtil.checkVisibility(node, visible2);
            }, {
              polling: visible || hidden ? "raf" : "mutation",
              root: element,
              timeout: timeout2,
              signal
            }, LazyArg.create((context2) => {
              return context2.puppeteerUtil;
            }), stringifyFunction(this._querySelector), selector, element, visible ? true : hidden ? false : void 0), false);
            if (signal?.aborted) {
              throw signal.reason;
            }
            if (!(_isElementHandle in handle)) {
              return null;
            }
            return await frame.mainRealm().transferHandle(handle);
          } catch (e_3) {
            env_4.error = e_3;
            env_4.hasError = true;
          } finally {
            __disposeResources7(env_4);
          }
        } catch (error) {
          if (!isErrorLike(error)) {
            throw error;
          }
          if (error.name === "AbortError") {
            throw error;
          }
          error.message = `Waiting for selector \`${selector}\` failed: ${error.message}`;
          throw error;
        }
      } catch (e_4) {
        env_3.error = e_4;
        env_3.hasError = true;
      } finally {
        __disposeResources7(env_3);
      }
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js
  init_assert();
  var NON_ELEMENT_NODE_ROLES = /* @__PURE__ */ new Set(["StaticText", "InlineTextBox"]);
  var queryAXTree = async (client, element, accessibleName, role) => {
    const { nodes } = await client.send("Accessibility.queryAXTree", {
      objectId: element.id,
      accessibleName,
      role
    });
    return nodes.filter((node) => {
      return !node.role || !NON_ELEMENT_NODE_ROLES.has(node.role.value);
    });
  };
  var isKnownAttribute = (attribute) => {
    return ["name", "role"].includes(attribute);
  };
  var normalizeValue = (value) => {
    return value.replace(/ +/g, " ").trim();
  };
  var ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
  var parseARIASelector = (selector) => {
    const queryOptions = {};
    const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_4, attribute, __, value) => {
      attribute = attribute.trim();
      assert(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
      queryOptions[attribute] = normalizeValue(value);
      return "";
    });
    if (defaultName && !queryOptions.name) {
      queryOptions.name = normalizeValue(defaultName);
    }
    return queryOptions;
  };
  var ARIAQueryHandler = class extends QueryHandler {
    static querySelector = async (node, selector, { ariaQuerySelector }) => {
      return await ariaQuerySelector(node, selector);
    };
    static async *queryAll(element, selector) {
      const { name: name2, role } = parseARIASelector(selector);
      const results = await queryAXTree(element.realm.environment.client, element, name2, role);
      yield* AsyncIterableUtil.map(results, (node) => {
        return element.realm.adoptBackendNode(node.backendDOMNodeId);
      });
    }
    static queryOne = async (element, selector) => {
      return await AsyncIterableUtil.first(this.queryAll(element, selector)) ?? null;
    };
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ElementHandle.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/CustomQueryHandler.js
  init_dirname();
  init_buffer2();
  init_assert();
  var CustomQueryHandlerRegistry = class {
    #handlers = /* @__PURE__ */ new Map();
    get(name2) {
      const handler = this.#handlers.get(name2);
      return handler ? handler[1] : void 0;
    }
    /**
     * Registers a {@link CustomQueryHandler | custom query handler}.
     *
     * @remarks
     * After registration, the handler can be used everywhere where a selector is
     * expected by prepending the selection string with `<name>/`. The name is
     * only allowed to consist of lower- and upper case latin letters.
     *
     * @example
     *
     * ```ts
     * Puppeteer.customQueryHandlers.register('lit', { … });
     * const aHandle = await page.$('lit/…');
     * ```
     *
     * @param name - Name to register under.
     * @param queryHandler - {@link CustomQueryHandler | Custom query handler} to
     * register.
     */
    register(name2, handler) {
      assert(!this.#handlers.has(name2), `Cannot register over existing handler: ${name2}`);
      assert(/^[a-zA-Z]+$/.test(name2), `Custom query handler names may only contain [a-zA-Z]`);
      assert(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
      const Handler = class extends QueryHandler {
        static querySelectorAll = interpolateFunction((node, selector, PuppeteerUtil) => {
          return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelectorAll(node, selector);
        }, { name: JSON.stringify(name2) });
        static querySelector = interpolateFunction((node, selector, PuppeteerUtil) => {
          return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelector(node, selector);
        }, { name: JSON.stringify(name2) });
      };
      const registerScript = interpolateFunction((PuppeteerUtil) => {
        PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER("name"), {
          queryAll: PLACEHOLDER("queryAll"),
          queryOne: PLACEHOLDER("queryOne")
        });
      }, {
        name: JSON.stringify(name2),
        queryAll: handler.queryAll ? stringifyFunction(handler.queryAll) : String(void 0),
        queryOne: handler.queryOne ? stringifyFunction(handler.queryOne) : String(void 0)
      }).toString();
      this.#handlers.set(name2, [registerScript, Handler]);
      scriptInjector.append(registerScript);
    }
    /**
     * Unregisters the {@link CustomQueryHandler | custom query handler} for the
     * given name.
     *
     * @throws `Error` if there is no handler under the given name.
     */
    unregister(name2) {
      const handler = this.#handlers.get(name2);
      if (!handler) {
        throw new Error(`Cannot unregister unknown handler: ${name2}`);
      }
      scriptInjector.pop(handler[0]);
      this.#handlers.delete(name2);
    }
    /**
     * Gets the names of all {@link CustomQueryHandler | custom query handlers}.
     */
    names() {
      return [...this.#handlers.keys()];
    }
    /**
     * Unregisters all custom query handlers.
     */
    clear() {
      for (const [registerScript] of this.#handlers) {
        scriptInjector.pop(registerScript);
      }
      this.#handlers.clear();
    }
  };
  var customQueryHandlers = new CustomQueryHandlerRegistry();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/PierceQueryHandler.js
  init_dirname();
  init_buffer2();
  var PierceQueryHandler = class extends QueryHandler {
    static querySelector = (element, selector, { pierceQuerySelector }) => {
      return pierceQuerySelector(element, selector);
    };
    static querySelectorAll = (element, selector, { pierceQuerySelectorAll }) => {
      return pierceQuerySelectorAll(element, selector);
    };
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/PQueryHandler.js
  init_dirname();
  init_buffer2();
  var PQueryHandler = class extends QueryHandler {
    static querySelectorAll = (element, selector, { pQuerySelectorAll }) => {
      return pQuerySelectorAll(element, selector);
    };
    static querySelector = (element, selector, { pQuerySelector }) => {
      return pQuerySelector(element, selector);
    };
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/TextQueryHandler.js
  init_dirname();
  init_buffer2();
  var TextQueryHandler = class extends QueryHandler {
    static querySelectorAll = (element, selector, { textQuerySelectorAll }) => {
      return textQuerySelectorAll(element, selector);
    };
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/XPathQueryHandler.js
  init_dirname();
  init_buffer2();
  var XPathQueryHandler = class extends QueryHandler {
    static querySelectorAll = (element, selector, { xpathQuerySelectorAll }) => {
      return xpathQuerySelectorAll(element, selector);
    };
    static querySelector = (element, selector, { xpathQuerySelectorAll }) => {
      for (const result of xpathQuerySelectorAll(element, selector, 1)) {
        return result;
      }
      return null;
    };
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js
  var BUILTIN_QUERY_HANDLERS = {
    aria: ARIAQueryHandler,
    pierce: PierceQueryHandler,
    xpath: XPathQueryHandler,
    text: TextQueryHandler
  };
  var QUERY_SEPARATORS = ["=", "/"];
  function getQueryHandlerAndSelector(selector) {
    for (const handlerMap of [
      customQueryHandlers.names().map((name2) => {
        return [name2, customQueryHandlers.get(name2)];
      }),
      Object.entries(BUILTIN_QUERY_HANDLERS)
    ]) {
      for (const [name2, QueryHandler2] of handlerMap) {
        for (const separator of QUERY_SEPARATORS) {
          const prefix = `${name2}${separator}`;
          if (selector.startsWith(prefix)) {
            selector = selector.slice(prefix.length);
            return { updatedSelector: selector, QueryHandler: QueryHandler2 };
          }
        }
      }
    }
    return { updatedSelector: selector, QueryHandler: PQueryHandler };
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js
  init_util2();
  init_assert();
  init_decorators();
  var __runInitializers5 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i7 = 0; i7 < initializers.length; i7++) {
      value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate5 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f7) {
      if (f7 !== void 0 && typeof f7 !== "function")
        throw new TypeError("Function expected");
      return f7;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _4, done = false;
    for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
      var context2 = {};
      for (var p7 in contextIn)
        context2[p7] = p7 === "access" ? {} : contextIn[p7];
      for (var p7 in contextIn.access)
        context2.access[p7] = contextIn.access[p7];
      context2.addInitializer = function(f7) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f7 || null));
      };
      var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_4 = accept(result.get))
          descriptor.get = _4;
        if (_4 = accept(result.set))
          descriptor.set = _4;
        if (_4 = accept(result.init))
          initializers.unshift(_4);
      } else if (_4 = accept(result)) {
        if (kind === "field")
          initializers.unshift(_4);
        else
          descriptor[key] = _4;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource8 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async2) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources8 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail2(e9) {
        env.error = env.hasError ? new SuppressedError2(e9, env.error, "An error was suppressed during disposal.") : e9;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  var ElementHandle = (() => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _22, _32, _4, _5;
    let _classSuper = JSHandle;
    let _instanceExtraInitializers = [];
    let _getProperty_decorators;
    let _getProperties_decorators;
    let _jsonValue_decorators;
    let _$_decorators;
    let _$$_decorators;
    let _waitForSelector_decorators;
    let _isVisible_decorators;
    let _isHidden_decorators;
    let _toElement_decorators;
    let _clickablePoint_decorators;
    let _hover_decorators;
    let _click_decorators;
    let _drag_decorators;
    let _dragEnter_decorators;
    let _dragOver_decorators;
    let _drop_decorators;
    let _dragAndDrop_decorators;
    let _select_decorators;
    let _tap_decorators;
    let _touchStart_decorators;
    let _touchMove_decorators;
    let _touchEnd_decorators;
    let _focus_decorators;
    let _type_decorators;
    let _press_decorators;
    let _boundingBox_decorators;
    let _boxModel_decorators;
    let _screenshot_decorators;
    let _isIntersectingViewport_decorators;
    let _scrollIntoView_decorators;
    return class ElementHandle2 extends _classSuper {
      static {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
        _getProperty_decorators = [throwIfDisposed(), (_a = ElementHandle2).bindIsolatedHandle.bind(_a)];
        _getProperties_decorators = [throwIfDisposed(), (_b = ElementHandle2).bindIsolatedHandle.bind(_b)];
        _jsonValue_decorators = [throwIfDisposed(), (_c = ElementHandle2).bindIsolatedHandle.bind(_c)];
        _$_decorators = [throwIfDisposed(), (_d = ElementHandle2).bindIsolatedHandle.bind(_d)];
        _$$_decorators = [throwIfDisposed(), (_e = ElementHandle2).bindIsolatedHandle.bind(_e)];
        _waitForSelector_decorators = [throwIfDisposed(), (_f = ElementHandle2).bindIsolatedHandle.bind(_f)];
        _isVisible_decorators = [throwIfDisposed(), (_g = ElementHandle2).bindIsolatedHandle.bind(_g)];
        _isHidden_decorators = [throwIfDisposed(), (_h = ElementHandle2).bindIsolatedHandle.bind(_h)];
        _toElement_decorators = [throwIfDisposed(), (_j = ElementHandle2).bindIsolatedHandle.bind(_j)];
        _clickablePoint_decorators = [throwIfDisposed(), (_k = ElementHandle2).bindIsolatedHandle.bind(_k)];
        _hover_decorators = [throwIfDisposed(), (_l = ElementHandle2).bindIsolatedHandle.bind(_l)];
        _click_decorators = [throwIfDisposed(), (_m = ElementHandle2).bindIsolatedHandle.bind(_m)];
        _drag_decorators = [throwIfDisposed(), (_o = ElementHandle2).bindIsolatedHandle.bind(_o)];
        _dragEnter_decorators = [throwIfDisposed(), (_p = ElementHandle2).bindIsolatedHandle.bind(_p)];
        _dragOver_decorators = [throwIfDisposed(), (_q = ElementHandle2).bindIsolatedHandle.bind(_q)];
        _drop_decorators = [throwIfDisposed(), (_r = ElementHandle2).bindIsolatedHandle.bind(_r)];
        _dragAndDrop_decorators = [throwIfDisposed(), (_s = ElementHandle2).bindIsolatedHandle.bind(_s)];
        _select_decorators = [throwIfDisposed(), (_t = ElementHandle2).bindIsolatedHandle.bind(_t)];
        _tap_decorators = [throwIfDisposed(), (_u = ElementHandle2).bindIsolatedHandle.bind(_u)];
        _touchStart_decorators = [throwIfDisposed(), (_v = ElementHandle2).bindIsolatedHandle.bind(_v)];
        _touchMove_decorators = [throwIfDisposed(), (_w = ElementHandle2).bindIsolatedHandle.bind(_w)];
        _touchEnd_decorators = [throwIfDisposed(), (_x = ElementHandle2).bindIsolatedHandle.bind(_x)];
        _focus_decorators = [throwIfDisposed(), (_y = ElementHandle2).bindIsolatedHandle.bind(_y)];
        _type_decorators = [throwIfDisposed(), (_z = ElementHandle2).bindIsolatedHandle.bind(_z)];
        _press_decorators = [throwIfDisposed(), (_0 = ElementHandle2).bindIsolatedHandle.bind(_0)];
        _boundingBox_decorators = [throwIfDisposed(), (_1 = ElementHandle2).bindIsolatedHandle.bind(_1)];
        _boxModel_decorators = [throwIfDisposed(), (_22 = ElementHandle2).bindIsolatedHandle.bind(_22)];
        _screenshot_decorators = [throwIfDisposed(), (_32 = ElementHandle2).bindIsolatedHandle.bind(_32)];
        _isIntersectingViewport_decorators = [throwIfDisposed(), (_4 = ElementHandle2).bindIsolatedHandle.bind(_4)];
        _scrollIntoView_decorators = [throwIfDisposed(), (_5 = ElementHandle2).bindIsolatedHandle.bind(_5)];
        __esDecorate5(this, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _jsonValue_decorators, { kind: "method", name: "jsonValue", static: false, private: false, access: { has: (obj) => "jsonValue" in obj, get: (obj) => obj.jsonValue }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _isVisible_decorators, { kind: "method", name: "isVisible", static: false, private: false, access: { has: (obj) => "isVisible" in obj, get: (obj) => obj.isVisible }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _isHidden_decorators, { kind: "method", name: "isHidden", static: false, private: false, access: { has: (obj) => "isHidden" in obj, get: (obj) => obj.isHidden }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _toElement_decorators, { kind: "method", name: "toElement", static: false, private: false, access: { has: (obj) => "toElement" in obj, get: (obj) => obj.toElement }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _clickablePoint_decorators, { kind: "method", name: "clickablePoint", static: false, private: false, access: { has: (obj) => "clickablePoint" in obj, get: (obj) => obj.clickablePoint }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _drag_decorators, { kind: "method", name: "drag", static: false, private: false, access: { has: (obj) => "drag" in obj, get: (obj) => obj.drag }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _dragEnter_decorators, { kind: "method", name: "dragEnter", static: false, private: false, access: { has: (obj) => "dragEnter" in obj, get: (obj) => obj.dragEnter }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _dragOver_decorators, { kind: "method", name: "dragOver", static: false, private: false, access: { has: (obj) => "dragOver" in obj, get: (obj) => obj.dragOver }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _drop_decorators, { kind: "method", name: "drop", static: false, private: false, access: { has: (obj) => "drop" in obj, get: (obj) => obj.drop }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _dragAndDrop_decorators, { kind: "method", name: "dragAndDrop", static: false, private: false, access: { has: (obj) => "dragAndDrop" in obj, get: (obj) => obj.dragAndDrop }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _touchStart_decorators, { kind: "method", name: "touchStart", static: false, private: false, access: { has: (obj) => "touchStart" in obj, get: (obj) => obj.touchStart }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _touchMove_decorators, { kind: "method", name: "touchMove", static: false, private: false, access: { has: (obj) => "touchMove" in obj, get: (obj) => obj.touchMove }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _touchEnd_decorators, { kind: "method", name: "touchEnd", static: false, private: false, access: { has: (obj) => "touchEnd" in obj, get: (obj) => obj.touchEnd }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _press_decorators, { kind: "method", name: "press", static: false, private: false, access: { has: (obj) => "press" in obj, get: (obj) => obj.press }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _boundingBox_decorators, { kind: "method", name: "boundingBox", static: false, private: false, access: { has: (obj) => "boundingBox" in obj, get: (obj) => obj.boundingBox }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _boxModel_decorators, { kind: "method", name: "boxModel", static: false, private: false, access: { has: (obj) => "boxModel" in obj, get: (obj) => obj.boxModel }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _isIntersectingViewport_decorators, { kind: "method", name: "isIntersectingViewport", static: false, private: false, access: { has: (obj) => "isIntersectingViewport" in obj, get: (obj) => obj.isIntersectingViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate5(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: (obj) => "scrollIntoView" in obj, get: (obj) => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
        if (_metadata)
          Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      }
      /**
       * A given method will have it's `this` replaced with an isolated version of
       * `this` when decorated with this decorator.
       *
       * All changes of isolated `this` are reflected on the actual `this`.
       *
       * @internal
       */
      static bindIsolatedHandle(target, _6) {
        return async function(...args) {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            if (this.realm === this.frame.isolatedRealm()) {
              return await target.call(this, ...args);
            }
            const adoptedThis = __addDisposableResource8(env_1, await this.frame.isolatedRealm().adoptHandle(this), false);
            const result = await target.call(adoptedThis, ...args);
            if (result === adoptedThis) {
              return this;
            }
            if (result instanceof JSHandle) {
              return await this.realm.transferHandle(result);
            }
            if (Array.isArray(result)) {
              await Promise.all(result.map(async (item, index, result2) => {
                if (item instanceof JSHandle) {
                  result2[index] = await this.realm.transferHandle(item);
                }
              }));
            }
            if (result instanceof Map) {
              await Promise.all([...result.entries()].map(async ([key, value]) => {
                if (value instanceof JSHandle) {
                  result.set(key, await this.realm.transferHandle(value));
                }
              }));
            }
            return result;
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources8(env_1);
          }
        };
      }
      /**
       * @internal
       */
      handle = (__runInitializers5(this, _instanceExtraInitializers), void 0);
      /**
       * @internal
       */
      constructor(handle) {
        super();
        this.handle = handle;
        this[_isElementHandle] = true;
      }
      /**
       * @internal
       */
      get id() {
        return this.handle.id;
      }
      /**
       * @internal
       */
      get disposed() {
        return this.handle.disposed;
      }
      /**
       * @internal
       */
      async getProperty(propertyName) {
        return await this.handle.getProperty(propertyName);
      }
      /**
       * @internal
       */
      async getProperties() {
        return await this.handle.getProperties();
      }
      /**
       * @internal
       */
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.handle.evaluate(pageFunction, ...args);
      }
      /**
       * @internal
       */
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.handle.evaluateHandle(pageFunction, ...args);
      }
      /**
       * @internal
       */
      async jsonValue() {
        return await this.handle.jsonValue();
      }
      /**
       * @internal
       */
      toString() {
        return this.handle.toString();
      }
      /**
       * @internal
       */
      remoteObject() {
        return this.handle.remoteObject();
      }
      /**
       * @internal
       */
      dispose() {
        return this.handle.dispose();
      }
      /**
       * @internal
       */
      asElement() {
        return this;
      }
      /**
       * Queries the current element for an element matching the given selector.
       *
       * @param selector - The selector to query for.
       * @returns A {@link ElementHandle | element handle} to the first element
       * matching the given selector. Otherwise, `null`.
       */
      async $(selector) {
        const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
        return await QueryHandler2.queryOne(this, updatedSelector);
      }
      /**
       * Queries the current element for all elements matching the given selector.
       *
       * @param selector - The selector to query for.
       * @returns An array of {@link ElementHandle | element handles} that point to
       * elements matching the given selector.
       */
      async $$(selector) {
        const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
        return await AsyncIterableUtil.collect(QueryHandler2.queryAll(this, updatedSelector));
      }
      /**
       * Runs the given function on the first element matching the given selector in
       * the current element.
       *
       * If the given function returns a promise, then this method will wait till
       * the promise resolves.
       *
       * @example
       *
       * ```ts
       * const tweetHandle = await page.$('.tweet');
       * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(
       *   '100'
       * );
       * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(
       *   '10'
       * );
       * ```
       *
       * @param selector - The selector to query for.
       * @param pageFunction - The function to be evaluated in this element's page's
       * context. The first element matching the selector will be passed in as the
       * first argument.
       * @param args - Additional arguments to pass to `pageFunction`.
       * @returns A promise to the result of the function.
       */
      async $eval(selector, pageFunction, ...args) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
          pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
          const elementHandle = __addDisposableResource8(env_2, await this.$(selector), false);
          if (!elementHandle) {
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
          }
          return await elementHandle.evaluate(pageFunction, ...args);
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          __disposeResources8(env_2);
        }
      }
      /**
       * Runs the given function on an array of elements matching the given selector
       * in the current element.
       *
       * If the given function returns a promise, then this method will wait till
       * the promise resolves.
       *
       * @example
       * HTML:
       *
       * ```html
       * <div class="feed">
       *   <div class="tweet">Hello!</div>
       *   <div class="tweet">Hi!</div>
       * </div>
       * ```
       *
       * JavaScript:
       *
       * ```ts
       * const feedHandle = await page.$('.feed');
       * expect(
       *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))
       * ).toEqual(['Hello!', 'Hi!']);
       * ```
       *
       * @param selector - The selector to query for.
       * @param pageFunction - The function to be evaluated in the element's page's
       * context. An array of elements matching the given selector will be passed to
       * the function as its first argument.
       * @param args - Additional arguments to pass to `pageFunction`.
       * @returns A promise to the result of the function.
       */
      async $$eval(selector, pageFunction, ...args) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
          pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
          const results = await this.$$(selector);
          const elements = __addDisposableResource8(env_3, await this.evaluateHandle((_6, ...elements2) => {
            return elements2;
          }, ...results), false);
          const [result] = await Promise.all([
            elements.evaluate(pageFunction, ...args),
            ...results.map((results2) => {
              return results2.dispose();
            })
          ]);
          return result;
        } catch (e_3) {
          env_3.error = e_3;
          env_3.hasError = true;
        } finally {
          __disposeResources8(env_3);
        }
      }
      /**
       * Wait for an element matching the given selector to appear in the current
       * element.
       *
       * Unlike {@link Frame.waitForSelector}, this method does not work across
       * navigations or if the element is detached from DOM.
       *
       * @example
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       *
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   let currentURL;
       *   page
       *     .mainFrame()
       *     .waitForSelector('img')
       *     .then(() => console.log('First URL with image: ' + currentURL));
       *
       *   for (currentURL of [
       *     'https://example.com',
       *     'https://google.com',
       *     'https://bbc.com',
       *   ]) {
       *     await page.goto(currentURL);
       *   }
       *   await browser.close();
       * })();
       * ```
       *
       * @param selector - The selector to query and wait for.
       * @param options - Options for customizing waiting behavior.
       * @returns An element matching the given selector.
       * @throws Throws if an element matching the given selector doesn't appear.
       */
      async waitForSelector(selector, options = {}) {
        const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
        return await QueryHandler2.waitFor(this, updatedSelector, options);
      }
      async #checkVisibility(visibility) {
        return await this.evaluate(async (element, PuppeteerUtil, visibility2) => {
          return Boolean(PuppeteerUtil.checkVisibility(element, visibility2));
        }, LazyArg.create((context2) => {
          return context2.puppeteerUtil;
        }), visibility);
      }
      /**
       * Checks if an element is visible using the same mechanism as
       * {@link ElementHandle.waitForSelector}.
       */
      async isVisible() {
        return await this.#checkVisibility(true);
      }
      /**
       * Checks if an element is hidden using the same mechanism as
       * {@link ElementHandle.waitForSelector}.
       */
      async isHidden() {
        return await this.#checkVisibility(false);
      }
      /**
       * Converts the current handle to the given element type.
       *
       * @example
       *
       * ```ts
       * const element: ElementHandle<Element> = await page.$(
       *   '.class-name-of-anchor'
       * );
       * // DO NOT DISPOSE `element`, this will be always be the same handle.
       * const anchor: ElementHandle<HTMLAnchorElement> =
       *   await element.toElement('a');
       * ```
       *
       * @param tagName - The tag name of the desired element type.
       * @throws An error if the handle does not match. **The handle will not be
       * automatically disposed.**
       */
      async toElement(tagName) {
        const isMatchingTagName = await this.evaluate((node, tagName2) => {
          return node.nodeName === tagName2.toUpperCase();
        }, tagName);
        if (!isMatchingTagName) {
          throw new Error(`Element is not a(n) \`${tagName}\` element`);
        }
        return this;
      }
      /**
       * Returns the middle point within an element unless a specific offset is provided.
       */
      async clickablePoint(offset) {
        const box = await this.#clickableBox();
        if (!box) {
          throw new Error("Node is either not clickable or not an Element");
        }
        if (offset !== void 0) {
          return {
            x: box.x + offset.x,
            y: box.y + offset.y
          };
        }
        return {
          x: box.x + box.width / 2,
          y: box.y + box.height / 2
        };
      }
      /**
       * This method scrolls element into view if needed, and then
       * uses {@link Page} to hover over the center of the element.
       * If the element is detached from DOM, the method throws an error.
       */
      async hover() {
        await this.scrollIntoViewIfNeeded();
        const { x: x4, y: y6 } = await this.clickablePoint();
        await this.frame.page().mouse.move(x4, y6);
      }
      /**
       * This method scrolls element into view if needed, and then
       * uses {@link Page | Page.mouse} to click in the center of the element.
       * If the element is detached from DOM, the method throws an error.
       */
      async click(options = {}) {
        await this.scrollIntoViewIfNeeded();
        const { x: x4, y: y6 } = await this.clickablePoint(options.offset);
        await this.frame.page().mouse.click(x4, y6, options);
      }
      /**
       * Drags an element over the given element or point.
       *
       * @returns DEPRECATED. When drag interception is enabled, the drag payload is
       * returned.
       */
      async drag(target) {
        await this.scrollIntoViewIfNeeded();
        const page = this.frame.page();
        if (page.isDragInterceptionEnabled()) {
          const source2 = await this.clickablePoint();
          if (target instanceof ElementHandle2) {
            target = await target.clickablePoint();
          }
          return await page.mouse.drag(source2, target);
        }
        try {
          if (!page._isDragging) {
            page._isDragging = true;
            await this.hover();
            await page.mouse.down();
          }
          if (target instanceof ElementHandle2) {
            await target.hover();
          } else {
            await page.mouse.move(target.x, target.y);
          }
        } catch (error) {
          page._isDragging = false;
          throw error;
        }
      }
      /**
       * @deprecated Do not use. `dragenter` will automatically be performed during dragging.
       */
      async dragEnter(data = { items: [], dragOperationsMask: 1 }) {
        const page = this.frame.page();
        await this.scrollIntoViewIfNeeded();
        const target = await this.clickablePoint();
        await page.mouse.dragEnter(target, data);
      }
      /**
       * @deprecated Do not use. `dragover` will automatically be performed during dragging.
       */
      async dragOver(data = { items: [], dragOperationsMask: 1 }) {
        const page = this.frame.page();
        await this.scrollIntoViewIfNeeded();
        const target = await this.clickablePoint();
        await page.mouse.dragOver(target, data);
      }
      /**
       * @internal
       */
      async drop(dataOrElement = {
        items: [],
        dragOperationsMask: 1
      }) {
        const page = this.frame.page();
        if ("items" in dataOrElement) {
          await this.scrollIntoViewIfNeeded();
          const destination = await this.clickablePoint();
          await page.mouse.drop(destination, dataOrElement);
        } else {
          await dataOrElement.drag(this);
          page._isDragging = false;
          await page.mouse.up();
        }
      }
      /**
       * @deprecated Use `ElementHandle.drop` instead.
       */
      async dragAndDrop(target, options) {
        const page = this.frame.page();
        assert(page.isDragInterceptionEnabled(), "Drag Interception is not enabled!");
        await this.scrollIntoViewIfNeeded();
        const startPoint = await this.clickablePoint();
        const targetPoint = await target.clickablePoint();
        await page.mouse.dragAndDrop(startPoint, targetPoint, options);
      }
      /**
       * Triggers a `change` and `input` event once all the provided options have been
       * selected. If there's no `<select>` element matching `selector`, the method
       * throws an error.
       *
       * @example
       *
       * ```ts
       * handle.select('blue'); // single selection
       * handle.select('red', 'green', 'blue'); // multiple selections
       * ```
       *
       * @param values - Values of options to select. If the `<select>` has the
       * `multiple` attribute, all values are considered, otherwise only the first
       * one is taken into account.
       */
      async select(...values) {
        for (const value of values) {
          assert(isString3(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
        }
        return await this.evaluate((element, vals) => {
          const values2 = new Set(vals);
          if (!(element instanceof HTMLSelectElement)) {
            throw new Error("Element is not a <select> element.");
          }
          const selectedValues = /* @__PURE__ */ new Set();
          if (!element.multiple) {
            for (const option of element.options) {
              option.selected = false;
            }
            for (const option of element.options) {
              if (values2.has(option.value)) {
                option.selected = true;
                selectedValues.add(option.value);
                break;
              }
            }
          } else {
            for (const option of element.options) {
              option.selected = values2.has(option.value);
              if (option.selected) {
                selectedValues.add(option.value);
              }
            }
          }
          element.dispatchEvent(new Event("input", { bubbles: true }));
          element.dispatchEvent(new Event("change", { bubbles: true }));
          return [...selectedValues.values()];
        }, values);
      }
      /**
       * This method scrolls element into view if needed, and then uses
       * {@link Touchscreen.tap} to tap in the center of the element.
       * If the element is detached from DOM, the method throws an error.
       */
      async tap() {
        await this.scrollIntoViewIfNeeded();
        const { x: x4, y: y6 } = await this.clickablePoint();
        await this.frame.page().touchscreen.tap(x4, y6);
      }
      async touchStart() {
        await this.scrollIntoViewIfNeeded();
        const { x: x4, y: y6 } = await this.clickablePoint();
        await this.frame.page().touchscreen.touchStart(x4, y6);
      }
      async touchMove() {
        await this.scrollIntoViewIfNeeded();
        const { x: x4, y: y6 } = await this.clickablePoint();
        await this.frame.page().touchscreen.touchMove(x4, y6);
      }
      async touchEnd() {
        await this.scrollIntoViewIfNeeded();
        await this.frame.page().touchscreen.touchEnd();
      }
      /**
       * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
       */
      async focus() {
        await this.evaluate((element) => {
          if (!(element instanceof HTMLElement)) {
            throw new Error("Cannot focus non-HTMLElement");
          }
          return element.focus();
        });
      }
      /**
       * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and
       * `keyup` event for each character in the text.
       *
       * To press a special key, like `Control` or `ArrowDown`,
       * use {@link ElementHandle.press}.
       *
       * @example
       *
       * ```ts
       * await elementHandle.type('Hello'); // Types instantly
       * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
       * ```
       *
       * @example
       * An example of typing into a text field and then submitting the form:
       *
       * ```ts
       * const elementHandle = await page.$('input');
       * await elementHandle.type('some text');
       * await elementHandle.press('Enter');
       * ```
       *
       * @param options - Delay in milliseconds. Defaults to 0.
       */
      async type(text, options) {
        await this.focus();
        await this.frame.page().keyboard.type(text, options);
      }
      /**
       * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.
       *
       * @remarks
       * If `key` is a single character and no modifier keys besides `Shift`
       * are being held down, a `keypress`/`input` event will also be generated.
       * The `text` option can be specified to force an input event to be generated.
       *
       * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`
       * will type the text in upper case.
       *
       * @param key - Name of key to press, such as `ArrowLeft`.
       * See {@link KeyInput} for a list of all key names.
       */
      async press(key, options) {
        await this.focus();
        await this.frame.page().keyboard.press(key, options);
      }
      async #clickableBox() {
        const boxes = await this.evaluate((element) => {
          if (!(element instanceof Element)) {
            return null;
          }
          return [...element.getClientRects()].map((rect) => {
            return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
          });
        });
        if (!boxes?.length) {
          return null;
        }
        await this.#intersectBoundingBoxesWithFrame(boxes);
        let frame = this.frame;
        let parentFrame;
        while (parentFrame = frame?.parentFrame()) {
          const env_4 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource8(env_4, await frame.frameElement(), false);
            if (!handle) {
              throw new Error("Unsupported frame type");
            }
            const parentBox = await handle.evaluate((element) => {
              if (element.getClientRects().length === 0) {
                return null;
              }
              const rect = element.getBoundingClientRect();
              const style = window.getComputedStyle(element);
              return {
                left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
                top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
              };
            });
            if (!parentBox) {
              return null;
            }
            for (const box2 of boxes) {
              box2.x += parentBox.left;
              box2.y += parentBox.top;
            }
            await handle.#intersectBoundingBoxesWithFrame(boxes);
            frame = parentFrame;
          } catch (e_4) {
            env_4.error = e_4;
            env_4.hasError = true;
          } finally {
            __disposeResources8(env_4);
          }
        }
        const box = boxes.find((box2) => {
          return box2.width >= 1 && box2.height >= 1;
        });
        if (!box) {
          return null;
        }
        return {
          x: box.x,
          y: box.y,
          height: box.height,
          width: box.width
        };
      }
      async #intersectBoundingBoxesWithFrame(boxes) {
        const { documentWidth, documentHeight } = await this.frame.isolatedRealm().evaluate(() => {
          return {
            documentWidth: document.documentElement.clientWidth,
            documentHeight: document.documentElement.clientHeight
          };
        });
        for (const box of boxes) {
          intersectBoundingBox(box, documentWidth, documentHeight);
        }
      }
      /**
       * This method returns the bounding box of the element (relative to the main frame),
       * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
       * (example: `display: none`).
       */
      async boundingBox() {
        const box = await this.evaluate((element) => {
          if (!(element instanceof Element)) {
            return null;
          }
          if (element.getClientRects().length === 0) {
            return null;
          }
          const rect = element.getBoundingClientRect();
          return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        });
        if (!box) {
          return null;
        }
        const offset = await this.#getTopLeftCornerOfFrame();
        if (!offset) {
          return null;
        }
        return {
          x: box.x + offset.x,
          y: box.y + offset.y,
          height: box.height,
          width: box.width
        };
      }
      /**
       * This method returns boxes of the element,
       * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
       * (example: `display: none`).
       *
       * @remarks
       *
       * Boxes are represented as an array of points;
       * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
       */
      async boxModel() {
        const model = await this.evaluate((element) => {
          if (!(element instanceof Element)) {
            return null;
          }
          if (element.getClientRects().length === 0) {
            return null;
          }
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          const offsets = {
            padding: {
              left: parseInt(style.paddingLeft, 10),
              top: parseInt(style.paddingTop, 10),
              right: parseInt(style.paddingRight, 10),
              bottom: parseInt(style.paddingBottom, 10)
            },
            margin: {
              left: -parseInt(style.marginLeft, 10),
              top: -parseInt(style.marginTop, 10),
              right: -parseInt(style.marginRight, 10),
              bottom: -parseInt(style.marginBottom, 10)
            },
            border: {
              left: parseInt(style.borderLeft, 10),
              top: parseInt(style.borderTop, 10),
              right: parseInt(style.borderRight, 10),
              bottom: parseInt(style.borderBottom, 10)
            }
          };
          const border = [
            { x: rect.left, y: rect.top },
            { x: rect.left + rect.width, y: rect.top },
            { x: rect.left + rect.width, y: rect.top + rect.bottom },
            { x: rect.left, y: rect.top + rect.bottom }
          ];
          const padding = transformQuadWithOffsets(border, offsets.border);
          const content = transformQuadWithOffsets(padding, offsets.padding);
          const margin = transformQuadWithOffsets(border, offsets.margin);
          return {
            content,
            padding,
            border,
            margin,
            width: rect.width,
            height: rect.height
          };
          function transformQuadWithOffsets(quad, offsets2) {
            return [
              {
                x: quad[0].x + offsets2.left,
                y: quad[0].y + offsets2.top
              },
              {
                x: quad[1].x - offsets2.right,
                y: quad[1].y + offsets2.top
              },
              {
                x: quad[2].x - offsets2.right,
                y: quad[2].y - offsets2.bottom
              },
              {
                x: quad[3].x + offsets2.left,
                y: quad[3].y - offsets2.bottom
              }
            ];
          }
        });
        if (!model) {
          return null;
        }
        const offset = await this.#getTopLeftCornerOfFrame();
        if (!offset) {
          return null;
        }
        for (const attribute of [
          "content",
          "padding",
          "border",
          "margin"
        ]) {
          for (const point of model[attribute]) {
            point.x += offset.x;
            point.y += offset.y;
          }
        }
        return model;
      }
      async #getTopLeftCornerOfFrame() {
        const point = { x: 0, y: 0 };
        let frame = this.frame;
        let parentFrame;
        while (parentFrame = frame?.parentFrame()) {
          const env_5 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource8(env_5, await frame.frameElement(), false);
            if (!handle) {
              throw new Error("Unsupported frame type");
            }
            const parentBox = await handle.evaluate((element) => {
              if (element.getClientRects().length === 0) {
                return null;
              }
              const rect = element.getBoundingClientRect();
              const style = window.getComputedStyle(element);
              return {
                left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
                top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
              };
            });
            if (!parentBox) {
              return null;
            }
            point.x += parentBox.left;
            point.y += parentBox.top;
            frame = parentFrame;
          } catch (e_5) {
            env_5.error = e_5;
            env_5.hasError = true;
          } finally {
            __disposeResources8(env_5);
          }
        }
        return point;
      }
      async screenshot(options = {}) {
        const { scrollIntoView = true, clip } = options;
        let elementClip = await this.#nonEmptyVisibleBoundingBox();
        const page = this.frame.page();
        if (scrollIntoView) {
          await this.scrollIntoViewIfNeeded();
          elementClip = await this.#nonEmptyVisibleBoundingBox();
        }
        const [pageLeft, pageTop] = await this.evaluate(() => {
          if (!window.visualViewport) {
            throw new Error("window.visualViewport is not supported.");
          }
          return [
            window.visualViewport.pageLeft,
            window.visualViewport.pageTop
          ];
        });
        elementClip.x += pageLeft;
        elementClip.y += pageTop;
        if (clip) {
          elementClip.x += clip.x;
          elementClip.y += clip.y;
          elementClip.height = clip.height;
          elementClip.width = clip.width;
        }
        return await page.screenshot({ ...options, clip: elementClip });
      }
      async #nonEmptyVisibleBoundingBox() {
        const box = await this.boundingBox();
        assert(box, "Node is either not visible or not an HTMLElement");
        assert(box.width !== 0, "Node has 0 width.");
        assert(box.height !== 0, "Node has 0 height.");
        return box;
      }
      /**
       * @internal
       */
      async assertConnectedElement() {
        const error = await this.evaluate(async (element) => {
          if (!element.isConnected) {
            return "Node is detached from document";
          }
          if (element.nodeType !== Node.ELEMENT_NODE) {
            return "Node is not of type HTMLElement";
          }
          return;
        });
        if (error) {
          throw new Error(error);
        }
      }
      /**
       * @internal
       */
      async scrollIntoViewIfNeeded() {
        if (await this.isIntersectingViewport({
          threshold: 1
        })) {
          return;
        }
        await this.scrollIntoView();
      }
      /**
       * Resolves to true if the element is visible in the current viewport. If an
       * element is an SVG, we check if the svg owner element is in the viewport
       * instead. See https://crbug.com/963246.
       *
       * @param options - Threshold for the intersection between 0 (no intersection) and 1
       * (full intersection). Defaults to 1.
       */
      async isIntersectingViewport(options = {}) {
        const env_6 = { stack: [], error: void 0, hasError: false };
        try {
          await this.assertConnectedElement();
          const handle = await this.#asSVGElementHandle();
          const target = __addDisposableResource8(env_6, handle && await handle.#getOwnerSVGElement(), false);
          return await (target ?? this).evaluate(async (element, threshold) => {
            const visibleRatio = await new Promise((resolve3) => {
              const observer = new IntersectionObserver((entries) => {
                resolve3(entries[0].intersectionRatio);
                observer.disconnect();
              });
              observer.observe(element);
            });
            return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;
          }, options.threshold ?? 0);
        } catch (e_6) {
          env_6.error = e_6;
          env_6.hasError = true;
        } finally {
          __disposeResources8(env_6);
        }
      }
      /**
       * Scrolls the element into view using either the automation protocol client
       * or by calling element.scrollIntoView.
       */
      async scrollIntoView() {
        await this.assertConnectedElement();
        await this.evaluate(async (element) => {
          element.scrollIntoView({
            block: "center",
            inline: "center",
            behavior: "instant"
          });
        });
      }
      /**
       * Returns true if an element is an SVGElement (included svg, path, rect
       * etc.).
       */
      async #asSVGElementHandle() {
        if (await this.evaluate((element) => {
          return element instanceof SVGElement;
        })) {
          return this;
        } else {
          return null;
        }
      }
      async #getOwnerSVGElement() {
        return await this.evaluateHandle((element) => {
          if (element instanceof SVGSVGElement) {
            return element;
          }
          return element.ownerSVGElement;
        });
      }
    };
  })();
  function intersectBoundingBox(box, width, height) {
    box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);
    box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ElementHandle.js
  init_util2();
  init_assert();
  init_decorators();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/JSHandle.js
  init_dirname();
  init_buffer2();
  init_util2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/utils.js
  init_dirname();
  init_buffer2();
  init_util2();
  init_assert();
  function createEvaluationError(details) {
    let name2;
    let message;
    if (!details.exception) {
      name2 = "Error";
      message = details.text;
    } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
      return valueFromRemoteObject(details.exception);
    } else {
      const detail = getErrorDetails(details);
      name2 = detail.name;
      message = detail.message;
    }
    const messageHeight = message.split("\n").length;
    const error = new Error(message);
    error.name = name2;
    const stackLines = error.stack.split("\n");
    const messageLines = stackLines.splice(0, messageHeight);
    stackLines.shift();
    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
      for (const frame of details.stackTrace.callFrames.reverse()) {
        if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
          const url = PuppeteerURL.parse(frame.url);
          stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
        } else {
          stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
        }
        if (stackLines.length >= Error.stackTraceLimit) {
          break;
        }
      }
    }
    error.stack = [...messageLines, ...stackLines].join("\n");
    return error;
  }
  var getErrorDetails = (details) => {
    let name2 = "";
    let message;
    const lines = details.exception?.description?.split("\n    at ") ?? [];
    const size = Math.min(details.stackTrace?.callFrames.length ?? 0, lines.length - 1);
    lines.splice(-size, size);
    if (details.exception?.className) {
      name2 = details.exception.className;
    }
    message = lines.join("\n");
    if (name2 && message.startsWith(`${name2}: `)) {
      message = message.slice(name2.length + 2);
    }
    return { message, name: name2 };
  };
  function createClientError(details) {
    let name2;
    let message;
    if (!details.exception) {
      name2 = "Error";
      message = details.text;
    } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
      return valueFromRemoteObject(details.exception);
    } else {
      const detail = getErrorDetails(details);
      name2 = detail.name;
      message = detail.message;
    }
    const error = new Error(message);
    error.name = name2;
    const messageHeight = error.message.split("\n").length;
    const messageLines = error.stack.split("\n").splice(0, messageHeight);
    const stackLines = [];
    if (details.stackTrace) {
      for (const frame of details.stackTrace.callFrames) {
        stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
        if (stackLines.length >= Error.stackTraceLimit) {
          break;
        }
      }
    }
    error.stack = [...messageLines, ...stackLines].join("\n");
    return error;
  }
  function valueFromRemoteObject(remoteObject) {
    assert(!remoteObject.objectId, "Cannot extract value when objectId is given");
    if (remoteObject.unserializableValue) {
      if (remoteObject.type === "bigint") {
        return BigInt(remoteObject.unserializableValue.replace("n", ""));
      }
      switch (remoteObject.unserializableValue) {
        case "-0":
          return -0;
        case "NaN":
          return NaN;
        case "Infinity":
          return Infinity;
        case "-Infinity":
          return -Infinity;
        default:
          throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
      }
    }
    return remoteObject.value;
  }
  function addPageBinding(type, name2) {
    const callCdp = globalThis[name2];
    if (callCdp[Symbol.toStringTag] === "PuppeteerBinding") {
      return;
    }
    Object.assign(globalThis, {
      [name2](...args) {
        const callPuppeteer = globalThis[name2];
        callPuppeteer.args ??= /* @__PURE__ */ new Map();
        callPuppeteer.callbacks ??= /* @__PURE__ */ new Map();
        const seq = (callPuppeteer.lastSeq ?? 0) + 1;
        callPuppeteer.lastSeq = seq;
        callPuppeteer.args.set(seq, args);
        callCdp(JSON.stringify({
          type,
          name: name2,
          seq,
          args,
          isTrivial: !args.some((value) => {
            return value instanceof Node;
          })
        }));
        return new Promise((resolve3, reject) => {
          callPuppeteer.callbacks.set(seq, {
            resolve(value) {
              callPuppeteer.args.delete(seq);
              resolve3(value);
            },
            reject(value) {
              callPuppeteer.args.delete(seq);
              reject(value);
            }
          });
        });
      }
    });
    globalThis[name2][Symbol.toStringTag] = "PuppeteerBinding";
  }
  function pageBindingInitString(type, name2) {
    return evaluationString(addPageBinding, type, name2);
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/JSHandle.js
  var CdpJSHandle = class extends JSHandle {
    #disposed = false;
    #remoteObject;
    #world;
    constructor(world, remoteObject) {
      super();
      this.#world = world;
      this.#remoteObject = remoteObject;
    }
    get disposed() {
      return this.#disposed;
    }
    get realm() {
      return this.#world;
    }
    get client() {
      return this.realm.environment.client;
    }
    async jsonValue() {
      if (!this.#remoteObject.objectId) {
        return valueFromRemoteObject(this.#remoteObject);
      }
      const value = await this.evaluate((object) => {
        return object;
      });
      if (value === void 0) {
        throw new Error("Could not serialize referenced object");
      }
      return value;
    }
    /**
     * Either `null` or the handle itself if the handle is an
     * instance of {@link ElementHandle}.
     */
    asElement() {
      return null;
    }
    async dispose() {
      if (this.#disposed) {
        return;
      }
      this.#disposed = true;
      await releaseObject(this.client, this.#remoteObject);
    }
    toString() {
      if (!this.#remoteObject.objectId) {
        return "JSHandle:" + valueFromRemoteObject(this.#remoteObject);
      }
      const type = this.#remoteObject.subtype || this.#remoteObject.type;
      return "JSHandle@" + type;
    }
    get id() {
      return this.#remoteObject.objectId;
    }
    remoteObject() {
      return this.#remoteObject;
    }
  };
  async function releaseObject(client, remoteObject) {
    if (!remoteObject.objectId) {
      return;
    }
    await client.send("Runtime.releaseObject", { objectId: remoteObject.objectId }).catch((error) => {
      debugError(error);
    });
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ElementHandle.js
  var __runInitializers6 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i7 = 0; i7 < initializers.length; i7++) {
      value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate6 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f7) {
      if (f7 !== void 0 && typeof f7 !== "function")
        throw new TypeError("Function expected");
      return f7;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _4, done = false;
    for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
      var context2 = {};
      for (var p7 in contextIn)
        context2[p7] = p7 === "access" ? {} : contextIn[p7];
      for (var p7 in contextIn.access)
        context2.access[p7] = contextIn.access[p7];
      context2.addInitializer = function(f7) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f7 || null));
      };
      var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_4 = accept(result.get))
          descriptor.get = _4;
        if (_4 = accept(result.set))
          descriptor.set = _4;
        if (_4 = accept(result.init))
          initializers.unshift(_4);
      } else if (_4 = accept(result)) {
        if (kind === "field")
          initializers.unshift(_4);
        else
          descriptor[key] = _4;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var CdpElementHandle = (() => {
    var _a, _b;
    let _classSuper = ElementHandle;
    let _instanceExtraInitializers = [];
    let _contentFrame_decorators;
    let _scrollIntoView_decorators;
    let _uploadFile_decorators;
    let _autofill_decorators;
    return class CdpElementHandle extends _classSuper {
      static {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
        _contentFrame_decorators = [throwIfDisposed()];
        _scrollIntoView_decorators = [throwIfDisposed(), (_a = ElementHandle).bindIsolatedHandle.bind(_a)];
        _uploadFile_decorators = [throwIfDisposed(), (_b = ElementHandle).bindIsolatedHandle.bind(_b)];
        _autofill_decorators = [throwIfDisposed()];
        __esDecorate6(this, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: (obj) => "contentFrame" in obj, get: (obj) => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate6(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: (obj) => "scrollIntoView" in obj, get: (obj) => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate6(this, null, _uploadFile_decorators, { kind: "method", name: "uploadFile", static: false, private: false, access: { has: (obj) => "uploadFile" in obj, get: (obj) => obj.uploadFile }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate6(this, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: (obj) => "autofill" in obj, get: (obj) => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
        if (_metadata)
          Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      }
      constructor(world, remoteObject) {
        super(new CdpJSHandle(world, remoteObject));
        __runInitializers6(this, _instanceExtraInitializers);
      }
      get realm() {
        return this.handle.realm;
      }
      get client() {
        return this.handle.client;
      }
      remoteObject() {
        return this.handle.remoteObject();
      }
      get #frameManager() {
        return this.frame._frameManager;
      }
      get frame() {
        return this.realm.environment;
      }
      async contentFrame() {
        const nodeInfo = await this.client.send("DOM.describeNode", {
          objectId: this.id
        });
        if (typeof nodeInfo.node.frameId !== "string") {
          return null;
        }
        return this.#frameManager.frame(nodeInfo.node.frameId);
      }
      async scrollIntoView() {
        await this.assertConnectedElement();
        try {
          await this.client.send("DOM.scrollIntoViewIfNeeded", {
            objectId: this.id
          });
        } catch (error) {
          debugError(error);
          await super.scrollIntoView();
        }
      }
      async uploadFile(...filePaths) {
        const isMultiple = await this.evaluate((element) => {
          return element.multiple;
        });
        assert(filePaths.length <= 1 || isMultiple, "Multiple file uploads only work with <input type=file multiple>");
        let path2;
        try {
          path2 = await Promise.resolve().then(() => (init_path(), path_exports));
        } catch (error) {
          if (error instanceof TypeError) {
            throw new Error(`JSHandle#uploadFile can only be used in Node-like environments.`);
          }
          throw error;
        }
        const files = filePaths.map((filePath) => {
          if (path2.win32.isAbsolute(filePath) || path2.posix.isAbsolute(filePath)) {
            return filePath;
          } else {
            return path2.resolve(filePath);
          }
        });
        if (files.length === 0) {
          await this.evaluate((element) => {
            element.files = new DataTransfer().files;
            element.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
            element.dispatchEvent(new Event("change", { bubbles: true }));
          });
          return;
        }
        const { node: { backendNodeId } } = await this.client.send("DOM.describeNode", {
          objectId: this.id
        });
        await this.client.send("DOM.setFileInputFiles", {
          objectId: this.id,
          files,
          backendNodeId
        });
      }
      async autofill(data) {
        const nodeInfo = await this.client.send("DOM.describeNode", {
          objectId: this.handle.id
        });
        const fieldId = nodeInfo.node.backendNodeId;
        const frameId = this.frame._id;
        await this.client.send("Autofill.trigger", {
          fieldId,
          frameId,
          card: data.creditCard
        });
      }
    };
  })();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ExecutionContext.js
  var ExecutionContext = class {
    _client;
    _world;
    _contextId;
    _contextName;
    constructor(client, contextPayload, world) {
      this._client = client;
      this._world = world;
      this._contextId = contextPayload.id;
      if (contextPayload.name) {
        this._contextName = contextPayload.name;
      }
    }
    #bindingsInstalled = false;
    #puppeteerUtil;
    get puppeteerUtil() {
      let promise = Promise.resolve();
      if (!this.#bindingsInstalled) {
        promise = Promise.all([
          this.#installGlobalBinding(new Binding("__ariaQuerySelector", ARIAQueryHandler.queryOne)),
          this.#installGlobalBinding(new Binding("__ariaQuerySelectorAll", async (element, selector) => {
            const results = ARIAQueryHandler.queryAll(element, selector);
            return await element.realm.evaluateHandle((...elements) => {
              return elements;
            }, ...await AsyncIterableUtil.collect(results));
          }))
        ]);
        this.#bindingsInstalled = true;
      }
      scriptInjector.inject((script) => {
        if (this.#puppeteerUtil) {
          void this.#puppeteerUtil.then((handle) => {
            void handle.dispose();
          });
        }
        this.#puppeteerUtil = promise.then(() => {
          return this.evaluateHandle(script);
        });
      }, !this.#puppeteerUtil);
      return this.#puppeteerUtil;
    }
    async #installGlobalBinding(binding) {
      try {
        if (this._world) {
          this._world._bindings.set(binding.name, binding);
          await this._world._addBindingToContext(this, binding.name);
        }
      } catch {
      }
    }
    /**
     * Evaluates the given function.
     *
     * @example
     *
     * ```ts
     * const executionContext = await page.mainFrame().executionContext();
     * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;
     * console.log(result); // prints "56"
     * ```
     *
     * @example
     * A string can also be passed in instead of a function:
     *
     * ```ts
     * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
     * ```
     *
     * @example
     * Handles can also be passed as `args`. They resolve to their referenced object:
     *
     * ```ts
     * const oneHandle = await executionContext.evaluateHandle(() => 1);
     * const twoHandle = await executionContext.evaluateHandle(() => 2);
     * const result = await executionContext.evaluate(
     *   (a, b) => a + b,
     *   oneHandle,
     *   twoHandle
     * );
     * await oneHandle.dispose();
     * await twoHandle.dispose();
     * console.log(result); // prints '3'.
     * ```
     *
     * @param pageFunction - The function to evaluate.
     * @param args - Additional arguments to pass into the function.
     * @returns The result of evaluating the function. If the result is an object,
     * a vanilla object containing the serializable properties of the result is
     * returned.
     */
    async evaluate(pageFunction, ...args) {
      return await this.#evaluate(true, pageFunction, ...args);
    }
    /**
     * Evaluates the given function.
     *
     * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a
     * handle to the result of the function.
     *
     * This method may be better suited if the object cannot be serialized (e.g.
     * `Map`) and requires further manipulation.
     *
     * @example
     *
     * ```ts
     * const context = await page.mainFrame().executionContext();
     * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(
     *   () => Promise.resolve(self)
     * );
     * ```
     *
     * @example
     * A string can also be passed in instead of a function.
     *
     * ```ts
     * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');
     * ```
     *
     * @example
     * Handles can also be passed as `args`. They resolve to their referenced object:
     *
     * ```ts
     * const bodyHandle: ElementHandle<HTMLBodyElement> =
     *   await context.evaluateHandle(() => {
     *     return document.body;
     *   });
     * const stringHandle: JSHandle<string> = await context.evaluateHandle(
     *   body => body.innerHTML,
     *   body
     * );
     * console.log(await stringHandle.jsonValue()); // prints body's innerHTML
     * // Always dispose your garbage! :)
     * await bodyHandle.dispose();
     * await stringHandle.dispose();
     * ```
     *
     * @param pageFunction - The function to evaluate.
     * @param args - Additional arguments to pass into the function.
     * @returns A {@link JSHandle | handle} to the result of evaluating the
     * function. If the result is a `Node`, then this will return an
     * {@link ElementHandle | element handle}.
     */
    async evaluateHandle(pageFunction, ...args) {
      return await this.#evaluate(false, pageFunction, ...args);
    }
    async #evaluate(returnByValue, pageFunction, ...args) {
      const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ?? PuppeteerURL.INTERNAL_URL);
      if (isString3(pageFunction)) {
        const contextId = this._contextId;
        const expression = pageFunction;
        const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : `${expression}
${sourceUrlComment}
`;
        const { exceptionDetails: exceptionDetails2, result: remoteObject2 } = await this._client.send("Runtime.evaluate", {
          expression: expressionWithSourceUrl,
          contextId,
          returnByValue,
          awaitPromise: true,
          userGesture: true
        }).catch(rewriteError2);
        if (exceptionDetails2) {
          throw createEvaluationError(exceptionDetails2);
        }
        return returnByValue ? valueFromRemoteObject(remoteObject2) : createCdpHandle(this._world, remoteObject2);
      }
      const functionDeclaration = stringifyFunction(pageFunction);
      const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}
${sourceUrlComment}
`;
      let callFunctionOnPromise;
      try {
        callFunctionOnPromise = this._client.send("Runtime.callFunctionOn", {
          functionDeclaration: functionDeclarationWithSourceUrl,
          executionContextId: this._contextId,
          arguments: args.length ? await Promise.all(args.map(convertArgument.bind(this))) : [],
          returnByValue,
          awaitPromise: true,
          userGesture: true
        });
      } catch (error) {
        if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
          error.message += " Recursive objects are not allowed.";
        }
        throw error;
      }
      const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError2);
      if (exceptionDetails) {
        throw createEvaluationError(exceptionDetails);
      }
      return returnByValue ? valueFromRemoteObject(remoteObject) : createCdpHandle(this._world, remoteObject);
      async function convertArgument(arg) {
        if (arg instanceof LazyArg) {
          arg = await arg.get(this);
        }
        if (typeof arg === "bigint") {
          return { unserializableValue: `${arg.toString()}n` };
        }
        if (Object.is(arg, -0)) {
          return { unserializableValue: "-0" };
        }
        if (Object.is(arg, Infinity)) {
          return { unserializableValue: "Infinity" };
        }
        if (Object.is(arg, -Infinity)) {
          return { unserializableValue: "-Infinity" };
        }
        if (Object.is(arg, NaN)) {
          return { unserializableValue: "NaN" };
        }
        const objectHandle = arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle) ? arg : null;
        if (objectHandle) {
          if (objectHandle.realm !== this._world) {
            throw new Error("JSHandles can be evaluated only in the context they were created!");
          }
          if (objectHandle.disposed) {
            throw new Error("JSHandle is disposed!");
          }
          if (objectHandle.remoteObject().unserializableValue) {
            return {
              unserializableValue: objectHandle.remoteObject().unserializableValue
            };
          }
          if (!objectHandle.remoteObject().objectId) {
            return { value: objectHandle.remoteObject().value };
          }
          return { objectId: objectHandle.remoteObject().objectId };
        }
        return { value: arg };
      }
    }
  };
  var rewriteError2 = (error) => {
    if (error.message.includes("Object reference chain is too long")) {
      return { result: { type: "undefined" } };
    }
    if (error.message.includes("Object couldn't be returned by value")) {
      return { result: { type: "undefined" } };
    }
    if (error.message.endsWith("Cannot find context with specified id") || error.message.endsWith("Inspected target navigated or closed")) {
      throw new Error("Execution context was destroyed, most likely because of a navigation.");
    }
    throw error;
  };
  function createCdpHandle(realm, remoteObject) {
    if (remoteObject.subtype === "node") {
      return new CdpElementHandle(realm, remoteObject);
    }
    return new CdpJSHandle(realm, remoteObject);
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FirefoxTargetManager.js
  init_dirname();
  init_buffer2();
  init_CDPSession();
  init_EventEmitter();
  init_assert();
  init_Deferred();
  var FirefoxTargetManager = class extends EventEmitter2 {
    #connection;
    /**
     * Keeps track of the following events: 'Target.targetCreated',
     * 'Target.targetDestroyed'.
     *
     * A target becomes discovered when 'Target.targetCreated' is received.
     * A target is removed from this map once 'Target.targetDestroyed' is
     * received.
     *
     * `targetFilterCallback` has no effect on this map.
     */
    #discoveredTargetsByTargetId = /* @__PURE__ */ new Map();
    /**
     * Keeps track of targets that were created via 'Target.targetCreated'
     * and which one are not filtered out by `targetFilterCallback`.
     *
     * The target is removed from here once it's been destroyed.
     */
    #availableTargetsByTargetId = /* @__PURE__ */ new Map();
    /**
     * Tracks which sessions attach to which target.
     */
    #availableTargetsBySessionId = /* @__PURE__ */ new Map();
    #targetFilterCallback;
    #targetFactory;
    #attachedToTargetListenersBySession = /* @__PURE__ */ new WeakMap();
    #initializeDeferred = Deferred.create();
    #targetsIdsForInit = /* @__PURE__ */ new Set();
    constructor(connection, targetFactory, targetFilterCallback) {
      super();
      this.#connection = connection;
      this.#targetFilterCallback = targetFilterCallback;
      this.#targetFactory = targetFactory;
      this.#connection.on("Target.targetCreated", this.#onTargetCreated);
      this.#connection.on("Target.targetDestroyed", this.#onTargetDestroyed);
      this.#connection.on(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
      this.setupAttachmentListeners(this.#connection);
    }
    setupAttachmentListeners(session) {
      const listener = (event) => {
        return this.#onAttachedToTarget(session, event);
      };
      assert(!this.#attachedToTargetListenersBySession.has(session));
      this.#attachedToTargetListenersBySession.set(session, listener);
      session.on("Target.attachedToTarget", listener);
    }
    #onSessionDetached = (session) => {
      this.removeSessionListeners(session);
      this.#availableTargetsBySessionId.delete(session.id());
    };
    removeSessionListeners(session) {
      if (this.#attachedToTargetListenersBySession.has(session)) {
        session.off("Target.attachedToTarget", this.#attachedToTargetListenersBySession.get(session));
        this.#attachedToTargetListenersBySession.delete(session);
      }
    }
    getAvailableTargets() {
      return this.#availableTargetsByTargetId;
    }
    dispose() {
      this.#connection.off("Target.targetCreated", this.#onTargetCreated);
      this.#connection.off("Target.targetDestroyed", this.#onTargetDestroyed);
    }
    async initialize() {
      await this.#connection.send("Target.setDiscoverTargets", {
        discover: true,
        filter: [{}]
      });
      this.#targetsIdsForInit = new Set(this.#discoveredTargetsByTargetId.keys());
      await this.#initializeDeferred.valueOrThrow();
    }
    #onTargetCreated = async (event) => {
      if (this.#discoveredTargetsByTargetId.has(event.targetInfo.targetId)) {
        return;
      }
      this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
      if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
        const target2 = this.#targetFactory(event.targetInfo, void 0);
        target2._initialize();
        this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target2);
        this.#finishInitializationIfReady(target2._targetId);
        return;
      }
      const target = this.#targetFactory(event.targetInfo, void 0);
      if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {
        this.#finishInitializationIfReady(event.targetInfo.targetId);
        return;
      }
      target._initialize();
      this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target);
      this.emit("targetAvailable", target);
      this.#finishInitializationIfReady(target._targetId);
    };
    #onTargetDestroyed = (event) => {
      this.#discoveredTargetsByTargetId.delete(event.targetId);
      this.#finishInitializationIfReady(event.targetId);
      const target = this.#availableTargetsByTargetId.get(event.targetId);
      if (target) {
        this.emit("targetGone", target);
        this.#availableTargetsByTargetId.delete(event.targetId);
      }
    };
    #onAttachedToTarget = async (parentSession, event) => {
      const targetInfo = event.targetInfo;
      const session = this.#connection.session(event.sessionId);
      if (!session) {
        throw new Error(`Session ${event.sessionId} was not created.`);
      }
      const target = this.#availableTargetsByTargetId.get(targetInfo.targetId);
      assert(target, `Target ${targetInfo.targetId} is missing`);
      session._setTarget(target);
      this.setupAttachmentListeners(session);
      this.#availableTargetsBySessionId.set(session.id(), this.#availableTargetsByTargetId.get(targetInfo.targetId));
      parentSession.emit(CDPSessionEvent.Ready, session);
    };
    #finishInitializationIfReady(targetId) {
      this.#targetsIdsForInit.delete(targetId);
      if (this.#targetsIdsForInit.size === 0) {
        this.#initializeDeferred.resolve();
      }
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameManager.js
  init_dirname();
  init_buffer2();
  init_CDPSession();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Frame.js
  init_dirname();
  init_buffer2();
  init_EventEmitter();
  init_util2();
  init_assert();
  init_decorators();
  var __runInitializers7 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i7 = 0; i7 < initializers.length; i7++) {
      value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate7 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f7) {
      if (f7 !== void 0 && typeof f7 !== "function")
        throw new TypeError("Function expected");
      return f7;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _4, done = false;
    for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
      var context2 = {};
      for (var p7 in contextIn)
        context2[p7] = p7 === "access" ? {} : contextIn[p7];
      for (var p7 in contextIn.access)
        context2.access[p7] = contextIn.access[p7];
      context2.addInitializer = function(f7) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f7 || null));
      };
      var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_4 = accept(result.get))
          descriptor.get = _4;
        if (_4 = accept(result.set))
          descriptor.set = _4;
        if (_4 = accept(result.init))
          initializers.unshift(_4);
      } else if (_4 = accept(result)) {
        if (kind === "field")
          initializers.unshift(_4);
        else
          descriptor[key] = _4;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource9 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async2) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources9 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail2(e9) {
        env.error = env.hasError ? new SuppressedError2(e9, env.error, "An error was suppressed during disposal.") : e9;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  var FrameEvent;
  (function(FrameEvent2) {
    FrameEvent2.FrameNavigated = Symbol("Frame.FrameNavigated");
    FrameEvent2.FrameSwapped = Symbol("Frame.FrameSwapped");
    FrameEvent2.LifecycleEvent = Symbol("Frame.LifecycleEvent");
    FrameEvent2.FrameNavigatedWithinDocument = Symbol("Frame.FrameNavigatedWithinDocument");
    FrameEvent2.FrameDetached = Symbol("Frame.FrameDetached");
    FrameEvent2.FrameSwappedByActivation = Symbol("Frame.FrameSwappedByActivation");
  })(FrameEvent || (FrameEvent = {}));
  var throwIfDetached = throwIfDisposed((frame) => {
    return `Attempted to use detached Frame '${frame._id}'.`;
  });
  var Frame = (() => {
    let _classSuper = EventEmitter2;
    let _instanceExtraInitializers = [];
    let _frameElement_decorators;
    let _evaluateHandle_decorators;
    let _evaluate_decorators;
    let _locator_decorators;
    let _$_decorators;
    let _$$_decorators;
    let _$eval_decorators;
    let _$$eval_decorators;
    let _waitForSelector_decorators;
    let _waitForFunction_decorators;
    let _content_decorators;
    let _addScriptTag_decorators;
    let _addStyleTag_decorators;
    let _click_decorators;
    let _focus_decorators;
    let _hover_decorators;
    let _select_decorators;
    let _tap_decorators;
    let _type_decorators;
    let _title_decorators;
    return class Frame extends _classSuper {
      static {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
        _frameElement_decorators = [throwIfDetached];
        _evaluateHandle_decorators = [throwIfDetached];
        _evaluate_decorators = [throwIfDetached];
        _locator_decorators = [throwIfDetached];
        _$_decorators = [throwIfDetached];
        _$$_decorators = [throwIfDetached];
        _$eval_decorators = [throwIfDetached];
        _$$eval_decorators = [throwIfDetached];
        _waitForSelector_decorators = [throwIfDetached];
        _waitForFunction_decorators = [throwIfDetached];
        _content_decorators = [throwIfDetached];
        _addScriptTag_decorators = [throwIfDetached];
        _addStyleTag_decorators = [throwIfDetached];
        _click_decorators = [throwIfDetached];
        _focus_decorators = [throwIfDetached];
        _hover_decorators = [throwIfDetached];
        _select_decorators = [throwIfDetached];
        _tap_decorators = [throwIfDetached];
        _type_decorators = [throwIfDetached];
        _title_decorators = [throwIfDetached];
        __esDecorate7(this, null, _frameElement_decorators, { kind: "method", name: "frameElement", static: false, private: false, access: { has: (obj) => "frameElement" in obj, get: (obj) => obj.frameElement }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _evaluateHandle_decorators, { kind: "method", name: "evaluateHandle", static: false, private: false, access: { has: (obj) => "evaluateHandle" in obj, get: (obj) => obj.evaluateHandle }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: (obj) => "evaluate" in obj, get: (obj) => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _locator_decorators, { kind: "method", name: "locator", static: false, private: false, access: { has: (obj) => "locator" in obj, get: (obj) => obj.locator }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _$eval_decorators, { kind: "method", name: "$eval", static: false, private: false, access: { has: (obj) => "$eval" in obj, get: (obj) => obj.$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _$$eval_decorators, { kind: "method", name: "$$eval", static: false, private: false, access: { has: (obj) => "$$eval" in obj, get: (obj) => obj.$$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _waitForFunction_decorators, { kind: "method", name: "waitForFunction", static: false, private: false, access: { has: (obj) => "waitForFunction" in obj, get: (obj) => obj.waitForFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _content_decorators, { kind: "method", name: "content", static: false, private: false, access: { has: (obj) => "content" in obj, get: (obj) => obj.content }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _addScriptTag_decorators, { kind: "method", name: "addScriptTag", static: false, private: false, access: { has: (obj) => "addScriptTag" in obj, get: (obj) => obj.addScriptTag }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _addStyleTag_decorators, { kind: "method", name: "addStyleTag", static: false, private: false, access: { has: (obj) => "addStyleTag" in obj, get: (obj) => obj.addStyleTag }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate7(this, null, _title_decorators, { kind: "method", name: "title", static: false, private: false, access: { has: (obj) => "title" in obj, get: (obj) => obj.title }, metadata: _metadata }, null, _instanceExtraInitializers);
        if (_metadata)
          Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      }
      /**
       * @internal
       */
      _id = (__runInitializers7(this, _instanceExtraInitializers), void 0);
      /**
       * @internal
       */
      _parentId;
      /**
       * @internal
       */
      _name;
      /**
       * @internal
       */
      _hasStartedLoading = false;
      /**
       * @internal
       */
      constructor() {
        super();
      }
      #_document;
      /**
       * @internal
       */
      #document() {
        if (!this.#_document) {
          this.#_document = this.isolatedRealm().evaluateHandle(() => {
            return document;
          }).then((handle) => {
            return this.mainRealm().transferHandle(handle);
          });
        }
        return this.#_document;
      }
      /**
       * Used to clear the document handle that has been destroyed.
       *
       * @internal
       */
      clearDocumentHandle() {
        this.#_document = void 0;
      }
      /**
       * @returns The frame element associated with this frame (if any).
       */
      async frameElement() {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const parentFrame = this.parentFrame();
          if (!parentFrame) {
            return null;
          }
          const list = __addDisposableResource9(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {
            return document.querySelectorAll("iframe,frame");
          }), false);
          for await (const iframe_1 of transposeIterableHandle(list)) {
            const env_2 = { stack: [], error: void 0, hasError: false };
            try {
              const iframe = __addDisposableResource9(env_2, iframe_1, false);
              const frame = await iframe.contentFrame();
              if (frame?._id === this._id) {
                return iframe.move();
              }
            } catch (e_1) {
              env_2.error = e_1;
              env_2.hasError = true;
            } finally {
              __disposeResources9(env_2);
            }
          }
          return null;
        } catch (e_2) {
          env_1.error = e_2;
          env_1.hasError = true;
        } finally {
          __disposeResources9(env_1);
        }
      }
      /**
       * Behaves identically to {@link Page.evaluateHandle} except it's run within
       * the context of this frame.
       *
       * @see {@link Page.evaluateHandle} for details.
       */
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.mainRealm().evaluateHandle(pageFunction, ...args);
      }
      /**
       * Behaves identically to {@link Page.evaluate} except it's run within
       * the context of this frame.
       *
       * @see {@link Page.evaluate} for details.
       */
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.mainRealm().evaluate(pageFunction, ...args);
      }
      /**
       * @internal
       */
      locator(selectorOrFunc) {
        if (typeof selectorOrFunc === "string") {
          return NodeLocator.create(this, selectorOrFunc);
        } else {
          return FunctionLocator.create(this, selectorOrFunc);
        }
      }
      /**
       * Queries the frame for an element matching the given selector.
       *
       * @param selector - The selector to query for.
       * @returns A {@link ElementHandle | element handle} to the first element
       * matching the given selector. Otherwise, `null`.
       */
      async $(selector) {
        const document2 = await this.#document();
        return await document2.$(selector);
      }
      /**
       * Queries the frame for all elements matching the given selector.
       *
       * @param selector - The selector to query for.
       * @returns An array of {@link ElementHandle | element handles} that point to
       * elements matching the given selector.
       */
      async $$(selector) {
        const document2 = await this.#document();
        return await document2.$$(selector);
      }
      /**
       * Runs the given function on the first element matching the given selector in
       * the frame.
       *
       * If the given function returns a promise, then this method will wait till
       * the promise resolves.
       *
       * @example
       *
       * ```ts
       * const searchValue = await frame.$eval('#search', el => el.value);
       * ```
       *
       * @param selector - The selector to query for.
       * @param pageFunction - The function to be evaluated in the frame's context.
       * The first element matching the selector will be passed to the function as
       * its first argument.
       * @param args - Additional arguments to pass to `pageFunction`.
       * @returns A promise to the result of the function.
       */
      async $eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
        const document2 = await this.#document();
        return await document2.$eval(selector, pageFunction, ...args);
      }
      /**
       * Runs the given function on an array of elements matching the given selector
       * in the frame.
       *
       * If the given function returns a promise, then this method will wait till
       * the promise resolves.
       *
       * @example
       *
       * ```ts
       * const divsCounts = await frame.$$eval('div', divs => divs.length);
       * ```
       *
       * @param selector - The selector to query for.
       * @param pageFunction - The function to be evaluated in the frame's context.
       * An array of elements matching the given selector will be passed to the
       * function as its first argument.
       * @param args - Additional arguments to pass to `pageFunction`.
       * @returns A promise to the result of the function.
       */
      async $$eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
        const document2 = await this.#document();
        return await document2.$$eval(selector, pageFunction, ...args);
      }
      /**
       * Waits for an element matching the given selector to appear in the frame.
       *
       * This method works across navigations.
       *
       * @example
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       *
       * (async () => {
       *   const browser = await puppeteer.launch();
       *   const page = await browser.newPage();
       *   let currentURL;
       *   page
       *     .mainFrame()
       *     .waitForSelector('img')
       *     .then(() => console.log('First URL with image: ' + currentURL));
       *
       *   for (currentURL of [
       *     'https://example.com',
       *     'https://google.com',
       *     'https://bbc.com',
       *   ]) {
       *     await page.goto(currentURL);
       *   }
       *   await browser.close();
       * })();
       * ```
       *
       * @param selector - The selector to query and wait for.
       * @param options - Options for customizing waiting behavior.
       * @returns An element matching the given selector.
       * @throws Throws if an element matching the given selector doesn't appear.
       */
      async waitForSelector(selector, options = {}) {
        const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
        return await QueryHandler2.waitFor(this, updatedSelector, options);
      }
      /**
       * @example
       * The `waitForFunction` can be used to observe viewport size change:
       *
       * ```ts
       * import puppeteer from 'puppeteer';
       *
       * (async () => {
       * .  const browser = await puppeteer.launch();
       * .  const page = await browser.newPage();
       * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
       * .  page.setViewport({width: 50, height: 50});
       * .  await watchDog;
       * .  await browser.close();
       * })();
       * ```
       *
       * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
       *
       * ```ts
       * const selector = '.foo';
       * await frame.waitForFunction(
       *   selector => !!document.querySelector(selector),
       *   {}, // empty options object
       *   selector
       * );
       * ```
       *
       * @param pageFunction - the function to evaluate in the frame context.
       * @param options - options to configure the polling method and timeout.
       * @param args - arguments to pass to the `pageFunction`.
       * @returns the promise which resolve when the `pageFunction` returns a truthy value.
       */
      async waitForFunction(pageFunction, options = {}, ...args) {
        return await this.mainRealm().waitForFunction(pageFunction, options, ...args);
      }
      /**
       * The full HTML contents of the frame, including the DOCTYPE.
       */
      async content() {
        return await this.evaluate(() => {
          let content = "";
          for (const node of document.childNodes) {
            switch (node) {
              case document.documentElement:
                content += document.documentElement.outerHTML;
                break;
              default:
                content += new XMLSerializer().serializeToString(node);
                break;
            }
          }
          return content;
        });
      }
      /**
       * @internal
       */
      async setFrameContent(content) {
        return await this.evaluate((html) => {
          document.open();
          document.write(html);
          document.close();
        }, content);
      }
      /**
       * The frame's `name` attribute as specified in the tag.
       *
       * @remarks
       * If the name is empty, it returns the `id` attribute instead.
       *
       * @remarks
       * This value is calculated once when the frame is created, and will not
       * update if the attribute is changed later.
       *
       * @deprecated Use
       *
       * ```ts
       * const element = await frame.frameElement();
       * const nameOrId = await element.evaluate(frame => frame.name ?? frame.id);
       * ```
       */
      name() {
        return this._name || "";
      }
      /**
       * Is`true` if the frame has been detached. Otherwise, `false`.
       *
       * @deprecated Use the `detached` getter.
       */
      isDetached() {
        return this.detached;
      }
      /**
       * @internal
       */
      get disposed() {
        return this.detached;
      }
      /**
       * Adds a `<script>` tag into the page with the desired url or content.
       *
       * @param options - Options for the script.
       * @returns An {@link ElementHandle | element handle} to the injected
       * `<script>` element.
       */
      async addScriptTag(options) {
        let { content = "", type } = options;
        const { path: path2 } = options;
        if (+!!options.url + +!!path2 + +!!content !== 1) {
          throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
        }
        if (path2) {
          const fs3 = await importFSPromises();
          content = await fs3.readFile(path2, "utf8");
          content += `//# sourceURL=${path2.replace(/\n/g, "")}`;
        }
        type = type ?? "text/javascript";
        return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, id, type: type2, content: content2 }) => {
          return await new Promise((resolve3, reject) => {
            const script = document.createElement("script");
            script.type = type2;
            script.text = content2;
            script.addEventListener("error", (event) => {
              reject(new Error(event.message ?? "Could not load script"));
            }, { once: true });
            if (id) {
              script.id = id;
            }
            if (url) {
              script.src = url;
              script.addEventListener("load", () => {
                resolve3(script);
              }, { once: true });
              document.head.appendChild(script);
            } else {
              document.head.appendChild(script);
              resolve3(script);
            }
          });
        }, { ...options, type, content }));
      }
      /**
       * @internal
       */
      async addStyleTag(options) {
        let { content = "" } = options;
        const { path: path2 } = options;
        if (+!!options.url + +!!path2 + +!!content !== 1) {
          throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
        }
        if (path2) {
          const fs3 = await importFSPromises();
          content = await fs3.readFile(path2, "utf8");
          content += "/*# sourceURL=" + path2.replace(/\n/g, "") + "*/";
          options.content = content;
        }
        return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, content: content2 }) => {
          return await new Promise((resolve3, reject) => {
            let element;
            if (!url) {
              element = document.createElement("style");
              element.appendChild(document.createTextNode(content2));
            } else {
              const link3 = document.createElement("link");
              link3.rel = "stylesheet";
              link3.href = url;
              element = link3;
            }
            element.addEventListener("load", () => {
              resolve3(element);
            }, { once: true });
            element.addEventListener("error", (event) => {
              reject(new Error(event.message ?? "Could not load style"));
            }, { once: true });
            document.head.appendChild(element);
            return element;
          });
        }, options));
      }
      /**
       * Clicks the first element found that matches `selector`.
       *
       * @remarks
       * If `click()` triggers a navigation event and there's a separate
       * `page.waitForNavigation()` promise to be resolved, you may end up with a
       * race condition that yields unexpected results. The correct pattern for
       * click and wait for navigation is the following:
       *
       * ```ts
       * const [response] = await Promise.all([
       *   page.waitForNavigation(waitOptions),
       *   frame.click(selector, clickOptions),
       * ]);
       * ```
       *
       * @param selector - The selector to query for.
       */
      async click(selector, options = {}) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource9(env_3, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          await handle.click(options);
          await handle.dispose();
        } catch (e_3) {
          env_3.error = e_3;
          env_3.hasError = true;
        } finally {
          __disposeResources9(env_3);
        }
      }
      /**
       * Focuses the first element that matches the `selector`.
       *
       * @param selector - The selector to query for.
       * @throws Throws if there's no element matching `selector`.
       */
      async focus(selector) {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource9(env_4, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          await handle.focus();
        } catch (e_4) {
          env_4.error = e_4;
          env_4.hasError = true;
        } finally {
          __disposeResources9(env_4);
        }
      }
      /**
       * Hovers the pointer over the center of the first element that matches the
       * `selector`.
       *
       * @param selector - The selector to query for.
       * @throws Throws if there's no element matching `selector`.
       */
      async hover(selector) {
        const env_5 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource9(env_5, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          await handle.hover();
        } catch (e_5) {
          env_5.error = e_5;
          env_5.hasError = true;
        } finally {
          __disposeResources9(env_5);
        }
      }
      /**
       * Selects a set of value on the first `<select>` element that matches the
       * `selector`.
       *
       * @example
       *
       * ```ts
       * frame.select('select#colors', 'blue'); // single selection
       * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
       * ```
       *
       * @param selector - The selector to query for.
       * @param values - The array of values to select. If the `<select>` has the
       * `multiple` attribute, all values are considered, otherwise only the first
       * one is taken into account.
       * @returns the list of values that were successfully selected.
       * @throws Throws if there's no `<select>` matching `selector`.
       */
      async select(selector, ...values) {
        const env_6 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource9(env_6, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          return await handle.select(...values);
        } catch (e_6) {
          env_6.error = e_6;
          env_6.hasError = true;
        } finally {
          __disposeResources9(env_6);
        }
      }
      /**
       * Taps the first element that matches the `selector`.
       *
       * @param selector - The selector to query for.
       * @throws Throws if there's no element matching `selector`.
       */
      async tap(selector) {
        const env_7 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource9(env_7, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          await handle.tap();
        } catch (e_7) {
          env_7.error = e_7;
          env_7.hasError = true;
        } finally {
          __disposeResources9(env_7);
        }
      }
      /**
       * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
       * in the text.
       *
       * @remarks
       * To press a special key, like `Control` or `ArrowDown`, use
       * {@link Keyboard.press}.
       *
       * @example
       *
       * ```ts
       * await frame.type('#mytextarea', 'Hello'); // Types instantly
       * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
       * ```
       *
       * @param selector - the selector for the element to type into. If there are
       * multiple the first will be used.
       * @param text - text to type into the element
       * @param options - takes one option, `delay`, which sets the time to wait
       * between key presses in milliseconds. Defaults to `0`.
       */
      async type(selector, text, options) {
        const env_8 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource9(env_8, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          await handle.type(text, options);
        } catch (e_8) {
          env_8.error = e_8;
          env_8.hasError = true;
        } finally {
          __disposeResources9(env_8);
        }
      }
      /**
       * The frame's title.
       */
      async title() {
        return await this.isolatedRealm().evaluate(() => {
          return document.title;
        });
      }
    };
  })();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameManager.js
  init_EventEmitter();
  init_util2();
  init_assert();
  init_Deferred();
  init_disposable();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/DeviceRequestPrompt.js
  init_dirname();
  init_buffer2();
  init_assert();
  init_Deferred();
  var DeviceRequestPromptDevice = class {
    /**
     * Device id during a prompt.
     */
    id;
    /**
     * Device name as it appears in a prompt.
     */
    name;
    /**
     * @internal
     */
    constructor(id, name2) {
      this.id = id;
      this.name = name2;
    }
  };
  var DeviceRequestPrompt = class {
    #client;
    #timeoutSettings;
    #id;
    #handled = false;
    #updateDevicesHandle = this.#updateDevices.bind(this);
    #waitForDevicePromises = /* @__PURE__ */ new Set();
    /**
     * Current list of selectable devices.
     */
    devices = [];
    /**
     * @internal
     */
    constructor(client, timeoutSettings, firstEvent) {
      this.#client = client;
      this.#timeoutSettings = timeoutSettings;
      this.#id = firstEvent.id;
      this.#client.on("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
      this.#client.on("Target.detachedFromTarget", () => {
        this.#client = null;
      });
      this.#updateDevices(firstEvent);
    }
    #updateDevices(event) {
      if (event.id !== this.#id) {
        return;
      }
      for (const rawDevice of event.devices) {
        if (this.devices.some((device) => {
          return device.id === rawDevice.id;
        })) {
          continue;
        }
        const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);
        this.devices.push(newDevice);
        for (const waitForDevicePromise of this.#waitForDevicePromises) {
          if (waitForDevicePromise.filter(newDevice)) {
            waitForDevicePromise.promise.resolve(newDevice);
          }
        }
      }
    }
    /**
     * Resolve to the first device in the prompt matching a filter.
     */
    async waitForDevice(filter2, options = {}) {
      for (const device of this.devices) {
        if (filter2(device)) {
          return device;
        }
      }
      const { timeout: timeout2 = this.#timeoutSettings.timeout() } = options;
      const deferred = Deferred.create({
        message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${timeout2}ms exceeded`,
        timeout: timeout2
      });
      const handle = { filter: filter2, promise: deferred };
      this.#waitForDevicePromises.add(handle);
      try {
        return await deferred.valueOrThrow();
      } finally {
        this.#waitForDevicePromises.delete(handle);
      }
    }
    /**
     * Select a device in the prompt's list.
     */
    async select(device) {
      assert(this.#client !== null, "Cannot select device through detached session!");
      assert(this.devices.includes(device), "Cannot select unknown device!");
      assert(!this.#handled, "Cannot select DeviceRequestPrompt which is already handled!");
      this.#client.off("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
      this.#handled = true;
      return await this.#client.send("DeviceAccess.selectPrompt", {
        id: this.#id,
        deviceId: device.id
      });
    }
    /**
     * Cancel the prompt.
     */
    async cancel() {
      assert(this.#client !== null, "Cannot cancel prompt through detached session!");
      assert(!this.#handled, "Cannot cancel DeviceRequestPrompt which is already handled!");
      this.#client.off("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
      this.#handled = true;
      return await this.#client.send("DeviceAccess.cancelPrompt", { id: this.#id });
    }
  };
  var DeviceRequestPromptManager = class {
    #client;
    #timeoutSettings;
    #deviceRequestPrompDeferreds = /* @__PURE__ */ new Set();
    /**
     * @internal
     */
    constructor(client, timeoutSettings) {
      this.#client = client;
      this.#timeoutSettings = timeoutSettings;
      this.#client.on("DeviceAccess.deviceRequestPrompted", (event) => {
        this.#onDeviceRequestPrompted(event);
      });
      this.#client.on("Target.detachedFromTarget", () => {
        this.#client = null;
      });
    }
    /**
     * Wait for device prompt created by an action like calling WebBluetooth's
     * requestDevice.
     */
    async waitForDevicePrompt(options = {}) {
      assert(this.#client !== null, "Cannot wait for device prompt through detached session!");
      const needsEnable = this.#deviceRequestPrompDeferreds.size === 0;
      let enablePromise;
      if (needsEnable) {
        enablePromise = this.#client.send("DeviceAccess.enable");
      }
      const { timeout: timeout2 = this.#timeoutSettings.timeout() } = options;
      const deferred = Deferred.create({
        message: `Waiting for \`DeviceRequestPrompt\` failed: ${timeout2}ms exceeded`,
        timeout: timeout2
      });
      this.#deviceRequestPrompDeferreds.add(deferred);
      try {
        const [result] = await Promise.all([
          deferred.valueOrThrow(),
          enablePromise
        ]);
        return result;
      } finally {
        this.#deviceRequestPrompDeferreds.delete(deferred);
      }
    }
    /**
     * @internal
     */
    #onDeviceRequestPrompted(event) {
      if (!this.#deviceRequestPrompDeferreds.size) {
        return;
      }
      assert(this.#client !== null);
      const devicePrompt = new DeviceRequestPrompt(this.#client, this.#timeoutSettings, event);
      for (const promise of this.#deviceRequestPrompDeferreds) {
        promise.resolve(devicePrompt);
      }
      this.#deviceRequestPrompDeferreds.clear();
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Frame.js
  init_dirname();
  init_buffer2();
  init_Errors();
  init_Deferred();
  init_disposable();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorld.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Realm.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/WaitTask.js
  init_dirname();
  init_buffer2();
  init_Deferred();
  init_Errors();
  var WaitTask = class {
    #world;
    #polling;
    #root;
    #fn;
    #args;
    #timeout;
    #timeoutError;
    #result = Deferred.create();
    #poller;
    #signal;
    #reruns = [];
    constructor(world, options, fn, ...args) {
      this.#world = world;
      this.#polling = options.polling;
      this.#root = options.root;
      this.#signal = options.signal;
      this.#signal?.addEventListener("abort", () => {
        void this.terminate(this.#signal?.reason);
      }, {
        once: true
      });
      switch (typeof fn) {
        case "string":
          this.#fn = `() => {return (${fn});}`;
          break;
        default:
          this.#fn = stringifyFunction(fn);
          break;
      }
      this.#args = args;
      this.#world.taskManager.add(this);
      if (options.timeout) {
        this.#timeoutError = new TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`);
        this.#timeout = setTimeout(() => {
          void this.terminate(this.#timeoutError);
        }, options.timeout);
      }
      void this.rerun();
    }
    get result() {
      return this.#result.valueOrThrow();
    }
    async rerun() {
      for (const prev of this.#reruns) {
        prev.abort();
      }
      this.#reruns.length = 0;
      const controller = new AbortController();
      this.#reruns.push(controller);
      try {
        switch (this.#polling) {
          case "raf":
            this.#poller = await this.#world.evaluateHandle(({ RAFPoller, createFunction: createFunction2 }, fn, ...args) => {
              const fun = createFunction2(fn);
              return new RAFPoller(() => {
                return fun(...args);
              });
            }, LazyArg.create((context2) => {
              return context2.puppeteerUtil;
            }), this.#fn, ...this.#args);
            break;
          case "mutation":
            this.#poller = await this.#world.evaluateHandle(({ MutationPoller, createFunction: createFunction2 }, root, fn, ...args) => {
              const fun = createFunction2(fn);
              return new MutationPoller(() => {
                return fun(...args);
              }, root || document);
            }, LazyArg.create((context2) => {
              return context2.puppeteerUtil;
            }), this.#root, this.#fn, ...this.#args);
            break;
          default:
            this.#poller = await this.#world.evaluateHandle(({ IntervalPoller, createFunction: createFunction2 }, ms, fn, ...args) => {
              const fun = createFunction2(fn);
              return new IntervalPoller(() => {
                return fun(...args);
              }, ms);
            }, LazyArg.create((context2) => {
              return context2.puppeteerUtil;
            }), this.#polling, this.#fn, ...this.#args);
            break;
        }
        await this.#poller.evaluate((poller) => {
          void poller.start();
        });
        const result = await this.#poller.evaluateHandle((poller) => {
          return poller.result();
        });
        this.#result.resolve(result);
        await this.terminate();
      } catch (error) {
        if (controller.signal.aborted) {
          return;
        }
        const badError = this.getBadError(error);
        if (badError) {
          await this.terminate(badError);
        }
      }
    }
    async terminate(error) {
      this.#world.taskManager.delete(this);
      clearTimeout(this.#timeout);
      if (error && !this.#result.finished()) {
        this.#result.reject(error);
      }
      if (this.#poller) {
        try {
          await this.#poller.evaluateHandle(async (poller) => {
            await poller.stop();
          });
          if (this.#poller) {
            await this.#poller.dispose();
            this.#poller = void 0;
          }
        } catch {
        }
      }
    }
    /**
     * Not all errors lead to termination. They usually imply we need to rerun the task.
     */
    getBadError(error) {
      if (isErrorLike(error)) {
        if (error.message.includes("Execution context is not available in detached frame")) {
          return new Error("Waiting failed: Frame detached");
        }
        if (error.message.includes("Execution context was destroyed")) {
          return;
        }
        if (error.message.includes("Cannot find context with specified id")) {
          return;
        }
        if (error.message.includes("AbortError: Actor 'MessageHandlerFrame' destroyed")) {
          return;
        }
        return error;
      }
      return new Error("WaitTask failed with an error", {
        cause: error
      });
    }
  };
  var TaskManager = class {
    #tasks = /* @__PURE__ */ new Set();
    add(task) {
      this.#tasks.add(task);
    }
    delete(task) {
      this.#tasks.delete(task);
    }
    terminateAll(error) {
      for (const task of this.#tasks) {
        void task.terminate(error);
      }
      this.#tasks.clear();
    }
    async rerunAll() {
      await Promise.all([...this.#tasks].map((task) => {
        return task.rerun();
      }));
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Realm.js
  init_disposable();
  var Realm = class {
    timeoutSettings;
    taskManager = new TaskManager();
    constructor(timeoutSettings) {
      this.timeoutSettings = timeoutSettings;
    }
    async waitForFunction(pageFunction, options = {}, ...args) {
      const { polling = "raf", timeout: timeout2 = this.timeoutSettings.timeout(), root, signal } = options;
      if (typeof polling === "number" && polling < 0) {
        throw new Error("Cannot poll with non-positive interval");
      }
      const waitTask = new WaitTask(this, {
        polling,
        root,
        timeout: timeout2,
        signal
      }, pageFunction, ...args);
      return await waitTask.result;
    }
    get disposed() {
      return this.#disposed;
    }
    #disposed = false;
    /** @internal */
    [disposeSymbol]() {
      this.#disposed = true;
      this.taskManager.terminateAll(new Error("waitForFunction failed: frame got detached."));
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorld.js
  init_util2();
  init_Deferred();
  init_disposable();
  init_Mutex();
  var __addDisposableResource10 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async2) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources10 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail2(e9) {
        env.error = env.hasError ? new SuppressedError2(e9, env.error, "An error was suppressed during disposal.") : e9;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  var IsolatedWorld = class extends Realm {
    #context = Deferred.create();
    // Set of bindings that have been registered in the current context.
    #contextBindings = /* @__PURE__ */ new Set();
    // Contains mapping from functions that should be bound to Puppeteer functions.
    #bindings = /* @__PURE__ */ new Map();
    get _bindings() {
      return this.#bindings;
    }
    #frameOrWorker;
    constructor(frameOrWorker, timeoutSettings) {
      super(timeoutSettings);
      this.#frameOrWorker = frameOrWorker;
      this.frameUpdated();
    }
    get environment() {
      return this.#frameOrWorker;
    }
    frameUpdated() {
      this.client.on("Runtime.bindingCalled", this.#onBindingCalled);
    }
    get client() {
      return this.#frameOrWorker.client;
    }
    clearContext() {
      this.#context?.reject(new Error("Execution context was destroyed"));
      this.#context = Deferred.create();
      if ("clearDocumentHandle" in this.#frameOrWorker) {
        this.#frameOrWorker.clearDocumentHandle();
      }
    }
    setContext(context2) {
      this.#contextBindings.clear();
      this.#context.resolve(context2);
      void this.taskManager.rerunAll();
    }
    hasContext() {
      return this.#context.resolved();
    }
    #executionContext() {
      if (this.disposed) {
        throw new Error(`Execution context is not available in detached frame "${this.environment.url()}" (are you trying to evaluate?)`);
      }
      if (this.#context === null) {
        throw new Error(`Execution content promise is missing`);
      }
      return this.#context.valueOrThrow();
    }
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      const context2 = await this.#executionContext();
      return await context2.evaluateHandle(pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      let context2 = this.#context.value();
      if (!context2 || !(context2 instanceof ExecutionContext)) {
        context2 = await this.#executionContext();
      }
      return await context2.evaluate(pageFunction, ...args);
    }
    // If multiple waitFor are set up asynchronously, we need to wait for the
    // first one to set up the binding in the page before running the others.
    #mutex = new Mutex();
    async _addBindingToContext(context2, name2) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        if (this.#contextBindings.has(name2)) {
          return;
        }
        const _4 = __addDisposableResource10(env_1, await this.#mutex.acquire(), false);
        try {
          await context2._client.send("Runtime.addBinding", context2._contextName ? {
            name: name2,
            executionContextName: context2._contextName
          } : {
            name: name2,
            executionContextId: context2._contextId
          });
          await context2.evaluate(addPageBinding, "internal", name2);
          this.#contextBindings.add(name2);
        } catch (error) {
          if (error instanceof Error) {
            if (error.message.includes("Execution context was destroyed")) {
              return;
            }
            if (error.message.includes("Cannot find context with specified id")) {
              return;
            }
          }
          debugError(error);
        }
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources10(env_1);
      }
    }
    #onBindingCalled = async (event) => {
      let payload;
      try {
        payload = JSON.parse(event.payload);
      } catch {
        return;
      }
      const { type, name: name2, seq, args, isTrivial } = payload;
      if (type !== "internal") {
        return;
      }
      if (!this.#contextBindings.has(name2)) {
        return;
      }
      try {
        const context2 = await this.#context.valueOrThrow();
        if (event.executionContextId !== context2._contextId) {
          return;
        }
        const binding = this._bindings.get(name2);
        await binding?.run(context2, seq, args, isTrivial);
      } catch (err) {
        debugError(err);
      }
    };
    async adoptBackendNode(backendNodeId) {
      const executionContext = await this.#executionContext();
      const { object } = await this.client.send("DOM.resolveNode", {
        backendNodeId,
        executionContextId: executionContext._contextId
      });
      return createCdpHandle(this, object);
    }
    async adoptHandle(handle) {
      if (handle.realm === this) {
        return await handle.evaluateHandle((value) => {
          return value;
        });
      }
      const nodeInfo = await this.client.send("DOM.describeNode", {
        objectId: handle.id
      });
      return await this.adoptBackendNode(nodeInfo.node.backendNodeId);
    }
    async transferHandle(handle) {
      if (handle.realm === this) {
        return handle;
      }
      if (handle.remoteObject().objectId === void 0) {
        return handle;
      }
      const info = await this.client.send("DOM.describeNode", {
        objectId: handle.remoteObject().objectId
      });
      const newHandle = await this.adoptBackendNode(info.node.backendNodeId);
      await handle.dispose();
      return newHandle;
    }
    [disposeSymbol]() {
      super[disposeSymbol]();
      this.client.off("Runtime.bindingCalled", this.#onBindingCalled);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorlds.js
  init_dirname();
  init_buffer2();
  var MAIN_WORLD = Symbol("mainWorld");
  var PUPPETEER_WORLD = Symbol("puppeteerWorld");

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/LifecycleWatcher.js
  init_dirname();
  init_buffer2();
  init_EventEmitter();
  init_assert();
  init_Deferred();
  init_disposable();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameManagerEvents.js
  init_dirname();
  init_buffer2();
  var FrameManagerEvent;
  (function(FrameManagerEvent2) {
    FrameManagerEvent2.FrameAttached = Symbol("FrameManager.FrameAttached");
    FrameManagerEvent2.FrameNavigated = Symbol("FrameManager.FrameNavigated");
    FrameManagerEvent2.FrameDetached = Symbol("FrameManager.FrameDetached");
    FrameManagerEvent2.FrameSwapped = Symbol("FrameManager.FrameSwapped");
    FrameManagerEvent2.LifecycleEvent = Symbol("FrameManager.LifecycleEvent");
    FrameManagerEvent2.FrameNavigatedWithinDocument = Symbol("FrameManager.FrameNavigatedWithinDocument");
  })(FrameManagerEvent || (FrameManagerEvent = {}));

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/LifecycleWatcher.js
  var puppeteerToProtocolLifecycle = /* @__PURE__ */ new Map([
    ["load", "load"],
    ["domcontentloaded", "DOMContentLoaded"],
    ["networkidle0", "networkIdle"],
    ["networkidle2", "networkAlmostIdle"]
  ]);
  var LifecycleWatcher = class {
    #expectedLifecycle;
    #frame;
    #timeout;
    #navigationRequest = null;
    #subscriptions = new DisposableStack();
    #initialLoaderId;
    #terminationDeferred;
    #sameDocumentNavigationDeferred = Deferred.create();
    #lifecycleDeferred = Deferred.create();
    #newDocumentNavigationDeferred = Deferred.create();
    #hasSameDocumentNavigation;
    #swapped;
    #navigationResponseReceived;
    constructor(networkManager, frame, waitUntil, timeout2) {
      if (Array.isArray(waitUntil)) {
        waitUntil = waitUntil.slice();
      } else if (typeof waitUntil === "string") {
        waitUntil = [waitUntil];
      }
      this.#initialLoaderId = frame._loaderId;
      this.#expectedLifecycle = waitUntil.map((value) => {
        const protocolEvent = puppeteerToProtocolLifecycle.get(value);
        assert(protocolEvent, "Unknown value for options.waitUntil: " + value);
        return protocolEvent;
      });
      this.#frame = frame;
      this.#timeout = timeout2;
      this.#subscriptions.use(
        // Revert if TODO #1 is done
        new EventSubscription(frame._frameManager, FrameManagerEvent.LifecycleEvent, this.#checkLifecycleComplete.bind(this))
      );
      this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameNavigatedWithinDocument, this.#navigatedWithinDocument.bind(this)));
      this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameNavigated, this.#navigated.bind(this)));
      this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameSwapped, this.#frameSwapped.bind(this)));
      this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameSwappedByActivation, this.#frameSwapped.bind(this)));
      this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameDetached, this.#onFrameDetached.bind(this)));
      this.#subscriptions.use(new EventSubscription(networkManager, NetworkManagerEvent.Request, this.#onRequest.bind(this)));
      this.#subscriptions.use(new EventSubscription(networkManager, NetworkManagerEvent.Response, this.#onResponse.bind(this)));
      this.#subscriptions.use(new EventSubscription(networkManager, NetworkManagerEvent.RequestFailed, this.#onRequestFailed.bind(this)));
      this.#terminationDeferred = Deferred.create({
        timeout: this.#timeout,
        message: `Navigation timeout of ${this.#timeout} ms exceeded`
      });
      this.#checkLifecycleComplete();
    }
    #onRequest(request) {
      if (request.frame() !== this.#frame || !request.isNavigationRequest()) {
        return;
      }
      this.#navigationRequest = request;
      this.#navigationResponseReceived?.resolve();
      this.#navigationResponseReceived = Deferred.create();
      if (request.response() !== null) {
        this.#navigationResponseReceived?.resolve();
      }
    }
    #onRequestFailed(request) {
      if (this.#navigationRequest?.id !== request.id) {
        return;
      }
      this.#navigationResponseReceived?.resolve();
    }
    #onResponse(response) {
      if (this.#navigationRequest?.id !== response.request().id) {
        return;
      }
      this.#navigationResponseReceived?.resolve();
    }
    #onFrameDetached(frame) {
      if (this.#frame === frame) {
        this.#terminationDeferred.resolve(new Error("Navigating frame was detached"));
        return;
      }
      this.#checkLifecycleComplete();
    }
    async navigationResponse() {
      await this.#navigationResponseReceived?.valueOrThrow();
      return this.#navigationRequest ? this.#navigationRequest.response() : null;
    }
    sameDocumentNavigationPromise() {
      return this.#sameDocumentNavigationDeferred.valueOrThrow();
    }
    newDocumentNavigationPromise() {
      return this.#newDocumentNavigationDeferred.valueOrThrow();
    }
    lifecyclePromise() {
      return this.#lifecycleDeferred.valueOrThrow();
    }
    terminationPromise() {
      return this.#terminationDeferred.valueOrThrow();
    }
    #navigatedWithinDocument() {
      this.#hasSameDocumentNavigation = true;
      this.#checkLifecycleComplete();
    }
    #navigated(navigationType) {
      if (navigationType === "BackForwardCacheRestore") {
        return this.#frameSwapped();
      }
      this.#checkLifecycleComplete();
    }
    #frameSwapped() {
      this.#swapped = true;
      this.#checkLifecycleComplete();
    }
    #checkLifecycleComplete() {
      if (!checkLifecycle(this.#frame, this.#expectedLifecycle)) {
        return;
      }
      this.#lifecycleDeferred.resolve();
      if (this.#hasSameDocumentNavigation) {
        this.#sameDocumentNavigationDeferred.resolve(void 0);
      }
      if (this.#swapped || this.#frame._loaderId !== this.#initialLoaderId) {
        this.#newDocumentNavigationDeferred.resolve(void 0);
      }
      function checkLifecycle(frame, expectedLifecycle) {
        for (const event of expectedLifecycle) {
          if (!frame._lifecycleEvents.has(event)) {
            return false;
          }
        }
        for (const child of frame.childFrames()) {
          if (child._hasStartedLoading && !checkLifecycle(child, expectedLifecycle)) {
            return false;
          }
        }
        return true;
      }
    }
    dispose() {
      this.#subscriptions.dispose();
      this.#terminationDeferred.resolve(new Error("LifecycleWatcher disposed"));
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Frame.js
  var __runInitializers8 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i7 = 0; i7 < initializers.length; i7++) {
      value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate8 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f7) {
      if (f7 !== void 0 && typeof f7 !== "function")
        throw new TypeError("Function expected");
      return f7;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _4, done = false;
    for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
      var context2 = {};
      for (var p7 in contextIn)
        context2[p7] = p7 === "access" ? {} : contextIn[p7];
      for (var p7 in contextIn.access)
        context2.access[p7] = contextIn.access[p7];
      context2.addInitializer = function(f7) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f7 || null));
      };
      var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_4 = accept(result.get))
          descriptor.get = _4;
        if (_4 = accept(result.set))
          descriptor.set = _4;
        if (_4 = accept(result.init))
          initializers.unshift(_4);
      } else if (_4 = accept(result)) {
        if (kind === "field")
          initializers.unshift(_4);
        else
          descriptor[key] = _4;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var CdpFrame = (() => {
    let _classSuper = Frame;
    let _instanceExtraInitializers = [];
    let _goto_decorators;
    let _waitForNavigation_decorators;
    let _setContent_decorators;
    let _waitForDevicePrompt_decorators;
    return class CdpFrame extends _classSuper {
      static {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
        __esDecorate8(this, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: (obj) => "goto" in obj, get: (obj) => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate8(this, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: (obj) => "waitForNavigation" in obj, get: (obj) => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate8(this, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: (obj) => "setContent" in obj, get: (obj) => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate8(this, null, _waitForDevicePrompt_decorators, { kind: "method", name: "waitForDevicePrompt", static: false, private: false, access: { has: (obj) => "waitForDevicePrompt" in obj, get: (obj) => obj.waitForDevicePrompt }, metadata: _metadata }, null, _instanceExtraInitializers);
        if (_metadata)
          Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      }
      #url = (__runInitializers8(this, _instanceExtraInitializers), "");
      #detached = false;
      #client;
      worlds;
      _frameManager;
      _id;
      _loaderId = "";
      _lifecycleEvents = /* @__PURE__ */ new Set();
      _parentId;
      constructor(frameManager, frameId, parentFrameId, client) {
        super();
        this._frameManager = frameManager;
        this.#url = "";
        this._id = frameId;
        this._parentId = parentFrameId;
        this.#detached = false;
        this._loaderId = "";
        this.updateClient(client);
        this.on(FrameEvent.FrameSwappedByActivation, () => {
          this._onLoadingStarted();
          this._onLoadingStopped();
        });
      }
      /**
       * This is used internally in DevTools.
       *
       * @internal
       */
      _client() {
        return this.#client;
      }
      /**
       * Updates the frame ID with the new ID. This happens when the main frame is
       * replaced by a different frame.
       */
      updateId(id) {
        this._id = id;
      }
      updateClient(client, keepWorlds = false) {
        this.#client = client;
        if (!keepWorlds) {
          if (this.worlds) {
            this.worlds[MAIN_WORLD].clearContext();
            this.worlds[PUPPETEER_WORLD].clearContext();
          }
          this.worlds = {
            [MAIN_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings),
            [PUPPETEER_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings)
          };
        } else {
          this.worlds[MAIN_WORLD].frameUpdated();
          this.worlds[PUPPETEER_WORLD].frameUpdated();
        }
      }
      page() {
        return this._frameManager.page();
      }
      isOOPFrame() {
        return this.#client !== this._frameManager.client;
      }
      async goto(url, options = {}) {
        const { referer = this._frameManager.networkManager.extraHTTPHeaders()["referer"], referrerPolicy = this._frameManager.networkManager.extraHTTPHeaders()["referer-policy"], waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
        let ensureNewDocumentNavigation = false;
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
        let error = await Deferred.race([
          navigate(this.#client, url, referer, referrerPolicy, this._id),
          watcher.terminationPromise()
        ]);
        if (!error) {
          error = await Deferred.race([
            watcher.terminationPromise(),
            ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()
          ]);
        }
        try {
          if (error) {
            throw error;
          }
          return await watcher.navigationResponse();
        } finally {
          watcher.dispose();
        }
        async function navigate(client, url2, referrer, referrerPolicy2, frameId) {
          try {
            const response = await client.send("Page.navigate", {
              url: url2,
              referrer,
              frameId,
              referrerPolicy: referrerPolicy2
            });
            ensureNewDocumentNavigation = !!response.loaderId;
            if (response.errorText === "net::ERR_HTTP_RESPONSE_CODE_FAILURE") {
              return null;
            }
            return response.errorText ? new Error(`${response.errorText} at ${url2}`) : null;
          } catch (error2) {
            if (isErrorLike(error2)) {
              return error2;
            }
            throw error2;
          }
        }
      }
      async waitForNavigation(options = {}) {
        const { waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
        const error = await Deferred.race([
          watcher.terminationPromise(),
          ...options.ignoreSameDocumentNavigation ? [] : [watcher.sameDocumentNavigationPromise()],
          watcher.newDocumentNavigationPromise()
        ]);
        try {
          if (error) {
            throw error;
          }
          const result = await Deferred.race([watcher.terminationPromise(), watcher.navigationResponse()]);
          if (result instanceof Error) {
            throw error;
          }
          return result || null;
        } finally {
          watcher.dispose();
        }
      }
      get client() {
        return this.#client;
      }
      mainRealm() {
        return this.worlds[MAIN_WORLD];
      }
      isolatedRealm() {
        return this.worlds[PUPPETEER_WORLD];
      }
      async setContent(html, options = {}) {
        const { waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
        await this.setFrameContent(html);
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
        const error = await Deferred.race([
          watcher.terminationPromise(),
          watcher.lifecyclePromise()
        ]);
        watcher.dispose();
        if (error) {
          throw error;
        }
      }
      url() {
        return this.#url;
      }
      parentFrame() {
        return this._frameManager._frameTree.parentFrame(this._id) || null;
      }
      childFrames() {
        return this._frameManager._frameTree.childFrames(this._id);
      }
      #deviceRequestPromptManager() {
        const rootFrame = this.page().mainFrame();
        if (this.isOOPFrame() || rootFrame === null) {
          return this._frameManager._deviceRequestPromptManager(this.#client);
        } else {
          return rootFrame._frameManager._deviceRequestPromptManager(this.#client);
        }
      }
      async waitForDevicePrompt(options = {}) {
        return await this.#deviceRequestPromptManager().waitForDevicePrompt(options);
      }
      _navigated(framePayload) {
        this._name = framePayload.name;
        this.#url = `${framePayload.url}${framePayload.urlFragment || ""}`;
      }
      _navigatedWithinDocument(url) {
        this.#url = url;
      }
      _onLifecycleEvent(loaderId, name2) {
        if (name2 === "init") {
          this._loaderId = loaderId;
          this._lifecycleEvents.clear();
        }
        this._lifecycleEvents.add(name2);
      }
      _onLoadingStopped() {
        this._lifecycleEvents.add("DOMContentLoaded");
        this._lifecycleEvents.add("load");
      }
      _onLoadingStarted() {
        this._hasStartedLoading = true;
      }
      get detached() {
        return this.#detached;
      }
      [(_goto_decorators = [throwIfDetached], _waitForNavigation_decorators = [throwIfDetached], _setContent_decorators = [throwIfDetached], _waitForDevicePrompt_decorators = [throwIfDetached], disposeSymbol)]() {
        if (this.#detached) {
          return;
        }
        this.#detached = true;
        this.worlds[MAIN_WORLD][disposeSymbol]();
        this.worlds[PUPPETEER_WORLD][disposeSymbol]();
      }
      exposeFunction() {
        throw new UnsupportedOperation();
      }
    };
  })();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameTree.js
  init_dirname();
  init_buffer2();
  init_Deferred();
  var FrameTree = class {
    #frames = /* @__PURE__ */ new Map();
    // frameID -> parentFrameID
    #parentIds = /* @__PURE__ */ new Map();
    // frameID -> childFrameIDs
    #childIds = /* @__PURE__ */ new Map();
    #mainFrame;
    #waitRequests = /* @__PURE__ */ new Map();
    getMainFrame() {
      return this.#mainFrame;
    }
    getById(frameId) {
      return this.#frames.get(frameId);
    }
    /**
     * Returns a promise that is resolved once the frame with
     * the given ID is added to the tree.
     */
    waitForFrame(frameId) {
      const frame = this.getById(frameId);
      if (frame) {
        return Promise.resolve(frame);
      }
      const deferred = Deferred.create();
      const callbacks = this.#waitRequests.get(frameId) || /* @__PURE__ */ new Set();
      callbacks.add(deferred);
      return deferred.valueOrThrow();
    }
    frames() {
      return Array.from(this.#frames.values());
    }
    addFrame(frame) {
      this.#frames.set(frame._id, frame);
      if (frame._parentId) {
        this.#parentIds.set(frame._id, frame._parentId);
        if (!this.#childIds.has(frame._parentId)) {
          this.#childIds.set(frame._parentId, /* @__PURE__ */ new Set());
        }
        this.#childIds.get(frame._parentId).add(frame._id);
      } else if (!this.#mainFrame) {
        this.#mainFrame = frame;
      }
      this.#waitRequests.get(frame._id)?.forEach((request) => {
        return request.resolve(frame);
      });
    }
    removeFrame(frame) {
      this.#frames.delete(frame._id);
      this.#parentIds.delete(frame._id);
      if (frame._parentId) {
        this.#childIds.get(frame._parentId)?.delete(frame._id);
      } else {
        this.#mainFrame = void 0;
      }
    }
    childFrames(frameId) {
      const childIds = this.#childIds.get(frameId);
      if (!childIds) {
        return [];
      }
      return Array.from(childIds).map((id) => {
        return this.getById(id);
      }).filter((frame) => {
        return frame !== void 0;
      });
    }
    parentFrame(frameId) {
      const parentId = this.#parentIds.get(frameId);
      return parentId ? this.getById(parentId) : void 0;
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/NetworkManager.js
  init_dirname();
  init_buffer2();
  init_CDPSession();
  init_EventEmitter();
  init_util2();
  init_assert();
  init_disposable();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/HTTPRequest.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPRequest.js
  init_dirname();
  init_buffer2();
  init_util2();
  init_assert();
  var HTTPRequest = class {
    /**
     * @internal
     */
    _interceptionId;
    /**
     * @internal
     */
    _failureText = null;
    /**
     * @internal
     */
    _response = null;
    /**
     * @internal
     */
    _fromMemoryCache = false;
    /**
     * @internal
     */
    _redirectChain = [];
    /**
     * @internal
     */
    interception = {
      enabled: false,
      handled: false,
      handlers: [],
      resolutionState: {
        action: InterceptResolutionAction.None
      },
      requestOverrides: {},
      response: null,
      abortReason: null
    };
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * The `ContinueRequestOverrides` that will be used
     * if the interception is allowed to continue (ie, `abort()` and
     * `respond()` aren't called).
     */
    continueRequestOverrides() {
      assert(this.interception.enabled, "Request Interception is not enabled!");
      return this.interception.requestOverrides;
    }
    /**
     * The `ResponseForRequest` that gets used if the
     * interception is allowed to respond (ie, `abort()` is not called).
     */
    responseForRequest() {
      assert(this.interception.enabled, "Request Interception is not enabled!");
      return this.interception.response;
    }
    /**
     * The most recent reason for aborting the request
     */
    abortErrorReason() {
      assert(this.interception.enabled, "Request Interception is not enabled!");
      return this.interception.abortReason;
    }
    /**
     * An InterceptResolutionState object describing the current resolution
     * action and priority.
     *
     * InterceptResolutionState contains:
     * action: InterceptResolutionAction
     * priority?: number
     *
     * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,
     * `disabled`, `none`, or `already-handled`.
     */
    interceptResolutionState() {
      if (!this.interception.enabled) {
        return { action: InterceptResolutionAction.Disabled };
      }
      if (this.interception.handled) {
        return { action: InterceptResolutionAction.AlreadyHandled };
      }
      return { ...this.interception.resolutionState };
    }
    /**
     * Is `true` if the intercept resolution has already been handled,
     * `false` otherwise.
     */
    isInterceptResolutionHandled() {
      return this.interception.handled;
    }
    /**
     * Adds an async request handler to the processing queue.
     * Deferred handlers are not guaranteed to execute in any particular order,
     * but they are guaranteed to resolve before the request interception
     * is finalized.
     */
    enqueueInterceptAction(pendingHandler) {
      this.interception.handlers.push(pendingHandler);
    }
    /**
     * Awaits pending interception handlers and then decides how to fulfill
     * the request interception.
     */
    async finalizeInterceptions() {
      await this.interception.handlers.reduce((promiseChain, interceptAction) => {
        return promiseChain.then(interceptAction);
      }, Promise.resolve());
      this.interception.handlers = [];
      const { action } = this.interceptResolutionState();
      switch (action) {
        case "abort":
          return await this._abort(this.interception.abortReason);
        case "respond":
          if (this.interception.response === null) {
            throw new Error("Response is missing for the interception");
          }
          return await this._respond(this.interception.response);
        case "continue":
          return await this._continue(this.interception.requestOverrides);
      }
    }
    /**
     * Continues request with optional request overrides.
     *
     * @example
     *
     * ```ts
     * await page.setRequestInterception(true);
     * page.on('request', request => {
     *   // Override headers
     *   const headers = Object.assign({}, request.headers(), {
     *     foo: 'bar', // set "foo" header
     *     origin: undefined, // remove "origin" header
     *   });
     *   request.continue({headers});
     * });
     * ```
     *
     * @param overrides - optional overrides to apply to the request.
     * @param priority - If provided, intercept is resolved using cooperative
     * handling rules. Otherwise, intercept is resolved immediately.
     *
     * @remarks
     *
     * To use this, request interception should be enabled with
     * {@link Page.setRequestInterception}.
     *
     * Exception is immediately thrown if the request interception is not enabled.
     */
    async continue(overrides = {}, priority) {
      if (this.url().startsWith("data:")) {
        return;
      }
      assert(this.interception.enabled, "Request Interception is not enabled!");
      assert(!this.interception.handled, "Request is already handled!");
      if (priority === void 0) {
        return await this._continue(overrides);
      }
      this.interception.requestOverrides = overrides;
      if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
        this.interception.resolutionState = {
          action: InterceptResolutionAction.Continue,
          priority
        };
        return;
      }
      if (priority === this.interception.resolutionState.priority) {
        if (this.interception.resolutionState.action === "abort" || this.interception.resolutionState.action === "respond") {
          return;
        }
        this.interception.resolutionState.action = InterceptResolutionAction.Continue;
      }
      return;
    }
    /**
     * Fulfills a request with the given response.
     *
     * @example
     * An example of fulfilling all requests with 404 responses:
     *
     * ```ts
     * await page.setRequestInterception(true);
     * page.on('request', request => {
     *   request.respond({
     *     status: 404,
     *     contentType: 'text/plain',
     *     body: 'Not Found!',
     *   });
     * });
     * ```
     *
     * NOTE: Mocking responses for dataURL requests is not supported.
     * Calling `request.respond` for a dataURL request is a noop.
     *
     * @param response - the response to fulfill the request with.
     * @param priority - If provided, intercept is resolved using
     * cooperative handling rules. Otherwise, intercept is resolved
     * immediately.
     *
     * @remarks
     *
     * To use this, request
     * interception should be enabled with {@link Page.setRequestInterception}.
     *
     * Exception is immediately thrown if the request interception is not enabled.
     */
    async respond(response, priority) {
      if (this.url().startsWith("data:")) {
        return;
      }
      assert(this.interception.enabled, "Request Interception is not enabled!");
      assert(!this.interception.handled, "Request is already handled!");
      if (priority === void 0) {
        return await this._respond(response);
      }
      this.interception.response = response;
      if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
        this.interception.resolutionState = {
          action: InterceptResolutionAction.Respond,
          priority
        };
        return;
      }
      if (priority === this.interception.resolutionState.priority) {
        if (this.interception.resolutionState.action === "abort") {
          return;
        }
        this.interception.resolutionState.action = InterceptResolutionAction.Respond;
      }
    }
    /**
     * Aborts a request.
     *
     * @param errorCode - optional error code to provide.
     * @param priority - If provided, intercept is resolved using
     * cooperative handling rules. Otherwise, intercept is resolved
     * immediately.
     *
     * @remarks
     *
     * To use this, request interception should be enabled with
     * {@link Page.setRequestInterception}. If it is not enabled, this method will
     * throw an exception immediately.
     */
    async abort(errorCode = "failed", priority) {
      if (this.url().startsWith("data:")) {
        return;
      }
      const errorReason = errorReasons[errorCode];
      assert(errorReason, "Unknown error code: " + errorCode);
      assert(this.interception.enabled, "Request Interception is not enabled!");
      assert(!this.interception.handled, "Request is already handled!");
      if (priority === void 0) {
        return await this._abort(errorReason);
      }
      this.interception.abortReason = errorReason;
      if (this.interception.resolutionState.priority === void 0 || priority >= this.interception.resolutionState.priority) {
        this.interception.resolutionState = {
          action: InterceptResolutionAction.Abort,
          priority
        };
        return;
      }
    }
  };
  var InterceptResolutionAction;
  (function(InterceptResolutionAction2) {
    InterceptResolutionAction2["Abort"] = "abort";
    InterceptResolutionAction2["Respond"] = "respond";
    InterceptResolutionAction2["Continue"] = "continue";
    InterceptResolutionAction2["Disabled"] = "disabled";
    InterceptResolutionAction2["None"] = "none";
    InterceptResolutionAction2["AlreadyHandled"] = "already-handled";
  })(InterceptResolutionAction || (InterceptResolutionAction = {}));
  function headersArray(headers) {
    const result = [];
    for (const name2 in headers) {
      const value = headers[name2];
      if (!Object.is(value, void 0)) {
        const values = Array.isArray(value) ? value : [value];
        result.push(...values.map((value2) => {
          return { name: name2, value: value2 + "" };
        }));
      }
    }
    return result;
  }
  var STATUS_TEXTS = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "103": "Early Hints",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "306": "Switch Proxy",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Too Early",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "510": "Not Extended",
    "511": "Network Authentication Required"
  };
  var errorReasons = {
    aborted: "Aborted",
    accessdenied: "AccessDenied",
    addressunreachable: "AddressUnreachable",
    blockedbyclient: "BlockedByClient",
    blockedbyresponse: "BlockedByResponse",
    connectionaborted: "ConnectionAborted",
    connectionclosed: "ConnectionClosed",
    connectionfailed: "ConnectionFailed",
    connectionrefused: "ConnectionRefused",
    connectionreset: "ConnectionReset",
    internetdisconnected: "InternetDisconnected",
    namenotresolved: "NameNotResolved",
    timedout: "TimedOut",
    failed: "Failed"
  };
  function handleError(error) {
    if (error.originalMessage.includes("Invalid header")) {
      throw error;
    }
    debugError(error);
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/HTTPRequest.js
  init_util2();
  var CdpHTTPRequest = class extends HTTPRequest {
    id;
    #client;
    #isNavigationRequest;
    #url;
    #resourceType;
    #method;
    #hasPostData = false;
    #postData;
    #headers = {};
    #frame;
    #initiator;
    get client() {
      return this.#client;
    }
    constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {
      super();
      this.#client = client;
      this.id = data.requestId;
      this.#isNavigationRequest = data.requestId === data.loaderId && data.type === "Document";
      this._interceptionId = interceptionId;
      this.#url = data.request.url;
      this.#resourceType = (data.type || "other").toLowerCase();
      this.#method = data.request.method;
      this.#postData = data.request.postData;
      this.#hasPostData = data.request.hasPostData ?? false;
      this.#frame = frame;
      this._redirectChain = redirectChain;
      this.#initiator = data.initiator;
      this.interception.enabled = allowInterception;
      for (const [key, value] of Object.entries(data.request.headers)) {
        this.#headers[key.toLowerCase()] = value;
      }
    }
    url() {
      return this.#url;
    }
    resourceType() {
      return this.#resourceType;
    }
    method() {
      return this.#method;
    }
    postData() {
      return this.#postData;
    }
    hasPostData() {
      return this.#hasPostData;
    }
    async fetchPostData() {
      try {
        const result = await this.#client.send("Network.getRequestPostData", {
          requestId: this.id
        });
        return result.postData;
      } catch (err) {
        debugError(err);
        return;
      }
    }
    headers() {
      return this.#headers;
    }
    response() {
      return this._response;
    }
    frame() {
      return this.#frame;
    }
    isNavigationRequest() {
      return this.#isNavigationRequest;
    }
    initiator() {
      return this.#initiator;
    }
    redirectChain() {
      return this._redirectChain.slice();
    }
    failure() {
      if (!this._failureText) {
        return null;
      }
      return {
        errorText: this._failureText
      };
    }
    /**
     * @internal
     */
    async _continue(overrides = {}) {
      const { url, method, postData, headers } = overrides;
      this.interception.handled = true;
      const postDataBinaryBase64 = postData ? Buffer2.from(postData).toString("base64") : void 0;
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.continueRequest");
      }
      await this.#client.send("Fetch.continueRequest", {
        requestId: this._interceptionId,
        url,
        method,
        postData: postDataBinaryBase64,
        headers: headers ? headersArray(headers) : void 0
      }).catch((error) => {
        this.interception.handled = false;
        return handleError(error);
      });
    }
    async _respond(response) {
      this.interception.handled = true;
      const responseBody = response.body && isString3(response.body) ? Buffer2.from(response.body) : response.body || null;
      const responseHeaders = {};
      if (response.headers) {
        for (const header of Object.keys(response.headers)) {
          const value = response.headers[header];
          responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map((item) => {
            return String(item);
          }) : String(value);
        }
      }
      if (response.contentType) {
        responseHeaders["content-type"] = response.contentType;
      }
      if (responseBody && !("content-length" in responseHeaders)) {
        responseHeaders["content-length"] = String(Buffer2.byteLength(responseBody));
      }
      const status = response.status || 200;
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest");
      }
      await this.#client.send("Fetch.fulfillRequest", {
        requestId: this._interceptionId,
        responseCode: status,
        responsePhrase: STATUS_TEXTS[status],
        responseHeaders: headersArray(responseHeaders),
        body: responseBody ? responseBody.toString("base64") : void 0
      }).catch((error) => {
        this.interception.handled = false;
        return handleError(error);
      });
    }
    async _abort(errorReason) {
      this.interception.handled = true;
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.failRequest");
      }
      await this.#client.send("Fetch.failRequest", {
        requestId: this._interceptionId,
        errorReason: errorReason || "Failed"
      }).catch(handleError);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/HTTPResponse.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js
  init_dirname();
  init_buffer2();
  var HTTPResponse = class {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * True if the response was successful (status in the range 200-299).
     */
    ok() {
      const status = this.status();
      return status === 0 || status >= 200 && status <= 299;
    }
    /**
     * Promise which resolves to a text (utf8) representation of response body.
     */
    async text() {
      const content = await this.buffer();
      return content.toString("utf8");
    }
    /**
     * Promise which resolves to a JSON representation of response body.
     *
     * @remarks
     *
     * This method will throw if the response body is not parsable via
     * `JSON.parse`.
     */
    async json() {
      const content = await this.text();
      return JSON.parse(content);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/HTTPResponse.js
  init_Errors();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js
  init_dirname();
  init_buffer2();
  var SecurityDetails = class {
    #subjectName;
    #issuer;
    #validFrom;
    #validTo;
    #protocol;
    #sanList;
    /**
     * @internal
     */
    constructor(securityPayload) {
      this.#subjectName = securityPayload.subjectName;
      this.#issuer = securityPayload.issuer;
      this.#validFrom = securityPayload.validFrom;
      this.#validTo = securityPayload.validTo;
      this.#protocol = securityPayload.protocol;
      this.#sanList = securityPayload.sanList;
    }
    /**
     * The name of the issuer of the certificate.
     */
    issuer() {
      return this.#issuer;
    }
    /**
     * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the start of the certificate's validity.
     */
    validFrom() {
      return this.#validFrom;
    }
    /**
     * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the end of the certificate's validity.
     */
    validTo() {
      return this.#validTo;
    }
    /**
     * The security protocol being used, e.g. "TLS 1.2".
     */
    protocol() {
      return this.#protocol;
    }
    /**
     * The name of the subject to which the certificate was issued.
     */
    subjectName() {
      return this.#subjectName;
    }
    /**
     * The list of {@link https://en.wikipedia.org/wiki/Subject_Alternative_Name | subject alternative names (SANs)} of the certificate.
     */
    subjectAlternativeNames() {
      return this.#sanList;
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/HTTPResponse.js
  init_Deferred();
  var CdpHTTPResponse = class extends HTTPResponse {
    #client;
    #request;
    #contentPromise = null;
    #bodyLoadedDeferred = Deferred.create();
    #remoteAddress;
    #status;
    #statusText;
    #url;
    #fromDiskCache;
    #fromServiceWorker;
    #headers = {};
    #securityDetails;
    #timing;
    constructor(client, request, responsePayload, extraInfo) {
      super();
      this.#client = client;
      this.#request = request;
      this.#remoteAddress = {
        ip: responsePayload.remoteIPAddress,
        port: responsePayload.remotePort
      };
      this.#statusText = this.#parseStatusTextFromExtraInfo(extraInfo) || responsePayload.statusText;
      this.#url = request.url();
      this.#fromDiskCache = !!responsePayload.fromDiskCache;
      this.#fromServiceWorker = !!responsePayload.fromServiceWorker;
      this.#status = extraInfo ? extraInfo.statusCode : responsePayload.status;
      const headers = extraInfo ? extraInfo.headers : responsePayload.headers;
      for (const [key, value] of Object.entries(headers)) {
        this.#headers[key.toLowerCase()] = value;
      }
      this.#securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;
      this.#timing = responsePayload.timing || null;
    }
    #parseStatusTextFromExtraInfo(extraInfo) {
      if (!extraInfo || !extraInfo.headersText) {
        return;
      }
      const firstLine = extraInfo.headersText.split("\r", 1)[0];
      if (!firstLine) {
        return;
      }
      const match = firstLine.match(/[^ ]* [^ ]* (.*)/);
      if (!match) {
        return;
      }
      const statusText = match[1];
      if (!statusText) {
        return;
      }
      return statusText;
    }
    _resolveBody(err) {
      if (err) {
        return this.#bodyLoadedDeferred.reject(err);
      }
      return this.#bodyLoadedDeferred.resolve();
    }
    remoteAddress() {
      return this.#remoteAddress;
    }
    url() {
      return this.#url;
    }
    status() {
      return this.#status;
    }
    statusText() {
      return this.#statusText;
    }
    headers() {
      return this.#headers;
    }
    securityDetails() {
      return this.#securityDetails;
    }
    timing() {
      return this.#timing;
    }
    buffer() {
      if (!this.#contentPromise) {
        this.#contentPromise = this.#bodyLoadedDeferred.valueOrThrow().then(async () => {
          try {
            const response = await this.#client.send("Network.getResponseBody", {
              requestId: this.#request.id
            });
            return Buffer2.from(response.body, response.base64Encoded ? "base64" : "utf8");
          } catch (error) {
            if (error instanceof ProtocolError && error.originalMessage === "No resource with given identifier found") {
              throw new ProtocolError("Could not load body for this request. This might happen if the request is a preflight request.");
            }
            throw error;
          }
        });
      }
      return this.#contentPromise;
    }
    request() {
      return this.#request;
    }
    fromCache() {
      return this.#fromDiskCache || this.#request._fromMemoryCache;
    }
    fromServiceWorker() {
      return this.#fromServiceWorker;
    }
    frame() {
      return this.#request.frame();
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/NetworkEventManager.js
  init_dirname();
  init_buffer2();
  var NetworkEventManager = class {
    /**
     * There are four possible orders of events:
     * A. `_onRequestWillBeSent`
     * B. `_onRequestWillBeSent`, `_onRequestPaused`
     * C. `_onRequestPaused`, `_onRequestWillBeSent`
     * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`
     * (see crbug.com/1196004)
     *
     * For `_onRequest` we need the event from `_onRequestWillBeSent` and
     * optionally the `interceptionId` from `_onRequestPaused`.
     *
     * If request interception is disabled, call `_onRequest` once per call to
     * `_onRequestWillBeSent`.
     * If request interception is enabled, call `_onRequest` once per call to
     * `_onRequestPaused` (once per `interceptionId`).
     *
     * Events are stored to allow for subsequent events to call `_onRequest`.
     *
     * Note that (chains of) redirect requests have the same `requestId` (!) as
     * the original request. We have to anticipate series of events like these:
     * A. `_onRequestWillBeSent`,
     * `_onRequestWillBeSent`, ...
     * B. `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, ...
     * C. `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestPaused`, `_onRequestWillBeSent`, ...
     * D. `_onRequestPaused`, `_onRequestWillBeSent`,
     * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...
     * (see crbug.com/1196004)
     */
    #requestWillBeSentMap = /* @__PURE__ */ new Map();
    #requestPausedMap = /* @__PURE__ */ new Map();
    #httpRequestsMap = /* @__PURE__ */ new Map();
    /*
     * The below maps are used to reconcile Network.responseReceivedExtraInfo
     * events with their corresponding request. Each response and redirect
     * response gets an ExtraInfo event, and we don't know which will come first.
     * This means that we have to store a Response or an ExtraInfo for each
     * response, and emit the event when we get both of them. In addition, to
     * handle redirects, we have to make them Arrays to represent the chain of
     * events.
     */
    #responseReceivedExtraInfoMap = /* @__PURE__ */ new Map();
    #queuedRedirectInfoMap = /* @__PURE__ */ new Map();
    #queuedEventGroupMap = /* @__PURE__ */ new Map();
    forget(networkRequestId) {
      this.#requestWillBeSentMap.delete(networkRequestId);
      this.#requestPausedMap.delete(networkRequestId);
      this.#queuedEventGroupMap.delete(networkRequestId);
      this.#queuedRedirectInfoMap.delete(networkRequestId);
      this.#responseReceivedExtraInfoMap.delete(networkRequestId);
    }
    responseExtraInfo(networkRequestId) {
      if (!this.#responseReceivedExtraInfoMap.has(networkRequestId)) {
        this.#responseReceivedExtraInfoMap.set(networkRequestId, []);
      }
      return this.#responseReceivedExtraInfoMap.get(networkRequestId);
    }
    queuedRedirectInfo(fetchRequestId) {
      if (!this.#queuedRedirectInfoMap.has(fetchRequestId)) {
        this.#queuedRedirectInfoMap.set(fetchRequestId, []);
      }
      return this.#queuedRedirectInfoMap.get(fetchRequestId);
    }
    queueRedirectInfo(fetchRequestId, redirectInfo) {
      this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
    }
    takeQueuedRedirectInfo(fetchRequestId) {
      return this.queuedRedirectInfo(fetchRequestId).shift();
    }
    inFlightRequestsCount() {
      let inFlightRequestCounter = 0;
      for (const request of this.#httpRequestsMap.values()) {
        if (!request.response()) {
          inFlightRequestCounter++;
        }
      }
      return inFlightRequestCounter;
    }
    storeRequestWillBeSent(networkRequestId, event) {
      this.#requestWillBeSentMap.set(networkRequestId, event);
    }
    getRequestWillBeSent(networkRequestId) {
      return this.#requestWillBeSentMap.get(networkRequestId);
    }
    forgetRequestWillBeSent(networkRequestId) {
      this.#requestWillBeSentMap.delete(networkRequestId);
    }
    getRequestPaused(networkRequestId) {
      return this.#requestPausedMap.get(networkRequestId);
    }
    forgetRequestPaused(networkRequestId) {
      this.#requestPausedMap.delete(networkRequestId);
    }
    storeRequestPaused(networkRequestId, event) {
      this.#requestPausedMap.set(networkRequestId, event);
    }
    getRequest(networkRequestId) {
      return this.#httpRequestsMap.get(networkRequestId);
    }
    storeRequest(networkRequestId, request) {
      this.#httpRequestsMap.set(networkRequestId, request);
    }
    forgetRequest(networkRequestId) {
      this.#httpRequestsMap.delete(networkRequestId);
    }
    getQueuedEventGroup(networkRequestId) {
      return this.#queuedEventGroupMap.get(networkRequestId);
    }
    queueEventGroup(networkRequestId, event) {
      this.#queuedEventGroupMap.set(networkRequestId, event);
    }
    forgetQueuedEventGroup(networkRequestId) {
      this.#queuedEventGroupMap.delete(networkRequestId);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/NetworkManager.js
  var NetworkManager = class extends EventEmitter2 {
    #ignoreHTTPSErrors;
    #frameManager;
    #networkEventManager = new NetworkEventManager();
    #extraHTTPHeaders;
    #credentials;
    #attemptedAuthentications = /* @__PURE__ */ new Set();
    #userRequestInterceptionEnabled = false;
    #protocolRequestInterceptionEnabled = false;
    #userCacheDisabled;
    #emulatedNetworkConditions;
    #userAgent;
    #userAgentMetadata;
    #handlers = [
      ["Fetch.requestPaused", this.#onRequestPaused],
      ["Fetch.authRequired", this.#onAuthRequired],
      ["Network.requestWillBeSent", this.#onRequestWillBeSent],
      ["Network.requestServedFromCache", this.#onRequestServedFromCache],
      ["Network.responseReceived", this.#onResponseReceived],
      ["Network.loadingFinished", this.#onLoadingFinished],
      ["Network.loadingFailed", this.#onLoadingFailed],
      ["Network.responseReceivedExtraInfo", this.#onResponseReceivedExtraInfo],
      [CDPSessionEvent.Disconnected, this.#removeClient]
    ];
    #clients = /* @__PURE__ */ new Map();
    constructor(ignoreHTTPSErrors, frameManager) {
      super();
      this.#ignoreHTTPSErrors = ignoreHTTPSErrors;
      this.#frameManager = frameManager;
    }
    async addClient(client) {
      if (this.#clients.has(client)) {
        return;
      }
      const subscriptions = new DisposableStack();
      this.#clients.set(client, subscriptions);
      for (const [event, handler] of this.#handlers) {
        subscriptions.use(
          // TODO: Remove any here.
          new EventSubscription(client, event, (arg) => {
            return handler.bind(this)(client, arg);
          })
        );
      }
      await Promise.all([
        this.#ignoreHTTPSErrors ? client.send("Security.setIgnoreCertificateErrors", {
          ignore: true
        }) : null,
        client.send("Network.enable"),
        this.#applyExtraHTTPHeaders(client),
        this.#applyNetworkConditions(client),
        this.#applyProtocolCacheDisabled(client),
        this.#applyProtocolRequestInterception(client),
        this.#applyUserAgent(client)
      ]);
    }
    async #removeClient(client) {
      this.#clients.get(client)?.dispose();
      this.#clients.delete(client);
    }
    async authenticate(credentials) {
      this.#credentials = credentials;
      const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;
      if (enabled === this.#protocolRequestInterceptionEnabled) {
        return;
      }
      this.#protocolRequestInterceptionEnabled = enabled;
      await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
    }
    async setExtraHTTPHeaders(extraHTTPHeaders) {
      this.#extraHTTPHeaders = {};
      for (const key of Object.keys(extraHTTPHeaders)) {
        const value = extraHTTPHeaders[key];
        assert(isString3(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
        this.#extraHTTPHeaders[key.toLowerCase()] = value;
      }
      await this.#applyToAllClients(this.#applyExtraHTTPHeaders.bind(this));
    }
    async #applyExtraHTTPHeaders(client) {
      if (this.#extraHTTPHeaders === void 0) {
        return;
      }
      await client.send("Network.setExtraHTTPHeaders", {
        headers: this.#extraHTTPHeaders
      });
    }
    extraHTTPHeaders() {
      return Object.assign({}, this.#extraHTTPHeaders);
    }
    inFlightRequestsCount() {
      return this.#networkEventManager.inFlightRequestsCount();
    }
    async setOfflineMode(value) {
      if (!this.#emulatedNetworkConditions) {
        this.#emulatedNetworkConditions = {
          offline: false,
          upload: -1,
          download: -1,
          latency: 0
        };
      }
      this.#emulatedNetworkConditions.offline = value;
      await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
    }
    async emulateNetworkConditions(networkConditions) {
      if (!this.#emulatedNetworkConditions) {
        this.#emulatedNetworkConditions = {
          offline: false,
          upload: -1,
          download: -1,
          latency: 0
        };
      }
      this.#emulatedNetworkConditions.upload = networkConditions ? networkConditions.upload : -1;
      this.#emulatedNetworkConditions.download = networkConditions ? networkConditions.download : -1;
      this.#emulatedNetworkConditions.latency = networkConditions ? networkConditions.latency : 0;
      await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
    }
    async #applyToAllClients(fn) {
      await Promise.all(Array.from(this.#clients.keys()).map((client) => {
        return fn(client);
      }));
    }
    async #applyNetworkConditions(client) {
      if (this.#emulatedNetworkConditions === void 0) {
        return;
      }
      await client.send("Network.emulateNetworkConditions", {
        offline: this.#emulatedNetworkConditions.offline,
        latency: this.#emulatedNetworkConditions.latency,
        uploadThroughput: this.#emulatedNetworkConditions.upload,
        downloadThroughput: this.#emulatedNetworkConditions.download
      });
    }
    async setUserAgent(userAgent, userAgentMetadata) {
      this.#userAgent = userAgent;
      this.#userAgentMetadata = userAgentMetadata;
      await this.#applyToAllClients(this.#applyUserAgent.bind(this));
    }
    async #applyUserAgent(client) {
      if (this.#userAgent === void 0) {
        return;
      }
      await client.send("Network.setUserAgentOverride", {
        userAgent: this.#userAgent,
        userAgentMetadata: this.#userAgentMetadata
      });
    }
    async setCacheEnabled(enabled) {
      this.#userCacheDisabled = !enabled;
      await this.#applyToAllClients(this.#applyProtocolCacheDisabled.bind(this));
    }
    async setRequestInterception(value) {
      this.#userRequestInterceptionEnabled = value;
      const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;
      if (enabled === this.#protocolRequestInterceptionEnabled) {
        return;
      }
      this.#protocolRequestInterceptionEnabled = enabled;
      await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
    }
    async #applyProtocolRequestInterception(client) {
      if (this.#userCacheDisabled === void 0) {
        this.#userCacheDisabled = false;
      }
      if (this.#protocolRequestInterceptionEnabled) {
        await Promise.all([
          this.#applyProtocolCacheDisabled(client),
          client.send("Fetch.enable", {
            handleAuthRequests: true,
            patterns: [{ urlPattern: "*" }]
          })
        ]);
      } else {
        await Promise.all([
          this.#applyProtocolCacheDisabled(client),
          client.send("Fetch.disable")
        ]);
      }
    }
    async #applyProtocolCacheDisabled(client) {
      if (this.#userCacheDisabled === void 0) {
        return;
      }
      await client.send("Network.setCacheDisabled", {
        cacheDisabled: this.#userCacheDisabled
      });
    }
    #onRequestWillBeSent(client, event) {
      if (this.#userRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
        const { requestId: networkRequestId } = event;
        this.#networkEventManager.storeRequestWillBeSent(networkRequestId, event);
        const requestPausedEvent = this.#networkEventManager.getRequestPaused(networkRequestId);
        if (requestPausedEvent) {
          const { requestId: fetchRequestId } = requestPausedEvent;
          this.#patchRequestEventHeaders(event, requestPausedEvent);
          this.#onRequest(client, event, fetchRequestId);
          this.#networkEventManager.forgetRequestPaused(networkRequestId);
        }
        return;
      }
      this.#onRequest(client, event, void 0);
    }
    #onAuthRequired(client, event) {
      let response = "Default";
      if (this.#attemptedAuthentications.has(event.requestId)) {
        response = "CancelAuth";
      } else if (this.#credentials) {
        response = "ProvideCredentials";
        this.#attemptedAuthentications.add(event.requestId);
      }
      const { username, password } = this.#credentials || {
        username: void 0,
        password: void 0
      };
      client.send("Fetch.continueWithAuth", {
        requestId: event.requestId,
        authChallengeResponse: { response, username, password }
      }).catch(debugError);
    }
    /**
     * CDP may send a Fetch.requestPaused without or before a
     * Network.requestWillBeSent
     *
     * CDP may send multiple Fetch.requestPaused
     * for the same Network.requestWillBeSent.
     */
    #onRequestPaused(client, event) {
      if (!this.#userRequestInterceptionEnabled && this.#protocolRequestInterceptionEnabled) {
        client.send("Fetch.continueRequest", {
          requestId: event.requestId
        }).catch(debugError);
      }
      const { networkId: networkRequestId, requestId: fetchRequestId } = event;
      if (!networkRequestId) {
        this.#onRequestWithoutNetworkInstrumentation(client, event);
        return;
      }
      const requestWillBeSentEvent = (() => {
        const requestWillBeSentEvent2 = this.#networkEventManager.getRequestWillBeSent(networkRequestId);
        if (requestWillBeSentEvent2 && (requestWillBeSentEvent2.request.url !== event.request.url || requestWillBeSentEvent2.request.method !== event.request.method)) {
          this.#networkEventManager.forgetRequestWillBeSent(networkRequestId);
          return;
        }
        return requestWillBeSentEvent2;
      })();
      if (requestWillBeSentEvent) {
        this.#patchRequestEventHeaders(requestWillBeSentEvent, event);
        this.#onRequest(client, requestWillBeSentEvent, fetchRequestId);
      } else {
        this.#networkEventManager.storeRequestPaused(networkRequestId, event);
      }
    }
    #patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {
      requestWillBeSentEvent.request.headers = {
        ...requestWillBeSentEvent.request.headers,
        // includes extra headers, like: Accept, Origin
        ...requestPausedEvent.request.headers
      };
    }
    #onRequestWithoutNetworkInstrumentation(client, event) {
      const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;
      const request = new CdpHTTPRequest(client, frame, event.requestId, this.#userRequestInterceptionEnabled, event, []);
      this.emit(NetworkManagerEvent.Request, request);
      void request.finalizeInterceptions();
    }
    #onRequest(client, event, fetchRequestId) {
      let redirectChain = [];
      if (event.redirectResponse) {
        let redirectResponseExtraInfo = null;
        if (event.redirectHasExtraInfo) {
          redirectResponseExtraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();
          if (!redirectResponseExtraInfo) {
            this.#networkEventManager.queueRedirectInfo(event.requestId, {
              event,
              fetchRequestId
            });
            return;
          }
        }
        const request2 = this.#networkEventManager.getRequest(event.requestId);
        if (request2) {
          this.#handleRequestRedirect(client, request2, event.redirectResponse, redirectResponseExtraInfo);
          redirectChain = request2._redirectChain;
        }
      }
      const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;
      const request = new CdpHTTPRequest(client, frame, fetchRequestId, this.#userRequestInterceptionEnabled, event, redirectChain);
      this.#networkEventManager.storeRequest(event.requestId, request);
      this.emit(NetworkManagerEvent.Request, request);
      void request.finalizeInterceptions();
    }
    #onRequestServedFromCache(_client, event) {
      const request = this.#networkEventManager.getRequest(event.requestId);
      if (request) {
        request._fromMemoryCache = true;
      }
      this.emit(NetworkManagerEvent.RequestServedFromCache, request);
    }
    #handleRequestRedirect(client, request, responsePayload, extraInfo) {
      const response = new CdpHTTPResponse(client, request, responsePayload, extraInfo);
      request._response = response;
      request._redirectChain.push(request);
      response._resolveBody(new Error("Response body is unavailable for redirect responses"));
      this.#forgetRequest(request, false);
      this.emit(NetworkManagerEvent.Response, response);
      this.emit(NetworkManagerEvent.RequestFinished, request);
    }
    #emitResponseEvent(client, responseReceived, extraInfo) {
      const request = this.#networkEventManager.getRequest(responseReceived.requestId);
      if (!request) {
        return;
      }
      const extraInfos = this.#networkEventManager.responseExtraInfo(responseReceived.requestId);
      if (extraInfos.length) {
        debugError(new Error("Unexpected extraInfo events for request " + responseReceived.requestId));
      }
      if (responseReceived.response.fromDiskCache) {
        extraInfo = null;
      }
      const response = new CdpHTTPResponse(client, request, responseReceived.response, extraInfo);
      request._response = response;
      this.emit(NetworkManagerEvent.Response, response);
    }
    #onResponseReceived(client, event) {
      const request = this.#networkEventManager.getRequest(event.requestId);
      let extraInfo = null;
      if (request && !request._fromMemoryCache && event.hasExtraInfo) {
        extraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();
        if (!extraInfo) {
          this.#networkEventManager.queueEventGroup(event.requestId, {
            responseReceivedEvent: event
          });
          return;
        }
      }
      this.#emitResponseEvent(client, event, extraInfo);
    }
    #onResponseReceivedExtraInfo(client, event) {
      const redirectInfo = this.#networkEventManager.takeQueuedRedirectInfo(event.requestId);
      if (redirectInfo) {
        this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
        this.#onRequest(client, redirectInfo.event, redirectInfo.fetchRequestId);
        return;
      }
      const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
      if (queuedEvents) {
        this.#networkEventManager.forgetQueuedEventGroup(event.requestId);
        this.#emitResponseEvent(client, queuedEvents.responseReceivedEvent, event);
        if (queuedEvents.loadingFinishedEvent) {
          this.#emitLoadingFinished(queuedEvents.loadingFinishedEvent);
        }
        if (queuedEvents.loadingFailedEvent) {
          this.#emitLoadingFailed(queuedEvents.loadingFailedEvent);
        }
        return;
      }
      this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
    }
    #forgetRequest(request, events) {
      const requestId = request.id;
      const interceptionId = request._interceptionId;
      this.#networkEventManager.forgetRequest(requestId);
      interceptionId !== void 0 && this.#attemptedAuthentications.delete(interceptionId);
      if (events) {
        this.#networkEventManager.forget(requestId);
      }
    }
    #onLoadingFinished(_client, event) {
      const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
      if (queuedEvents) {
        queuedEvents.loadingFinishedEvent = event;
      } else {
        this.#emitLoadingFinished(event);
      }
    }
    #emitLoadingFinished(event) {
      const request = this.#networkEventManager.getRequest(event.requestId);
      if (!request) {
        return;
      }
      if (request.response()) {
        request.response()?._resolveBody();
      }
      this.#forgetRequest(request, true);
      this.emit(NetworkManagerEvent.RequestFinished, request);
    }
    #onLoadingFailed(_client, event) {
      const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
      if (queuedEvents) {
        queuedEvents.loadingFailedEvent = event;
      } else {
        this.#emitLoadingFailed(event);
      }
    }
    #emitLoadingFailed(event) {
      const request = this.#networkEventManager.getRequest(event.requestId);
      if (!request) {
        return;
      }
      request._failureText = event.errorText;
      const response = request.response();
      if (response) {
        response._resolveBody();
      }
      this.#forgetRequest(request, true);
      this.emit(NetworkManagerEvent.RequestFailed, request);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameManager.js
  var TIME_FOR_WAITING_FOR_SWAP = 100;
  var FrameManager = class extends EventEmitter2 {
    #page;
    #networkManager;
    #timeoutSettings;
    #contextIdToContext = /* @__PURE__ */ new Map();
    #isolatedWorlds = /* @__PURE__ */ new Set();
    #client;
    _frameTree = new FrameTree();
    /**
     * Set of frame IDs stored to indicate if a frame has received a
     * frameNavigated event so that frame tree responses could be ignored as the
     * frameNavigated event usually contains the latest information.
     */
    #frameNavigatedReceived = /* @__PURE__ */ new Set();
    #deviceRequestPromptManagerMap = /* @__PURE__ */ new WeakMap();
    #frameTreeHandled;
    get timeoutSettings() {
      return this.#timeoutSettings;
    }
    get networkManager() {
      return this.#networkManager;
    }
    get client() {
      return this.#client;
    }
    constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {
      super();
      this.#client = client;
      this.#page = page;
      this.#networkManager = new NetworkManager(ignoreHTTPSErrors, this);
      this.#timeoutSettings = timeoutSettings;
      this.setupEventListeners(this.#client);
      client.once(CDPSessionEvent.Disconnected, () => {
        this.#onClientDisconnect().catch(debugError);
      });
    }
    /**
     * Called when the frame's client is disconnected. We don't know if the
     * disconnect means that the frame is removed or if it will be replaced by a
     * new frame. Therefore, we wait for a swap event.
     */
    async #onClientDisconnect() {
      const mainFrame = this._frameTree.getMainFrame();
      if (!mainFrame) {
        return;
      }
      for (const child of mainFrame.childFrames()) {
        this.#removeFramesRecursively(child);
      }
      const swapped = Deferred.create({
        timeout: TIME_FOR_WAITING_FOR_SWAP,
        message: "Frame was not swapped"
      });
      mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {
        swapped.resolve();
      });
      try {
        await swapped.valueOrThrow();
      } catch (err) {
        this.#removeFramesRecursively(mainFrame);
      }
    }
    /**
     * When the main frame is replaced by another main frame,
     * we maintain the main frame object identity while updating
     * its frame tree and ID.
     */
    async swapFrameTree(client) {
      this.#onExecutionContextsCleared(this.#client);
      this.#client = client;
      assert(this.#client instanceof CdpCDPSession, "CDPSession is not an instance of CDPSessionImpl.");
      const frame = this._frameTree.getMainFrame();
      if (frame) {
        this.#frameNavigatedReceived.add(this.#client._target()._targetId);
        this._frameTree.removeFrame(frame);
        frame.updateId(this.#client._target()._targetId);
        frame.mainRealm().clearContext();
        frame.isolatedRealm().clearContext();
        this._frameTree.addFrame(frame);
        frame.updateClient(client, true);
      }
      this.setupEventListeners(client);
      client.once(CDPSessionEvent.Disconnected, () => {
        this.#onClientDisconnect().catch(debugError);
      });
      await this.initialize(client);
      await this.#networkManager.addClient(client);
      if (frame) {
        frame.emit(FrameEvent.FrameSwappedByActivation, void 0);
      }
    }
    async registerSpeculativeSession(client) {
      await this.#networkManager.addClient(client);
    }
    setupEventListeners(session) {
      session.on("Page.frameAttached", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onFrameAttached(session, event.frameId, event.parentFrameId);
      });
      session.on("Page.frameNavigated", async (event) => {
        this.#frameNavigatedReceived.add(event.frame.id);
        await this.#frameTreeHandled?.valueOrThrow();
        void this.#onFrameNavigated(event.frame, event.type);
      });
      session.on("Page.navigatedWithinDocument", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onFrameNavigatedWithinDocument(event.frameId, event.url);
      });
      session.on("Page.frameDetached", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onFrameDetached(event.frameId, event.reason);
      });
      session.on("Page.frameStartedLoading", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onFrameStartedLoading(event.frameId);
      });
      session.on("Page.frameStoppedLoading", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onFrameStoppedLoading(event.frameId);
      });
      session.on("Runtime.executionContextCreated", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onExecutionContextCreated(event.context, session);
      });
      session.on("Runtime.executionContextDestroyed", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onExecutionContextDestroyed(event.executionContextId, session);
      });
      session.on("Runtime.executionContextsCleared", async () => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onExecutionContextsCleared(session);
      });
      session.on("Page.lifecycleEvent", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onLifecycleEvent(event);
      });
    }
    async initialize(client) {
      try {
        this.#frameTreeHandled?.resolve();
        this.#frameTreeHandled = Deferred.create();
        await Promise.all([
          this.#networkManager.addClient(client),
          client.send("Page.enable"),
          client.send("Page.getFrameTree").then(({ frameTree }) => {
            this.#handleFrameTree(client, frameTree);
            this.#frameTreeHandled?.resolve();
          }),
          client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
          client.send("Runtime.enable").then(() => {
            return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
          })
        ]);
      } catch (error) {
        this.#frameTreeHandled?.resolve();
        if (isErrorLike(error) && isTargetClosedError(error)) {
          return;
        }
        throw error;
      }
    }
    executionContextById(contextId, session = this.#client) {
      const context2 = this.getExecutionContextById(contextId, session);
      assert(context2, "INTERNAL ERROR: missing context with id = " + contextId);
      return context2;
    }
    getExecutionContextById(contextId, session = this.#client) {
      return this.#contextIdToContext.get(`${session.id()}:${contextId}`);
    }
    page() {
      return this.#page;
    }
    mainFrame() {
      const mainFrame = this._frameTree.getMainFrame();
      assert(mainFrame, "Requesting main frame too early!");
      return mainFrame;
    }
    frames() {
      return Array.from(this._frameTree.frames());
    }
    frame(frameId) {
      return this._frameTree.getById(frameId) || null;
    }
    onAttachedToTarget(target) {
      if (target._getTargetInfo().type !== "iframe") {
        return;
      }
      const frame = this.frame(target._getTargetInfo().targetId);
      if (frame) {
        frame.updateClient(target._session());
      }
      this.setupEventListeners(target._session());
      void this.initialize(target._session());
    }
    _deviceRequestPromptManager(client) {
      let manager = this.#deviceRequestPromptManagerMap.get(client);
      if (manager === void 0) {
        manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);
        this.#deviceRequestPromptManagerMap.set(client, manager);
      }
      return manager;
    }
    #onLifecycleEvent(event) {
      const frame = this.frame(event.frameId);
      if (!frame) {
        return;
      }
      frame._onLifecycleEvent(event.loaderId, event.name);
      this.emit(FrameManagerEvent.LifecycleEvent, frame);
      frame.emit(FrameEvent.LifecycleEvent, void 0);
    }
    #onFrameStartedLoading(frameId) {
      const frame = this.frame(frameId);
      if (!frame) {
        return;
      }
      frame._onLoadingStarted();
    }
    #onFrameStoppedLoading(frameId) {
      const frame = this.frame(frameId);
      if (!frame) {
        return;
      }
      frame._onLoadingStopped();
      this.emit(FrameManagerEvent.LifecycleEvent, frame);
      frame.emit(FrameEvent.LifecycleEvent, void 0);
    }
    #handleFrameTree(session, frameTree) {
      if (frameTree.frame.parentId) {
        this.#onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);
      }
      if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {
        void this.#onFrameNavigated(frameTree.frame, "Navigation");
      } else {
        this.#frameNavigatedReceived.delete(frameTree.frame.id);
      }
      if (!frameTree.childFrames) {
        return;
      }
      for (const child of frameTree.childFrames) {
        this.#handleFrameTree(session, child);
      }
    }
    #onFrameAttached(session, frameId, parentFrameId) {
      let frame = this.frame(frameId);
      if (frame) {
        if (session && frame.isOOPFrame()) {
          frame.updateClient(session);
        }
        return;
      }
      frame = new CdpFrame(this, frameId, parentFrameId, session);
      this._frameTree.addFrame(frame);
      this.emit(FrameManagerEvent.FrameAttached, frame);
    }
    async #onFrameNavigated(framePayload, navigationType) {
      const frameId = framePayload.id;
      const isMainFrame = !framePayload.parentId;
      let frame = this._frameTree.getById(frameId);
      if (frame) {
        for (const child of frame.childFrames()) {
          this.#removeFramesRecursively(child);
        }
      }
      if (isMainFrame) {
        if (frame) {
          this._frameTree.removeFrame(frame);
          frame._id = frameId;
        } else {
          frame = new CdpFrame(this, frameId, void 0, this.#client);
        }
        this._frameTree.addFrame(frame);
      }
      frame = await this._frameTree.waitForFrame(frameId);
      frame._navigated(framePayload);
      this.emit(FrameManagerEvent.FrameNavigated, frame);
      frame.emit(FrameEvent.FrameNavigated, navigationType);
    }
    async #createIsolatedWorld(session, name2) {
      const key = `${session.id()}:${name2}`;
      if (this.#isolatedWorlds.has(key)) {
        return;
      }
      await session.send("Page.addScriptToEvaluateOnNewDocument", {
        source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,
        worldName: name2
      });
      await Promise.all(this.frames().filter((frame) => {
        return frame.client === session;
      }).map((frame) => {
        return session.send("Page.createIsolatedWorld", {
          frameId: frame._id,
          worldName: name2,
          grantUniveralAccess: true
        }).catch(debugError);
      }));
      this.#isolatedWorlds.add(key);
    }
    #onFrameNavigatedWithinDocument(frameId, url) {
      const frame = this.frame(frameId);
      if (!frame) {
        return;
      }
      frame._navigatedWithinDocument(url);
      this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);
      frame.emit(FrameEvent.FrameNavigatedWithinDocument, void 0);
      this.emit(FrameManagerEvent.FrameNavigated, frame);
      frame.emit(FrameEvent.FrameNavigated, "Navigation");
    }
    #onFrameDetached(frameId, reason) {
      const frame = this.frame(frameId);
      if (!frame) {
        return;
      }
      switch (reason) {
        case "remove":
          this.#removeFramesRecursively(frame);
          break;
        case "swap":
          this.emit(FrameManagerEvent.FrameSwapped, frame);
          frame.emit(FrameEvent.FrameSwapped, void 0);
          break;
      }
    }
    #onExecutionContextCreated(contextPayload, session) {
      const auxData = contextPayload.auxData;
      const frameId = auxData && auxData.frameId;
      const frame = typeof frameId === "string" ? this.frame(frameId) : void 0;
      let world;
      if (frame) {
        if (frame.client !== session) {
          return;
        }
        if (contextPayload.auxData && contextPayload.auxData["isDefault"]) {
          world = frame.worlds[MAIN_WORLD];
        } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame.worlds[PUPPETEER_WORLD].hasContext()) {
          world = frame.worlds[PUPPETEER_WORLD];
        }
      }
      if (!world) {
        return;
      }
      const context2 = new ExecutionContext(frame?.client || this.#client, contextPayload, world);
      if (world) {
        world.setContext(context2);
      }
      const key = `${session.id()}:${contextPayload.id}`;
      this.#contextIdToContext.set(key, context2);
    }
    #onExecutionContextDestroyed(executionContextId, session) {
      const key = `${session.id()}:${executionContextId}`;
      const context2 = this.#contextIdToContext.get(key);
      if (!context2) {
        return;
      }
      this.#contextIdToContext.delete(key);
      if (context2._world) {
        context2._world.clearContext();
      }
    }
    #onExecutionContextsCleared(session) {
      for (const [key, context2] of this.#contextIdToContext.entries()) {
        if (context2._client !== session) {
          continue;
        }
        if (context2._world) {
          context2._world.clearContext();
        }
        this.#contextIdToContext.delete(key);
      }
    }
    #removeFramesRecursively(frame) {
      for (const child of frame.childFrames()) {
        this.#removeFramesRecursively(child);
      }
      frame[disposeSymbol]();
      this._frameTree.removeFrame(frame);
      this.emit(FrameManagerEvent.FrameDetached, frame);
      frame.emit(FrameEvent.FrameDetached, frame);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Input.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Input.js
  init_dirname();
  init_buffer2();
  var Keyboard = class {
    /**
     * @internal
     */
    constructor() {
    }
  };
  var MouseButton = Object.freeze({
    Left: "left",
    Right: "right",
    Middle: "middle",
    Back: "back",
    Forward: "forward"
  });
  var Mouse = class {
    /**
     * @internal
     */
    constructor() {
    }
  };
  var Touchscreen = class {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * Dispatches a `touchstart` and `touchend` event.
     * @param x - Horizontal position of the tap.
     * @param y - Vertical position of the tap.
     */
    async tap(x4, y6) {
      await this.touchStart(x4, y6);
      await this.touchEnd();
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/USKeyboardLayout.js
  init_dirname();
  init_buffer2();
  var _keyDefinitions = {
    "0": { keyCode: 48, key: "0", code: "Digit0" },
    "1": { keyCode: 49, key: "1", code: "Digit1" },
    "2": { keyCode: 50, key: "2", code: "Digit2" },
    "3": { keyCode: 51, key: "3", code: "Digit3" },
    "4": { keyCode: 52, key: "4", code: "Digit4" },
    "5": { keyCode: 53, key: "5", code: "Digit5" },
    "6": { keyCode: 54, key: "6", code: "Digit6" },
    "7": { keyCode: 55, key: "7", code: "Digit7" },
    "8": { keyCode: 56, key: "8", code: "Digit8" },
    "9": { keyCode: 57, key: "9", code: "Digit9" },
    Power: { key: "Power", code: "Power" },
    Eject: { key: "Eject", code: "Eject" },
    Abort: { keyCode: 3, code: "Abort", key: "Cancel" },
    Help: { keyCode: 6, code: "Help", key: "Help" },
    Backspace: { keyCode: 8, code: "Backspace", key: "Backspace" },
    Tab: { keyCode: 9, code: "Tab", key: "Tab" },
    Numpad5: {
      keyCode: 12,
      shiftKeyCode: 101,
      key: "Clear",
      code: "Numpad5",
      shiftKey: "5",
      location: 3
    },
    NumpadEnter: {
      keyCode: 13,
      code: "NumpadEnter",
      key: "Enter",
      text: "\r",
      location: 3
    },
    Enter: { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    "\r": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    "\n": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    ShiftLeft: { keyCode: 16, code: "ShiftLeft", key: "Shift", location: 1 },
    ShiftRight: { keyCode: 16, code: "ShiftRight", key: "Shift", location: 2 },
    ControlLeft: {
      keyCode: 17,
      code: "ControlLeft",
      key: "Control",
      location: 1
    },
    ControlRight: {
      keyCode: 17,
      code: "ControlRight",
      key: "Control",
      location: 2
    },
    AltLeft: { keyCode: 18, code: "AltLeft", key: "Alt", location: 1 },
    AltRight: { keyCode: 18, code: "AltRight", key: "Alt", location: 2 },
    Pause: { keyCode: 19, code: "Pause", key: "Pause" },
    CapsLock: { keyCode: 20, code: "CapsLock", key: "CapsLock" },
    Escape: { keyCode: 27, code: "Escape", key: "Escape" },
    Convert: { keyCode: 28, code: "Convert", key: "Convert" },
    NonConvert: { keyCode: 29, code: "NonConvert", key: "NonConvert" },
    Space: { keyCode: 32, code: "Space", key: " " },
    Numpad9: {
      keyCode: 33,
      shiftKeyCode: 105,
      key: "PageUp",
      code: "Numpad9",
      shiftKey: "9",
      location: 3
    },
    PageUp: { keyCode: 33, code: "PageUp", key: "PageUp" },
    Numpad3: {
      keyCode: 34,
      shiftKeyCode: 99,
      key: "PageDown",
      code: "Numpad3",
      shiftKey: "3",
      location: 3
    },
    PageDown: { keyCode: 34, code: "PageDown", key: "PageDown" },
    End: { keyCode: 35, code: "End", key: "End" },
    Numpad1: {
      keyCode: 35,
      shiftKeyCode: 97,
      key: "End",
      code: "Numpad1",
      shiftKey: "1",
      location: 3
    },
    Home: { keyCode: 36, code: "Home", key: "Home" },
    Numpad7: {
      keyCode: 36,
      shiftKeyCode: 103,
      key: "Home",
      code: "Numpad7",
      shiftKey: "7",
      location: 3
    },
    ArrowLeft: { keyCode: 37, code: "ArrowLeft", key: "ArrowLeft" },
    Numpad4: {
      keyCode: 37,
      shiftKeyCode: 100,
      key: "ArrowLeft",
      code: "Numpad4",
      shiftKey: "4",
      location: 3
    },
    Numpad8: {
      keyCode: 38,
      shiftKeyCode: 104,
      key: "ArrowUp",
      code: "Numpad8",
      shiftKey: "8",
      location: 3
    },
    ArrowUp: { keyCode: 38, code: "ArrowUp", key: "ArrowUp" },
    ArrowRight: { keyCode: 39, code: "ArrowRight", key: "ArrowRight" },
    Numpad6: {
      keyCode: 39,
      shiftKeyCode: 102,
      key: "ArrowRight",
      code: "Numpad6",
      shiftKey: "6",
      location: 3
    },
    Numpad2: {
      keyCode: 40,
      shiftKeyCode: 98,
      key: "ArrowDown",
      code: "Numpad2",
      shiftKey: "2",
      location: 3
    },
    ArrowDown: { keyCode: 40, code: "ArrowDown", key: "ArrowDown" },
    Select: { keyCode: 41, code: "Select", key: "Select" },
    Open: { keyCode: 43, code: "Open", key: "Execute" },
    PrintScreen: { keyCode: 44, code: "PrintScreen", key: "PrintScreen" },
    Insert: { keyCode: 45, code: "Insert", key: "Insert" },
    Numpad0: {
      keyCode: 45,
      shiftKeyCode: 96,
      key: "Insert",
      code: "Numpad0",
      shiftKey: "0",
      location: 3
    },
    Delete: { keyCode: 46, code: "Delete", key: "Delete" },
    NumpadDecimal: {
      keyCode: 46,
      shiftKeyCode: 110,
      code: "NumpadDecimal",
      key: "\0",
      shiftKey: ".",
      location: 3
    },
    Digit0: { keyCode: 48, code: "Digit0", shiftKey: ")", key: "0" },
    Digit1: { keyCode: 49, code: "Digit1", shiftKey: "!", key: "1" },
    Digit2: { keyCode: 50, code: "Digit2", shiftKey: "@", key: "2" },
    Digit3: { keyCode: 51, code: "Digit3", shiftKey: "#", key: "3" },
    Digit4: { keyCode: 52, code: "Digit4", shiftKey: "$", key: "4" },
    Digit5: { keyCode: 53, code: "Digit5", shiftKey: "%", key: "5" },
    Digit6: { keyCode: 54, code: "Digit6", shiftKey: "^", key: "6" },
    Digit7: { keyCode: 55, code: "Digit7", shiftKey: "&", key: "7" },
    Digit8: { keyCode: 56, code: "Digit8", shiftKey: "*", key: "8" },
    Digit9: { keyCode: 57, code: "Digit9", shiftKey: "(", key: "9" },
    KeyA: { keyCode: 65, code: "KeyA", shiftKey: "A", key: "a" },
    KeyB: { keyCode: 66, code: "KeyB", shiftKey: "B", key: "b" },
    KeyC: { keyCode: 67, code: "KeyC", shiftKey: "C", key: "c" },
    KeyD: { keyCode: 68, code: "KeyD", shiftKey: "D", key: "d" },
    KeyE: { keyCode: 69, code: "KeyE", shiftKey: "E", key: "e" },
    KeyF: { keyCode: 70, code: "KeyF", shiftKey: "F", key: "f" },
    KeyG: { keyCode: 71, code: "KeyG", shiftKey: "G", key: "g" },
    KeyH: { keyCode: 72, code: "KeyH", shiftKey: "H", key: "h" },
    KeyI: { keyCode: 73, code: "KeyI", shiftKey: "I", key: "i" },
    KeyJ: { keyCode: 74, code: "KeyJ", shiftKey: "J", key: "j" },
    KeyK: { keyCode: 75, code: "KeyK", shiftKey: "K", key: "k" },
    KeyL: { keyCode: 76, code: "KeyL", shiftKey: "L", key: "l" },
    KeyM: { keyCode: 77, code: "KeyM", shiftKey: "M", key: "m" },
    KeyN: { keyCode: 78, code: "KeyN", shiftKey: "N", key: "n" },
    KeyO: { keyCode: 79, code: "KeyO", shiftKey: "O", key: "o" },
    KeyP: { keyCode: 80, code: "KeyP", shiftKey: "P", key: "p" },
    KeyQ: { keyCode: 81, code: "KeyQ", shiftKey: "Q", key: "q" },
    KeyR: { keyCode: 82, code: "KeyR", shiftKey: "R", key: "r" },
    KeyS: { keyCode: 83, code: "KeyS", shiftKey: "S", key: "s" },
    KeyT: { keyCode: 84, code: "KeyT", shiftKey: "T", key: "t" },
    KeyU: { keyCode: 85, code: "KeyU", shiftKey: "U", key: "u" },
    KeyV: { keyCode: 86, code: "KeyV", shiftKey: "V", key: "v" },
    KeyW: { keyCode: 87, code: "KeyW", shiftKey: "W", key: "w" },
    KeyX: { keyCode: 88, code: "KeyX", shiftKey: "X", key: "x" },
    KeyY: { keyCode: 89, code: "KeyY", shiftKey: "Y", key: "y" },
    KeyZ: { keyCode: 90, code: "KeyZ", shiftKey: "Z", key: "z" },
    MetaLeft: { keyCode: 91, code: "MetaLeft", key: "Meta", location: 1 },
    MetaRight: { keyCode: 92, code: "MetaRight", key: "Meta", location: 2 },
    ContextMenu: { keyCode: 93, code: "ContextMenu", key: "ContextMenu" },
    NumpadMultiply: {
      keyCode: 106,
      code: "NumpadMultiply",
      key: "*",
      location: 3
    },
    NumpadAdd: { keyCode: 107, code: "NumpadAdd", key: "+", location: 3 },
    NumpadSubtract: {
      keyCode: 109,
      code: "NumpadSubtract",
      key: "-",
      location: 3
    },
    NumpadDivide: { keyCode: 111, code: "NumpadDivide", key: "/", location: 3 },
    F1: { keyCode: 112, code: "F1", key: "F1" },
    F2: { keyCode: 113, code: "F2", key: "F2" },
    F3: { keyCode: 114, code: "F3", key: "F3" },
    F4: { keyCode: 115, code: "F4", key: "F4" },
    F5: { keyCode: 116, code: "F5", key: "F5" },
    F6: { keyCode: 117, code: "F6", key: "F6" },
    F7: { keyCode: 118, code: "F7", key: "F7" },
    F8: { keyCode: 119, code: "F8", key: "F8" },
    F9: { keyCode: 120, code: "F9", key: "F9" },
    F10: { keyCode: 121, code: "F10", key: "F10" },
    F11: { keyCode: 122, code: "F11", key: "F11" },
    F12: { keyCode: 123, code: "F12", key: "F12" },
    F13: { keyCode: 124, code: "F13", key: "F13" },
    F14: { keyCode: 125, code: "F14", key: "F14" },
    F15: { keyCode: 126, code: "F15", key: "F15" },
    F16: { keyCode: 127, code: "F16", key: "F16" },
    F17: { keyCode: 128, code: "F17", key: "F17" },
    F18: { keyCode: 129, code: "F18", key: "F18" },
    F19: { keyCode: 130, code: "F19", key: "F19" },
    F20: { keyCode: 131, code: "F20", key: "F20" },
    F21: { keyCode: 132, code: "F21", key: "F21" },
    F22: { keyCode: 133, code: "F22", key: "F22" },
    F23: { keyCode: 134, code: "F23", key: "F23" },
    F24: { keyCode: 135, code: "F24", key: "F24" },
    NumLock: { keyCode: 144, code: "NumLock", key: "NumLock" },
    ScrollLock: { keyCode: 145, code: "ScrollLock", key: "ScrollLock" },
    AudioVolumeMute: {
      keyCode: 173,
      code: "AudioVolumeMute",
      key: "AudioVolumeMute"
    },
    AudioVolumeDown: {
      keyCode: 174,
      code: "AudioVolumeDown",
      key: "AudioVolumeDown"
    },
    AudioVolumeUp: { keyCode: 175, code: "AudioVolumeUp", key: "AudioVolumeUp" },
    MediaTrackNext: {
      keyCode: 176,
      code: "MediaTrackNext",
      key: "MediaTrackNext"
    },
    MediaTrackPrevious: {
      keyCode: 177,
      code: "MediaTrackPrevious",
      key: "MediaTrackPrevious"
    },
    MediaStop: { keyCode: 178, code: "MediaStop", key: "MediaStop" },
    MediaPlayPause: {
      keyCode: 179,
      code: "MediaPlayPause",
      key: "MediaPlayPause"
    },
    Semicolon: { keyCode: 186, code: "Semicolon", shiftKey: ":", key: ";" },
    Equal: { keyCode: 187, code: "Equal", shiftKey: "+", key: "=" },
    NumpadEqual: { keyCode: 187, code: "NumpadEqual", key: "=", location: 3 },
    Comma: { keyCode: 188, code: "Comma", shiftKey: "<", key: "," },
    Minus: { keyCode: 189, code: "Minus", shiftKey: "_", key: "-" },
    Period: { keyCode: 190, code: "Period", shiftKey: ">", key: "." },
    Slash: { keyCode: 191, code: "Slash", shiftKey: "?", key: "/" },
    Backquote: { keyCode: 192, code: "Backquote", shiftKey: "~", key: "`" },
    BracketLeft: { keyCode: 219, code: "BracketLeft", shiftKey: "{", key: "[" },
    Backslash: { keyCode: 220, code: "Backslash", shiftKey: "|", key: "\\" },
    BracketRight: { keyCode: 221, code: "BracketRight", shiftKey: "}", key: "]" },
    Quote: { keyCode: 222, code: "Quote", shiftKey: '"', key: "'" },
    AltGraph: { keyCode: 225, code: "AltGraph", key: "AltGraph" },
    Props: { keyCode: 247, code: "Props", key: "CrSel" },
    Cancel: { keyCode: 3, key: "Cancel", code: "Abort" },
    Clear: { keyCode: 12, key: "Clear", code: "Numpad5", location: 3 },
    Shift: { keyCode: 16, key: "Shift", code: "ShiftLeft", location: 1 },
    Control: { keyCode: 17, key: "Control", code: "ControlLeft", location: 1 },
    Alt: { keyCode: 18, key: "Alt", code: "AltLeft", location: 1 },
    Accept: { keyCode: 30, key: "Accept" },
    ModeChange: { keyCode: 31, key: "ModeChange" },
    " ": { keyCode: 32, key: " ", code: "Space" },
    Print: { keyCode: 42, key: "Print" },
    Execute: { keyCode: 43, key: "Execute", code: "Open" },
    "\0": { keyCode: 46, key: "\0", code: "NumpadDecimal", location: 3 },
    a: { keyCode: 65, key: "a", code: "KeyA" },
    b: { keyCode: 66, key: "b", code: "KeyB" },
    c: { keyCode: 67, key: "c", code: "KeyC" },
    d: { keyCode: 68, key: "d", code: "KeyD" },
    e: { keyCode: 69, key: "e", code: "KeyE" },
    f: { keyCode: 70, key: "f", code: "KeyF" },
    g: { keyCode: 71, key: "g", code: "KeyG" },
    h: { keyCode: 72, key: "h", code: "KeyH" },
    i: { keyCode: 73, key: "i", code: "KeyI" },
    j: { keyCode: 74, key: "j", code: "KeyJ" },
    k: { keyCode: 75, key: "k", code: "KeyK" },
    l: { keyCode: 76, key: "l", code: "KeyL" },
    m: { keyCode: 77, key: "m", code: "KeyM" },
    n: { keyCode: 78, key: "n", code: "KeyN" },
    o: { keyCode: 79, key: "o", code: "KeyO" },
    p: { keyCode: 80, key: "p", code: "KeyP" },
    q: { keyCode: 81, key: "q", code: "KeyQ" },
    r: { keyCode: 82, key: "r", code: "KeyR" },
    s: { keyCode: 83, key: "s", code: "KeyS" },
    t: { keyCode: 84, key: "t", code: "KeyT" },
    u: { keyCode: 85, key: "u", code: "KeyU" },
    v: { keyCode: 86, key: "v", code: "KeyV" },
    w: { keyCode: 87, key: "w", code: "KeyW" },
    x: { keyCode: 88, key: "x", code: "KeyX" },
    y: { keyCode: 89, key: "y", code: "KeyY" },
    z: { keyCode: 90, key: "z", code: "KeyZ" },
    Meta: { keyCode: 91, key: "Meta", code: "MetaLeft", location: 1 },
    "*": { keyCode: 106, key: "*", code: "NumpadMultiply", location: 3 },
    "+": { keyCode: 107, key: "+", code: "NumpadAdd", location: 3 },
    "-": { keyCode: 109, key: "-", code: "NumpadSubtract", location: 3 },
    "/": { keyCode: 111, key: "/", code: "NumpadDivide", location: 3 },
    ";": { keyCode: 186, key: ";", code: "Semicolon" },
    "=": { keyCode: 187, key: "=", code: "Equal" },
    ",": { keyCode: 188, key: ",", code: "Comma" },
    ".": { keyCode: 190, key: ".", code: "Period" },
    "`": { keyCode: 192, key: "`", code: "Backquote" },
    "[": { keyCode: 219, key: "[", code: "BracketLeft" },
    "\\": { keyCode: 220, key: "\\", code: "Backslash" },
    "]": { keyCode: 221, key: "]", code: "BracketRight" },
    "'": { keyCode: 222, key: "'", code: "Quote" },
    Attn: { keyCode: 246, key: "Attn" },
    CrSel: { keyCode: 247, key: "CrSel", code: "Props" },
    ExSel: { keyCode: 248, key: "ExSel" },
    EraseEof: { keyCode: 249, key: "EraseEof" },
    Play: { keyCode: 250, key: "Play" },
    ZoomOut: { keyCode: 251, key: "ZoomOut" },
    ")": { keyCode: 48, key: ")", code: "Digit0" },
    "!": { keyCode: 49, key: "!", code: "Digit1" },
    "@": { keyCode: 50, key: "@", code: "Digit2" },
    "#": { keyCode: 51, key: "#", code: "Digit3" },
    $: { keyCode: 52, key: "$", code: "Digit4" },
    "%": { keyCode: 53, key: "%", code: "Digit5" },
    "^": { keyCode: 54, key: "^", code: "Digit6" },
    "&": { keyCode: 55, key: "&", code: "Digit7" },
    "(": { keyCode: 57, key: "(", code: "Digit9" },
    A: { keyCode: 65, key: "A", code: "KeyA" },
    B: { keyCode: 66, key: "B", code: "KeyB" },
    C: { keyCode: 67, key: "C", code: "KeyC" },
    D: { keyCode: 68, key: "D", code: "KeyD" },
    E: { keyCode: 69, key: "E", code: "KeyE" },
    F: { keyCode: 70, key: "F", code: "KeyF" },
    G: { keyCode: 71, key: "G", code: "KeyG" },
    H: { keyCode: 72, key: "H", code: "KeyH" },
    I: { keyCode: 73, key: "I", code: "KeyI" },
    J: { keyCode: 74, key: "J", code: "KeyJ" },
    K: { keyCode: 75, key: "K", code: "KeyK" },
    L: { keyCode: 76, key: "L", code: "KeyL" },
    M: { keyCode: 77, key: "M", code: "KeyM" },
    N: { keyCode: 78, key: "N", code: "KeyN" },
    O: { keyCode: 79, key: "O", code: "KeyO" },
    P: { keyCode: 80, key: "P", code: "KeyP" },
    Q: { keyCode: 81, key: "Q", code: "KeyQ" },
    R: { keyCode: 82, key: "R", code: "KeyR" },
    S: { keyCode: 83, key: "S", code: "KeyS" },
    T: { keyCode: 84, key: "T", code: "KeyT" },
    U: { keyCode: 85, key: "U", code: "KeyU" },
    V: { keyCode: 86, key: "V", code: "KeyV" },
    W: { keyCode: 87, key: "W", code: "KeyW" },
    X: { keyCode: 88, key: "X", code: "KeyX" },
    Y: { keyCode: 89, key: "Y", code: "KeyY" },
    Z: { keyCode: 90, key: "Z", code: "KeyZ" },
    ":": { keyCode: 186, key: ":", code: "Semicolon" },
    "<": { keyCode: 188, key: "<", code: "Comma" },
    _: { keyCode: 189, key: "_", code: "Minus" },
    ">": { keyCode: 190, key: ">", code: "Period" },
    "?": { keyCode: 191, key: "?", code: "Slash" },
    "~": { keyCode: 192, key: "~", code: "Backquote" },
    "{": { keyCode: 219, key: "{", code: "BracketLeft" },
    "|": { keyCode: 220, key: "|", code: "Backslash" },
    "}": { keyCode: 221, key: "}", code: "BracketRight" },
    '"': { keyCode: 222, key: '"', code: "Quote" },
    SoftLeft: { key: "SoftLeft", code: "SoftLeft", location: 4 },
    SoftRight: { key: "SoftRight", code: "SoftRight", location: 4 },
    Camera: { keyCode: 44, key: "Camera", code: "Camera", location: 4 },
    Call: { key: "Call", code: "Call", location: 4 },
    EndCall: { keyCode: 95, key: "EndCall", code: "EndCall", location: 4 },
    VolumeDown: {
      keyCode: 182,
      key: "VolumeDown",
      code: "VolumeDown",
      location: 4
    },
    VolumeUp: { keyCode: 183, key: "VolumeUp", code: "VolumeUp", location: 4 }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Input.js
  init_assert();
  var CdpKeyboard = class extends Keyboard {
    #client;
    #pressedKeys = /* @__PURE__ */ new Set();
    _modifiers = 0;
    constructor(client) {
      super();
      this.#client = client;
    }
    updateClient(client) {
      this.#client = client;
    }
    async down(key, options = {
      text: void 0,
      commands: []
    }) {
      const description = this.#keyDescriptionForString(key);
      const autoRepeat = this.#pressedKeys.has(description.code);
      this.#pressedKeys.add(description.code);
      this._modifiers |= this.#modifierBit(description.key);
      const text = options.text === void 0 ? description.text : options.text;
      await this.#client.send("Input.dispatchKeyEvent", {
        type: text ? "keyDown" : "rawKeyDown",
        modifiers: this._modifiers,
        windowsVirtualKeyCode: description.keyCode,
        code: description.code,
        key: description.key,
        text,
        unmodifiedText: text,
        autoRepeat,
        location: description.location,
        isKeypad: description.location === 3,
        commands: options.commands
      });
    }
    #modifierBit(key) {
      if (key === "Alt") {
        return 1;
      }
      if (key === "Control") {
        return 2;
      }
      if (key === "Meta") {
        return 4;
      }
      if (key === "Shift") {
        return 8;
      }
      return 0;
    }
    #keyDescriptionForString(keyString) {
      const shift = this._modifiers & 8;
      const description = {
        key: "",
        keyCode: 0,
        code: "",
        text: "",
        location: 0
      };
      const definition = _keyDefinitions[keyString];
      assert(definition, `Unknown key: "${keyString}"`);
      if (definition.key) {
        description.key = definition.key;
      }
      if (shift && definition.shiftKey) {
        description.key = definition.shiftKey;
      }
      if (definition.keyCode) {
        description.keyCode = definition.keyCode;
      }
      if (shift && definition.shiftKeyCode) {
        description.keyCode = definition.shiftKeyCode;
      }
      if (definition.code) {
        description.code = definition.code;
      }
      if (definition.location) {
        description.location = definition.location;
      }
      if (description.key.length === 1) {
        description.text = description.key;
      }
      if (definition.text) {
        description.text = definition.text;
      }
      if (shift && definition.shiftText) {
        description.text = definition.shiftText;
      }
      if (this._modifiers & ~8) {
        description.text = "";
      }
      return description;
    }
    async up(key) {
      const description = this.#keyDescriptionForString(key);
      this._modifiers &= ~this.#modifierBit(description.key);
      this.#pressedKeys.delete(description.code);
      await this.#client.send("Input.dispatchKeyEvent", {
        type: "keyUp",
        modifiers: this._modifiers,
        key: description.key,
        windowsVirtualKeyCode: description.keyCode,
        code: description.code,
        location: description.location
      });
    }
    async sendCharacter(char) {
      await this.#client.send("Input.insertText", { text: char });
    }
    charIsKey(char) {
      return !!_keyDefinitions[char];
    }
    async type(text, options = {}) {
      const delay = options.delay || void 0;
      for (const char of text) {
        if (this.charIsKey(char)) {
          await this.press(char, { delay });
        } else {
          if (delay) {
            await new Promise((f7) => {
              return setTimeout(f7, delay);
            });
          }
          await this.sendCharacter(char);
        }
      }
    }
    async press(key, options = {}) {
      const { delay = null } = options;
      await this.down(key, options);
      if (delay) {
        await new Promise((f7) => {
          return setTimeout(f7, options.delay);
        });
      }
      await this.up(key);
    }
  };
  var getFlag = (button) => {
    switch (button) {
      case MouseButton.Left:
        return 1;
      case MouseButton.Right:
        return 2;
      case MouseButton.Middle:
        return 4;
      case MouseButton.Back:
        return 8;
      case MouseButton.Forward:
        return 16;
    }
  };
  var getButtonFromPressedButtons = (buttons) => {
    if (buttons & 1) {
      return MouseButton.Left;
    } else if (buttons & 2) {
      return MouseButton.Right;
    } else if (buttons & 4) {
      return MouseButton.Middle;
    } else if (buttons & 8) {
      return MouseButton.Back;
    } else if (buttons & 16) {
      return MouseButton.Forward;
    }
    return "none";
  };
  var CdpMouse = class extends Mouse {
    #client;
    #keyboard;
    constructor(client, keyboard) {
      super();
      this.#client = client;
      this.#keyboard = keyboard;
    }
    updateClient(client) {
      this.#client = client;
    }
    #_state = {
      position: { x: 0, y: 0 },
      buttons: 0
    };
    get #state() {
      return Object.assign({ ...this.#_state }, ...this.#transactions);
    }
    // Transactions can run in parallel, so we store each of thme in this array.
    #transactions = [];
    #createTransaction() {
      const transaction = {};
      this.#transactions.push(transaction);
      const popTransaction = () => {
        this.#transactions.splice(this.#transactions.indexOf(transaction), 1);
      };
      return {
        update: (updates) => {
          Object.assign(transaction, updates);
        },
        commit: () => {
          this.#_state = { ...this.#_state, ...transaction };
          popTransaction();
        },
        rollback: popTransaction
      };
    }
    /**
     * This is a shortcut for a typical update, commit/rollback lifecycle based on
     * the error of the action.
     */
    async #withTransaction(action) {
      const { update, commit, rollback } = this.#createTransaction();
      try {
        await action(update);
        commit();
      } catch (error) {
        rollback();
        throw error;
      }
    }
    async reset() {
      const actions = [];
      for (const [flag, button] of [
        [1, MouseButton.Left],
        [4, MouseButton.Middle],
        [2, MouseButton.Right],
        [16, MouseButton.Forward],
        [8, MouseButton.Back]
      ]) {
        if (this.#state.buttons & flag) {
          actions.push(this.up({ button }));
        }
      }
      if (this.#state.position.x !== 0 || this.#state.position.y !== 0) {
        actions.push(this.move(0, 0));
      }
      await Promise.all(actions);
    }
    async move(x4, y6, options = {}) {
      const { steps = 1 } = options;
      const from2 = this.#state.position;
      const to = { x: x4, y: y6 };
      for (let i7 = 1; i7 <= steps; i7++) {
        await this.#withTransaction((updateState) => {
          updateState({
            position: {
              x: from2.x + (to.x - from2.x) * (i7 / steps),
              y: from2.y + (to.y - from2.y) * (i7 / steps)
            }
          });
          const { buttons, position } = this.#state;
          return this.#client.send("Input.dispatchMouseEvent", {
            type: "mouseMoved",
            modifiers: this.#keyboard._modifiers,
            buttons,
            button: getButtonFromPressedButtons(buttons),
            ...position
          });
        });
      }
    }
    async down(options = {}) {
      const { button = MouseButton.Left, clickCount = 1 } = options;
      const flag = getFlag(button);
      if (!flag) {
        throw new Error(`Unsupported mouse button: ${button}`);
      }
      if (this.#state.buttons & flag) {
        throw new Error(`'${button}' is already pressed.`);
      }
      await this.#withTransaction((updateState) => {
        updateState({
          buttons: this.#state.buttons | flag
        });
        const { buttons, position } = this.#state;
        return this.#client.send("Input.dispatchMouseEvent", {
          type: "mousePressed",
          modifiers: this.#keyboard._modifiers,
          clickCount,
          buttons,
          button,
          ...position
        });
      });
    }
    async up(options = {}) {
      const { button = MouseButton.Left, clickCount = 1 } = options;
      const flag = getFlag(button);
      if (!flag) {
        throw new Error(`Unsupported mouse button: ${button}`);
      }
      if (!(this.#state.buttons & flag)) {
        throw new Error(`'${button}' is not pressed.`);
      }
      await this.#withTransaction((updateState) => {
        updateState({
          buttons: this.#state.buttons & ~flag
        });
        const { buttons, position } = this.#state;
        return this.#client.send("Input.dispatchMouseEvent", {
          type: "mouseReleased",
          modifiers: this.#keyboard._modifiers,
          clickCount,
          buttons,
          button,
          ...position
        });
      });
    }
    async click(x4, y6, options = {}) {
      const { delay, count = 1, clickCount = count } = options;
      if (count < 1) {
        throw new Error("Click must occur a positive number of times.");
      }
      const actions = [this.move(x4, y6)];
      if (clickCount === count) {
        for (let i7 = 1; i7 < count; ++i7) {
          actions.push(this.down({ ...options, clickCount: i7 }), this.up({ ...options, clickCount: i7 }));
        }
      }
      actions.push(this.down({ ...options, clickCount }));
      if (typeof delay === "number") {
        await Promise.all(actions);
        actions.length = 0;
        await new Promise((resolve3) => {
          setTimeout(resolve3, delay);
        });
      }
      actions.push(this.up({ ...options, clickCount }));
      await Promise.all(actions);
    }
    async wheel(options = {}) {
      const { deltaX = 0, deltaY = 0 } = options;
      const { position, buttons } = this.#state;
      await this.#client.send("Input.dispatchMouseEvent", {
        type: "mouseWheel",
        pointerType: "mouse",
        modifiers: this.#keyboard._modifiers,
        deltaY,
        deltaX,
        buttons,
        ...position
      });
    }
    async drag(start, target) {
      const promise = new Promise((resolve3) => {
        this.#client.once("Input.dragIntercepted", (event) => {
          return resolve3(event.data);
        });
      });
      await this.move(start.x, start.y);
      await this.down();
      await this.move(target.x, target.y);
      return await promise;
    }
    async dragEnter(target, data) {
      await this.#client.send("Input.dispatchDragEvent", {
        type: "dragEnter",
        x: target.x,
        y: target.y,
        modifiers: this.#keyboard._modifiers,
        data
      });
    }
    async dragOver(target, data) {
      await this.#client.send("Input.dispatchDragEvent", {
        type: "dragOver",
        x: target.x,
        y: target.y,
        modifiers: this.#keyboard._modifiers,
        data
      });
    }
    async drop(target, data) {
      await this.#client.send("Input.dispatchDragEvent", {
        type: "drop",
        x: target.x,
        y: target.y,
        modifiers: this.#keyboard._modifiers,
        data
      });
    }
    async dragAndDrop(start, target, options = {}) {
      const { delay = null } = options;
      const data = await this.drag(start, target);
      await this.dragEnter(target, data);
      await this.dragOver(target, data);
      if (delay) {
        await new Promise((resolve3) => {
          return setTimeout(resolve3, delay);
        });
      }
      await this.drop(target, data);
      await this.up();
    }
  };
  var CdpTouchscreen = class extends Touchscreen {
    #client;
    #keyboard;
    constructor(client, keyboard) {
      super();
      this.#client = client;
      this.#keyboard = keyboard;
    }
    updateClient(client) {
      this.#client = client;
    }
    async touchStart(x4, y6) {
      await this.#client.send("Input.dispatchTouchEvent", {
        type: "touchStart",
        touchPoints: [
          {
            x: Math.round(x4),
            y: Math.round(y6),
            radiusX: 0.5,
            radiusY: 0.5,
            force: 0.5
          }
        ],
        modifiers: this.#keyboard._modifiers
      });
    }
    async touchMove(x4, y6) {
      await this.#client.send("Input.dispatchTouchEvent", {
        type: "touchMove",
        touchPoints: [
          {
            x: Math.round(x4),
            y: Math.round(y6),
            radiusX: 0.5,
            radiusY: 0.5,
            force: 0.5
          }
        ],
        modifiers: this.#keyboard._modifiers
      });
    }
    async touchEnd() {
      await this.#client.send("Input.dispatchTouchEvent", {
        type: "touchEnd",
        touchPoints: [],
        modifiers: this.#keyboard._modifiers
      });
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Tracing.js
  init_dirname();
  init_buffer2();
  init_util2();
  init_assert();
  init_Deferred();
  var Tracing = class {
    #client;
    #recording = false;
    #path;
    /**
     * @internal
     */
    constructor(client) {
      this.#client = client;
    }
    /**
     * @internal
     */
    updateClient(client) {
      this.#client = client;
    }
    /**
     * Starts a trace for the current page.
     * @remarks
     * Only one trace can be active at a time per browser.
     *
     * @param options - Optional `TracingOptions`.
     */
    async start(options = {}) {
      assert(!this.#recording, "Cannot start recording trace while already recording trace.");
      const defaultCategories = [
        "-*",
        "devtools.timeline",
        "v8.execute",
        "disabled-by-default-devtools.timeline",
        "disabled-by-default-devtools.timeline.frame",
        "toplevel",
        "blink.console",
        "blink.user_timing",
        "latencyInfo",
        "disabled-by-default-devtools.timeline.stack",
        "disabled-by-default-v8.cpu_profiler"
      ];
      const { path: path2, screenshots = false, categories = defaultCategories } = options;
      if (screenshots) {
        categories.push("disabled-by-default-devtools.screenshot");
      }
      const excludedCategories = categories.filter((cat) => {
        return cat.startsWith("-");
      }).map((cat) => {
        return cat.slice(1);
      });
      const includedCategories = categories.filter((cat) => {
        return !cat.startsWith("-");
      });
      this.#path = path2;
      this.#recording = true;
      await this.#client.send("Tracing.start", {
        transferMode: "ReturnAsStream",
        traceConfig: {
          excludedCategories,
          includedCategories
        }
      });
    }
    /**
     * Stops a trace started with the `start` method.
     * @returns Promise which resolves to buffer with trace data.
     */
    async stop() {
      const contentDeferred = Deferred.create();
      this.#client.once("Tracing.tracingComplete", async (event) => {
        try {
          assert(event.stream, 'Missing "stream"');
          const readable = await getReadableFromProtocolStream(this.#client, event.stream);
          const buffer2 = await getReadableAsBuffer(readable, this.#path);
          contentDeferred.resolve(buffer2 ?? void 0);
        } catch (error) {
          if (isErrorLike(error)) {
            contentDeferred.reject(error);
          } else {
            contentDeferred.reject(new Error(`Unknown error: ${error}`));
          }
        }
      });
      await this.#client.send("Tracing.end");
      this.#recording = false;
      return await contentDeferred.valueOrThrow();
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/WebWorker.js
  init_dirname();
  init_buffer2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/WebWorker.js
  init_dirname();
  init_buffer2();
  init_Errors();
  init_EventEmitter();
  init_util2();
  var WebWorker = class extends EventEmitter2 {
    /**
     * @internal
     */
    timeoutSettings = new TimeoutSettings();
    #url;
    /**
     * @internal
     */
    constructor(url) {
      super();
      this.#url = url;
    }
    /**
     * The URL of this web worker.
     */
    url() {
      return this.#url;
    }
    /**
     * Evaluates a given function in the {@link WebWorker | worker}.
     *
     * @remarks If the given function returns a promise,
     * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
     *
     * As a rule of thumb, if the return value of the given function is more
     * complicated than a JSON object (e.g. most classes), then
     * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated
     * value (or `{}`). This is because we are not returning the actual return
     * value, but a deserialized version as a result of transferring the return
     * value through a protocol to Puppeteer.
     *
     * In general, you should use
     * {@link WebWorker.evaluateHandle | evaluateHandle} if
     * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
     * properly or you need a mutable {@link JSHandle | handle} to the return
     * object.
     *
     * @param func - Function to be evaluated.
     * @param args - Arguments to pass into `func`.
     * @returns The result of `func`.
     */
    async evaluate(func, ...args) {
      func = withSourcePuppeteerURLIfNone(this.evaluate.name, func);
      return await this.mainRealm().evaluate(func, ...args);
    }
    /**
     * Evaluates a given function in the {@link WebWorker | worker}.
     *
     * @remarks If the given function returns a promise,
     * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
     *
     * In general, you should use
     * {@link WebWorker.evaluateHandle | evaluateHandle} if
     * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
     * properly or you need a mutable {@link JSHandle | handle} to the return
     * object.
     *
     * @param func - Function to be evaluated.
     * @param args - Arguments to pass into `func`.
     * @returns A {@link JSHandle | handle} to the return value of `func`.
     */
    async evaluateHandle(func, ...args) {
      func = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func);
      return await this.mainRealm().evaluateHandle(func, ...args);
    }
    async close() {
      throw new UnsupportedOperation("WebWorker.close() is not supported");
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/WebWorker.js
  init_util2();
  var CdpWebWorker = class extends WebWorker {
    #world;
    #client;
    #id;
    #targetType;
    constructor(client, url, targetId, targetType, consoleAPICalled, exceptionThrown) {
      super(url);
      this.#id = targetId;
      this.#client = client;
      this.#targetType = targetType;
      this.#world = new IsolatedWorld(this, new TimeoutSettings());
      this.#client.once("Runtime.executionContextCreated", async (event) => {
        this.#world.setContext(new ExecutionContext(client, event.context, this.#world));
      });
      this.#client.on("Runtime.consoleAPICalled", async (event) => {
        try {
          return consoleAPICalled(event.type, event.args.map((object) => {
            return new CdpJSHandle(this.#world, object);
          }), event.stackTrace);
        } catch (err) {
          debugError(err);
        }
      });
      this.#client.on("Runtime.exceptionThrown", exceptionThrown);
      this.#client.send("Runtime.enable").catch(debugError);
    }
    mainRealm() {
      return this.#world;
    }
    get client() {
      return this.#client;
    }
    async close() {
      switch (this.#targetType) {
        case TargetType.SERVICE_WORKER:
        case TargetType.SHARED_WORKER: {
          await this.client.connection()?.send("Target.closeTarget", {
            targetId: this.#id
          });
          await this.client.connection()?.send("Target.detachFromTarget", {
            sessionId: this.client.id()
          });
          break;
        }
        default:
          await this.evaluate(() => {
            self.close();
          });
      }
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
  var __addDisposableResource11 = function(env, value, async2) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async2) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env.stack.push({ value, dispose, async: async2 });
    } else if (async2) {
      env.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources11 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env) {
      function fail2(e9) {
        env.error = env.hasError ? new SuppressedError2(e9, env.error, "An error was suppressed during disposal.") : e9;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  function convertConsoleMessageLevel(method) {
    switch (method) {
      case "warning":
        return "warn";
      default:
        return method;
    }
  }
  var CdpPage = class _CdpPage extends Page {
    static async _create(client, target, ignoreHTTPSErrors, defaultViewport) {
      const page = new _CdpPage(client, target, ignoreHTTPSErrors);
      await page.#initialize();
      if (defaultViewport) {
        try {
          await page.setViewport(defaultViewport);
        } catch (err) {
          if (isErrorLike(err) && isTargetClosedError(err)) {
            debugError(err);
          } else {
            throw err;
          }
        }
      }
      return page;
    }
    #closed = false;
    #targetManager;
    #primaryTargetClient;
    #primaryTarget;
    #tabTargetClient;
    #tabTarget;
    #keyboard;
    #mouse;
    #touchscreen;
    #accessibility;
    #frameManager;
    #emulationManager;
    #tracing;
    #bindings = /* @__PURE__ */ new Map();
    #exposedFunctions = /* @__PURE__ */ new Map();
    #coverage;
    #viewport;
    #workers = /* @__PURE__ */ new Map();
    #fileChooserDeferreds = /* @__PURE__ */ new Set();
    #sessionCloseDeferred = Deferred.create();
    #serviceWorkerBypassed = false;
    #userDragInterceptionEnabled = false;
    #frameManagerHandlers = [
      [
        FrameManagerEvent.FrameAttached,
        (frame) => {
          this.emit("frameattached", frame);
        }
      ],
      [
        FrameManagerEvent.FrameDetached,
        (frame) => {
          this.emit("framedetached", frame);
        }
      ],
      [
        FrameManagerEvent.FrameNavigated,
        (frame) => {
          this.emit("framenavigated", frame);
        }
      ]
    ];
    #networkManagerHandlers = [
      [
        NetworkManagerEvent.Request,
        (request) => {
          this.emit("request", request);
        }
      ],
      [
        NetworkManagerEvent.RequestServedFromCache,
        (request) => {
          this.emit("requestservedfromcache", request);
        }
      ],
      [
        NetworkManagerEvent.Response,
        (response) => {
          this.emit("response", response);
        }
      ],
      [
        NetworkManagerEvent.RequestFailed,
        (request) => {
          this.emit("requestfailed", request);
        }
      ],
      [
        NetworkManagerEvent.RequestFinished,
        (request) => {
          this.emit("requestfinished", request);
        }
      ]
    ];
    #sessionHandlers = [
      [
        CDPSessionEvent.Disconnected,
        () => {
          this.#sessionCloseDeferred.reject(new TargetCloseError("Target closed"));
        }
      ],
      [
        "Page.domContentEventFired",
        () => {
          return this.emit("domcontentloaded", void 0);
        }
      ],
      [
        "Page.loadEventFired",
        () => {
          return this.emit("load", void 0);
        }
      ],
      ["Runtime.consoleAPICalled", this.#onConsoleAPI.bind(this)],
      ["Runtime.bindingCalled", this.#onBindingCalled.bind(this)],
      ["Page.javascriptDialogOpening", this.#onDialog.bind(this)],
      ["Runtime.exceptionThrown", this.#handleException.bind(this)],
      ["Inspector.targetCrashed", this.#onTargetCrashed.bind(this)],
      ["Performance.metrics", this.#emitMetrics.bind(this)],
      ["Log.entryAdded", this.#onLogEntryAdded.bind(this)],
      ["Page.fileChooserOpened", this.#onFileChooser.bind(this)]
    ];
    constructor(client, target, ignoreHTTPSErrors) {
      super();
      this.#primaryTargetClient = client;
      this.#tabTargetClient = client.parentSession();
      assert(this.#tabTargetClient, "Tab target session is not defined.");
      this.#tabTarget = this.#tabTargetClient._target();
      assert(this.#tabTarget, "Tab target is not defined.");
      this.#primaryTarget = target;
      this.#targetManager = target._targetManager();
      this.#keyboard = new CdpKeyboard(client);
      this.#mouse = new CdpMouse(client, this.#keyboard);
      this.#touchscreen = new CdpTouchscreen(client, this.#keyboard);
      this.#accessibility = new Accessibility(client);
      this.#frameManager = new FrameManager(client, this, ignoreHTTPSErrors, this._timeoutSettings);
      this.#emulationManager = new EmulationManager(client);
      this.#tracing = new Tracing(client);
      this.#coverage = new Coverage(client);
      this.#viewport = null;
      for (const [eventName, handler] of this.#frameManagerHandlers) {
        this.#frameManager.on(eventName, handler);
      }
      for (const [eventName, handler] of this.#networkManagerHandlers) {
        this.#frameManager.networkManager.on(eventName, handler);
      }
      this.#tabTargetClient.on(CDPSessionEvent.Swapped, this.#onActivation.bind(this));
      this.#tabTargetClient.on(CDPSessionEvent.Ready, this.#onSecondaryTarget.bind(this));
      this.#targetManager.on("targetGone", this.#onDetachedFromTarget);
      this.#tabTarget._isClosedDeferred.valueOrThrow().then(() => {
        this.#targetManager.off("targetGone", this.#onDetachedFromTarget);
        this.emit("close", void 0);
        this.#closed = true;
      }).catch(debugError);
      this.#setupPrimaryTargetListeners();
    }
    async #onActivation(newSession) {
      this.#primaryTargetClient = newSession;
      assert(this.#primaryTargetClient instanceof CdpCDPSession, "CDPSession is not instance of CDPSessionImpl");
      this.#primaryTarget = this.#primaryTargetClient._target();
      assert(this.#primaryTarget, "Missing target on swap");
      this.#keyboard.updateClient(newSession);
      this.#mouse.updateClient(newSession);
      this.#touchscreen.updateClient(newSession);
      this.#accessibility.updateClient(newSession);
      this.#emulationManager.updateClient(newSession);
      this.#tracing.updateClient(newSession);
      this.#coverage.updateClient(newSession);
      await this.#frameManager.swapFrameTree(newSession);
      this.#setupPrimaryTargetListeners();
    }
    async #onSecondaryTarget(session) {
      assert(session instanceof CdpCDPSession);
      if (session._target()._subtype() !== "prerender") {
        return;
      }
      this.#frameManager.registerSpeculativeSession(session).catch(debugError);
      this.#emulationManager.registerSpeculativeSession(session).catch(debugError);
    }
    /**
     * Sets up listeners for the primary target. The primary target can change
     * during a navigation to a prerended page.
     */
    #setupPrimaryTargetListeners() {
      this.#primaryTargetClient.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);
      for (const [eventName, handler] of this.#sessionHandlers) {
        this.#primaryTargetClient.on(eventName, handler);
      }
    }
    #onDetachedFromTarget = (target) => {
      const sessionId = target._session()?.id();
      const worker = this.#workers.get(sessionId);
      if (!worker) {
        return;
      }
      this.#workers.delete(sessionId);
      this.emit("workerdestroyed", worker);
    };
    #onAttachedToTarget = (session) => {
      assert(session instanceof CdpCDPSession);
      this.#frameManager.onAttachedToTarget(session._target());
      if (session._target()._getTargetInfo().type === "worker") {
        const worker = new CdpWebWorker(session, session._target().url(), session._target()._targetId, session._target().type(), this.#addConsoleMessage.bind(this), this.#handleException.bind(this));
        this.#workers.set(session.id(), worker);
        this.emit("workercreated", worker);
      }
      session.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);
    };
    async #initialize() {
      try {
        await Promise.all([
          this.#frameManager.initialize(this.#primaryTargetClient),
          this.#primaryTargetClient.send("Performance.enable"),
          this.#primaryTargetClient.send("Log.enable")
        ]);
      } catch (err) {
        if (isErrorLike(err) && isTargetClosedError(err)) {
          debugError(err);
        } else {
          throw err;
        }
      }
    }
    async #onFileChooser(event) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        if (!this.#fileChooserDeferreds.size) {
          return;
        }
        const frame = this.#frameManager.frame(event.frameId);
        assert(frame, "This should never happen.");
        const handle = __addDisposableResource11(env_1, await frame.worlds[MAIN_WORLD].adoptBackendNode(event.backendNodeId), false);
        const fileChooser = new FileChooser(handle.move(), event);
        for (const promise of this.#fileChooserDeferreds) {
          promise.resolve(fileChooser);
        }
        this.#fileChooserDeferreds.clear();
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources11(env_1);
      }
    }
    _client() {
      return this.#primaryTargetClient;
    }
    isServiceWorkerBypassed() {
      return this.#serviceWorkerBypassed;
    }
    isDragInterceptionEnabled() {
      return this.#userDragInterceptionEnabled;
    }
    isJavaScriptEnabled() {
      return this.#emulationManager.javascriptEnabled;
    }
    async waitForFileChooser(options = {}) {
      const needsEnable = this.#fileChooserDeferreds.size === 0;
      const { timeout: timeout2 = this._timeoutSettings.timeout() } = options;
      const deferred = Deferred.create({
        message: `Waiting for \`FileChooser\` failed: ${timeout2}ms exceeded`,
        timeout: timeout2
      });
      this.#fileChooserDeferreds.add(deferred);
      let enablePromise;
      if (needsEnable) {
        enablePromise = this.#primaryTargetClient.send("Page.setInterceptFileChooserDialog", {
          enabled: true
        });
      }
      try {
        const [result] = await Promise.all([
          deferred.valueOrThrow(),
          enablePromise
        ]);
        return result;
      } catch (error) {
        this.#fileChooserDeferreds.delete(deferred);
        throw error;
      }
    }
    async setGeolocation(options) {
      return await this.#emulationManager.setGeolocation(options);
    }
    target() {
      return this.#primaryTarget;
    }
    browser() {
      return this.#primaryTarget.browser();
    }
    browserContext() {
      return this.#primaryTarget.browserContext();
    }
    #onTargetCrashed() {
      this.emit("error", new Error("Page crashed!"));
    }
    #onLogEntryAdded(event) {
      const { level, text, args, source: source2, url, lineNumber } = event.entry;
      if (args) {
        args.map((arg) => {
          void releaseObject(this.#primaryTargetClient, arg);
        });
      }
      if (source2 !== "worker") {
        this.emit("console", new ConsoleMessage(convertConsoleMessageLevel(level), text, [], [{ url, lineNumber }]));
      }
    }
    mainFrame() {
      return this.#frameManager.mainFrame();
    }
    get keyboard() {
      return this.#keyboard;
    }
    get touchscreen() {
      return this.#touchscreen;
    }
    get coverage() {
      return this.#coverage;
    }
    get tracing() {
      return this.#tracing;
    }
    get accessibility() {
      return this.#accessibility;
    }
    frames() {
      return this.#frameManager.frames();
    }
    workers() {
      return Array.from(this.#workers.values());
    }
    async setRequestInterception(value) {
      return await this.#frameManager.networkManager.setRequestInterception(value);
    }
    async setBypassServiceWorker(bypass) {
      this.#serviceWorkerBypassed = bypass;
      return await this.#primaryTargetClient.send("Network.setBypassServiceWorker", { bypass });
    }
    async setDragInterception(enabled) {
      this.#userDragInterceptionEnabled = enabled;
      return await this.#primaryTargetClient.send("Input.setInterceptDrags", {
        enabled
      });
    }
    async setOfflineMode(enabled) {
      return await this.#frameManager.networkManager.setOfflineMode(enabled);
    }
    async emulateNetworkConditions(networkConditions) {
      return await this.#frameManager.networkManager.emulateNetworkConditions(networkConditions);
    }
    setDefaultNavigationTimeout(timeout2) {
      this._timeoutSettings.setDefaultNavigationTimeout(timeout2);
    }
    setDefaultTimeout(timeout2) {
      this._timeoutSettings.setDefaultTimeout(timeout2);
    }
    getDefaultTimeout() {
      return this._timeoutSettings.timeout();
    }
    async queryObjects(prototypeHandle) {
      assert(!prototypeHandle.disposed, "Prototype JSHandle is disposed!");
      assert(prototypeHandle.id, "Prototype JSHandle must not be referencing primitive value");
      const response = await this.mainFrame().client.send("Runtime.queryObjects", {
        prototypeObjectId: prototypeHandle.id
      });
      return createCdpHandle(this.mainFrame().mainRealm(), response.objects);
    }
    async cookies(...urls) {
      const originalCookies = (await this.#primaryTargetClient.send("Network.getCookies", {
        urls: urls.length ? urls : [this.url()]
      })).cookies;
      const unsupportedCookieAttributes = ["sourcePort"];
      const filterUnsupportedAttributes = (cookie) => {
        for (const attr of unsupportedCookieAttributes) {
          delete cookie[attr];
        }
        return cookie;
      };
      return originalCookies.map(filterUnsupportedAttributes);
    }
    async deleteCookie(...cookies) {
      const pageURL = this.url();
      for (const cookie of cookies) {
        const item = Object.assign({}, cookie);
        if (!cookie.url && pageURL.startsWith("http")) {
          item.url = pageURL;
        }
        await this.#primaryTargetClient.send("Network.deleteCookies", item);
      }
    }
    async setCookie(...cookies) {
      const pageURL = this.url();
      const startsWithHTTP = pageURL.startsWith("http");
      const items = cookies.map((cookie) => {
        const item = Object.assign({}, cookie);
        if (!item.url && startsWithHTTP) {
          item.url = pageURL;
        }
        assert(item.url !== "about:blank", `Blank page can not have cookie "${item.name}"`);
        assert(!String.prototype.startsWith.call(item.url || "", "data:"), `Data URL page can not have cookie "${item.name}"`);
        return item;
      });
      await this.deleteCookie(...items);
      if (items.length) {
        await this.#primaryTargetClient.send("Network.setCookies", {
          cookies: items
        });
      }
    }
    async exposeFunction(name2, pptrFunction) {
      if (this.#bindings.has(name2)) {
        throw new Error(`Failed to add page binding with name ${name2}: window['${name2}'] already exists!`);
      }
      let binding;
      switch (typeof pptrFunction) {
        case "function":
          binding = new Binding(name2, pptrFunction);
          break;
        default:
          binding = new Binding(name2, pptrFunction.default);
          break;
      }
      this.#bindings.set(name2, binding);
      const expression = pageBindingInitString("exposedFun", name2);
      await this.#primaryTargetClient.send("Runtime.addBinding", { name: name2 });
      const { identifier } = await this.#primaryTargetClient.send("Page.addScriptToEvaluateOnNewDocument", {
        source: expression
      });
      this.#exposedFunctions.set(name2, identifier);
      await Promise.all(this.frames().map((frame) => {
        if (frame !== this.mainFrame() && !frame._hasStartedLoading) {
          return;
        }
        return frame.evaluate(expression).catch(debugError);
      }));
    }
    async removeExposedFunction(name2) {
      const exposedFun = this.#exposedFunctions.get(name2);
      if (!exposedFun) {
        throw new Error(`Failed to remove page binding with name ${name2}: window['${name2}'] does not exists!`);
      }
      await this.#primaryTargetClient.send("Runtime.removeBinding", { name: name2 });
      await this.removeScriptToEvaluateOnNewDocument(exposedFun);
      await Promise.all(this.frames().map((frame) => {
        if (frame !== this.mainFrame() && !frame._hasStartedLoading) {
          return;
        }
        return frame.evaluate((name3) => {
          globalThis[name3] = void 0;
        }, name2).catch(debugError);
      }));
      this.#exposedFunctions.delete(name2);
      this.#bindings.delete(name2);
    }
    async authenticate(credentials) {
      return await this.#frameManager.networkManager.authenticate(credentials);
    }
    async setExtraHTTPHeaders(headers) {
      return await this.#frameManager.networkManager.setExtraHTTPHeaders(headers);
    }
    async setUserAgent(userAgent, userAgentMetadata) {
      return await this.#frameManager.networkManager.setUserAgent(userAgent, userAgentMetadata);
    }
    async metrics() {
      const response = await this.#primaryTargetClient.send("Performance.getMetrics");
      return this.#buildMetricsObject(response.metrics);
    }
    #emitMetrics(event) {
      this.emit("metrics", {
        title: event.title,
        metrics: this.#buildMetricsObject(event.metrics)
      });
    }
    #buildMetricsObject(metrics) {
      const result = {};
      for (const metric of metrics || []) {
        if (supportedMetrics.has(metric.name)) {
          result[metric.name] = metric.value;
        }
      }
      return result;
    }
    #handleException(exception) {
      this.emit("pageerror", createClientError(exception.exceptionDetails));
    }
    async #onConsoleAPI(event) {
      if (event.executionContextId === 0) {
        return;
      }
      const context2 = this.#frameManager.getExecutionContextById(event.executionContextId, this.#primaryTargetClient);
      if (!context2) {
        debugError(new Error(`ExecutionContext not found for a console message: ${JSON.stringify(event)}`));
        return;
      }
      const values = event.args.map((arg) => {
        return createCdpHandle(context2._world, arg);
      });
      this.#addConsoleMessage(convertConsoleMessageLevel(event.type), values, event.stackTrace);
    }
    async #onBindingCalled(event) {
      let payload;
      try {
        payload = JSON.parse(event.payload);
      } catch {
        return;
      }
      const { type, name: name2, seq, args, isTrivial } = payload;
      if (type !== "exposedFun") {
        return;
      }
      const context2 = this.#frameManager.executionContextById(event.executionContextId, this.#primaryTargetClient);
      if (!context2) {
        return;
      }
      const binding = this.#bindings.get(name2);
      await binding?.run(context2, seq, args, isTrivial);
    }
    #addConsoleMessage(eventType, args, stackTrace) {
      if (!this.listenerCount(
        "console"
        /* PageEvent.Console */
      )) {
        args.forEach((arg) => {
          return arg.dispose();
        });
        return;
      }
      const textTokens = [];
      for (const arg of args) {
        const remoteObject = arg.remoteObject();
        if (remoteObject.objectId) {
          textTokens.push(arg.toString());
        } else {
          textTokens.push(valueFromRemoteObject(remoteObject));
        }
      }
      const stackTraceLocations = [];
      if (stackTrace) {
        for (const callFrame of stackTrace.callFrames) {
          stackTraceLocations.push({
            url: callFrame.url,
            lineNumber: callFrame.lineNumber,
            columnNumber: callFrame.columnNumber
          });
        }
      }
      const message = new ConsoleMessage(convertConsoleMessageLevel(eventType), textTokens.join(" "), args, stackTraceLocations);
      this.emit("console", message);
    }
    #onDialog(event) {
      const type = validateDialogType(event.type);
      const dialog = new CdpDialog(this.#primaryTargetClient, type, event.message, event.defaultPrompt);
      this.emit("dialog", dialog);
    }
    async reload(options) {
      const [result] = await Promise.all([
        this.waitForNavigation({
          ...options,
          ignoreSameDocumentNavigation: true
        }),
        this.#primaryTargetClient.send("Page.reload")
      ]);
      return result;
    }
    async createCDPSession() {
      return await this.target().createCDPSession();
    }
    async goBack(options = {}) {
      return await this.#go(-1, options);
    }
    async goForward(options = {}) {
      return await this.#go(1, options);
    }
    async #go(delta, options) {
      const history = await this.#primaryTargetClient.send("Page.getNavigationHistory");
      const entry = history.entries[history.currentIndex + delta];
      if (!entry) {
        return null;
      }
      const result = await Promise.all([
        this.waitForNavigation(options),
        this.#primaryTargetClient.send("Page.navigateToHistoryEntry", {
          entryId: entry.id
        })
      ]);
      return result[0];
    }
    async bringToFront() {
      await this.#primaryTargetClient.send("Page.bringToFront");
    }
    async setJavaScriptEnabled(enabled) {
      return await this.#emulationManager.setJavaScriptEnabled(enabled);
    }
    async setBypassCSP(enabled) {
      await this.#primaryTargetClient.send("Page.setBypassCSP", { enabled });
    }
    async emulateMediaType(type) {
      return await this.#emulationManager.emulateMediaType(type);
    }
    async emulateCPUThrottling(factor) {
      return await this.#emulationManager.emulateCPUThrottling(factor);
    }
    async emulateMediaFeatures(features) {
      return await this.#emulationManager.emulateMediaFeatures(features);
    }
    async emulateTimezone(timezoneId) {
      return await this.#emulationManager.emulateTimezone(timezoneId);
    }
    async emulateIdleState(overrides) {
      return await this.#emulationManager.emulateIdleState(overrides);
    }
    async emulateVisionDeficiency(type) {
      return await this.#emulationManager.emulateVisionDeficiency(type);
    }
    async setViewport(viewport) {
      const needsReload = await this.#emulationManager.emulateViewport(viewport);
      this.#viewport = viewport;
      if (needsReload) {
        await this.reload();
      }
    }
    viewport() {
      return this.#viewport;
    }
    async evaluateOnNewDocument(pageFunction, ...args) {
      const source2 = evaluationString(pageFunction, ...args);
      const { identifier } = await this.#primaryTargetClient.send("Page.addScriptToEvaluateOnNewDocument", {
        source: source2
      });
      return { identifier };
    }
    async removeScriptToEvaluateOnNewDocument(identifier) {
      await this.#primaryTargetClient.send("Page.removeScriptToEvaluateOnNewDocument", {
        identifier
      });
    }
    async setCacheEnabled(enabled = true) {
      await this.#frameManager.networkManager.setCacheEnabled(enabled);
    }
    async _screenshot(options) {
      const env_2 = { stack: [], error: void 0, hasError: false };
      try {
        const { fromSurface, omitBackground, optimizeForSpeed, quality, clip: userClip, type, captureBeyondViewport } = options;
        const isFirefox = this.target()._targetManager() instanceof FirefoxTargetManager;
        const stack = __addDisposableResource11(env_2, new AsyncDisposableStack(), true);
        if (!isFirefox && omitBackground && (type === "png" || type === "webp")) {
          await this.#emulationManager.setTransparentBackgroundColor();
          stack.defer(async () => {
            await this.#emulationManager.resetDefaultBackgroundColor().catch(debugError);
          });
        }
        let clip = userClip;
        if (clip && !captureBeyondViewport) {
          const viewport = await this.mainFrame().isolatedRealm().evaluate(() => {
            const { height, pageLeft: x4, pageTop: y6, width } = window.visualViewport;
            return { x: x4, y: y6, height, width };
          });
          clip = getIntersectionRect(clip, viewport);
        }
        const { data } = await this.#primaryTargetClient.send("Page.captureScreenshot", {
          format: type,
          ...optimizeForSpeed ? { optimizeForSpeed } : {},
          ...quality !== void 0 ? { quality: Math.round(quality) } : {},
          ...clip ? { clip: { ...clip, scale: clip.scale ?? 1 } } : {},
          ...!fromSurface ? { fromSurface } : {},
          captureBeyondViewport
        });
        return data;
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        const result_1 = __disposeResources11(env_2);
        if (result_1)
          await result_1;
      }
    }
    async createPDFStream(options = {}) {
      const { timeout: ms = this._timeoutSettings.timeout() } = options;
      const { landscape, displayHeaderFooter, headerTemplate, footerTemplate, printBackground, scale, width: paperWidth, height: paperHeight, margin, pageRanges, preferCSSPageSize, omitBackground, tagged: generateTaggedPDF, outline: generateDocumentOutline } = parsePDFOptions(options);
      if (omitBackground) {
        await this.#emulationManager.setTransparentBackgroundColor();
      }
      await firstValueFrom(from(this.mainFrame().isolatedRealm().evaluate(() => {
        return document.fonts.ready;
      })).pipe(raceWith(timeout(ms))));
      const printCommandPromise = this.#primaryTargetClient.send("Page.printToPDF", {
        transferMode: "ReturnAsStream",
        landscape,
        displayHeaderFooter,
        headerTemplate,
        footerTemplate,
        printBackground,
        scale,
        paperWidth,
        paperHeight,
        marginTop: margin.top,
        marginBottom: margin.bottom,
        marginLeft: margin.left,
        marginRight: margin.right,
        pageRanges,
        preferCSSPageSize,
        generateTaggedPDF,
        generateDocumentOutline
      });
      const result = await firstValueFrom(from(printCommandPromise).pipe(raceWith(timeout(ms))));
      if (omitBackground) {
        await this.#emulationManager.resetDefaultBackgroundColor();
      }
      assert(result.stream, "`stream` is missing from `Page.printToPDF");
      return await getReadableFromProtocolStream(this.#primaryTargetClient, result.stream);
    }
    async pdf(options = {}) {
      const { path: path2 = void 0 } = options;
      const readable = await this.createPDFStream(options);
      const buffer2 = await getReadableAsBuffer(readable, path2);
      assert(buffer2, "Could not create buffer");
      return buffer2;
    }
    async close(options = { runBeforeUnload: void 0 }) {
      const connection = this.#primaryTargetClient.connection();
      assert(connection, "Protocol error: Connection closed. Most likely the page has been closed.");
      const runBeforeUnload = !!options.runBeforeUnload;
      if (runBeforeUnload) {
        await this.#primaryTargetClient.send("Page.close");
      } else {
        await connection.send("Target.closeTarget", {
          targetId: this.#primaryTarget._targetId
        });
        await this.#tabTarget._isClosedDeferred.valueOrThrow();
      }
    }
    isClosed() {
      return this.#closed;
    }
    get mouse() {
      return this.#mouse;
    }
    /**
     * This method is typically coupled with an action that triggers a device
     * request from an api such as WebBluetooth.
     *
     * :::caution
     *
     * This must be called before the device request is made. It will not return a
     * currently active device prompt.
     *
     * :::
     *
     * @example
     *
     * ```ts
     * const [devicePrompt] = Promise.all([
     *   page.waitForDevicePrompt(),
     *   page.click('#connect-bluetooth'),
     * ]);
     * await devicePrompt.select(
     *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))
     * );
     * ```
     */
    async waitForDevicePrompt(options = {}) {
      return await this.mainFrame().waitForDevicePrompt(options);
    }
  };
  var supportedMetrics = /* @__PURE__ */ new Set([
    "Timestamp",
    "Documents",
    "Frames",
    "JSEventListeners",
    "Nodes",
    "LayoutCount",
    "RecalcStyleCount",
    "LayoutDuration",
    "RecalcStyleDuration",
    "ScriptDuration",
    "TaskDuration",
    "JSHeapUsedSize",
    "JSHeapTotalSize"
  ]);
  function getIntersectionRect(clip, viewport) {
    const x4 = Math.max(clip.x, viewport.x);
    const y6 = Math.max(clip.y, viewport.y);
    return {
      x: x4,
      y: y6,
      width: Math.max(Math.min(clip.x + clip.width, viewport.x + viewport.width) - x4, 0),
      height: Math.max(Math.min(clip.y + clip.height, viewport.y + viewport.height) - y6, 0)
    };
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Target.js
  var InitializationStatus;
  (function(InitializationStatus2) {
    InitializationStatus2["SUCCESS"] = "success";
    InitializationStatus2["ABORTED"] = "aborted";
  })(InitializationStatus || (InitializationStatus = {}));
  var CdpTarget = class extends Target {
    #browserContext;
    #session;
    #targetInfo;
    #targetManager;
    #sessionFactory;
    _initializedDeferred = Deferred.create();
    _isClosedDeferred = Deferred.create();
    _targetId;
    /**
     * To initialize the target for use, call initialize.
     *
     * @internal
     */
    constructor(targetInfo, session, browserContext, targetManager, sessionFactory) {
      super();
      this.#session = session;
      this.#targetManager = targetManager;
      this.#targetInfo = targetInfo;
      this.#browserContext = browserContext;
      this._targetId = targetInfo.targetId;
      this.#sessionFactory = sessionFactory;
      if (this.#session && this.#session instanceof CdpCDPSession) {
        this.#session._setTarget(this);
      }
    }
    async asPage() {
      const session = this._session();
      if (!session) {
        return await this.createCDPSession().then((client) => {
          return CdpPage._create(client, this, false, null);
        });
      }
      return await CdpPage._create(session, this, false, null);
    }
    _subtype() {
      return this.#targetInfo.subtype;
    }
    _session() {
      return this.#session;
    }
    _sessionFactory() {
      if (!this.#sessionFactory) {
        throw new Error("sessionFactory is not initialized");
      }
      return this.#sessionFactory;
    }
    createCDPSession() {
      if (!this.#sessionFactory) {
        throw new Error("sessionFactory is not initialized");
      }
      return this.#sessionFactory(false).then((session) => {
        session._setTarget(this);
        return session;
      });
    }
    url() {
      return this.#targetInfo.url;
    }
    type() {
      const type = this.#targetInfo.type;
      switch (type) {
        case "page":
          return TargetType.PAGE;
        case "background_page":
          return TargetType.BACKGROUND_PAGE;
        case "service_worker":
          return TargetType.SERVICE_WORKER;
        case "shared_worker":
          return TargetType.SHARED_WORKER;
        case "browser":
          return TargetType.BROWSER;
        case "webview":
          return TargetType.WEBVIEW;
        case "tab":
          return TargetType.TAB;
        default:
          return TargetType.OTHER;
      }
    }
    _targetManager() {
      if (!this.#targetManager) {
        throw new Error("targetManager is not initialized");
      }
      return this.#targetManager;
    }
    _getTargetInfo() {
      return this.#targetInfo;
    }
    browser() {
      if (!this.#browserContext) {
        throw new Error("browserContext is not initialized");
      }
      return this.#browserContext.browser();
    }
    browserContext() {
      if (!this.#browserContext) {
        throw new Error("browserContext is not initialized");
      }
      return this.#browserContext;
    }
    opener() {
      const { openerId } = this.#targetInfo;
      if (!openerId) {
        return;
      }
      return this.browser().targets().find((target) => {
        return target._targetId === openerId;
      });
    }
    _targetInfoChanged(targetInfo) {
      this.#targetInfo = targetInfo;
      this._checkIfInitialized();
    }
    _initialize() {
      this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
    }
    _isTargetExposed() {
      return this.type() !== TargetType.TAB && !this._subtype();
    }
    _checkIfInitialized() {
      if (!this._initializedDeferred.resolved()) {
        this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
      }
    }
  };
  var PageTarget = class _PageTarget extends CdpTarget {
    #defaultViewport;
    pagePromise;
    #ignoreHTTPSErrors;
    constructor(targetInfo, session, browserContext, targetManager, sessionFactory, ignoreHTTPSErrors, defaultViewport) {
      super(targetInfo, session, browserContext, targetManager, sessionFactory);
      this.#ignoreHTTPSErrors = ignoreHTTPSErrors;
      this.#defaultViewport = defaultViewport ?? void 0;
    }
    _initialize() {
      this._initializedDeferred.valueOrThrow().then(async (result) => {
        if (result === InitializationStatus.ABORTED) {
          return;
        }
        const opener = this.opener();
        if (!(opener instanceof _PageTarget)) {
          return;
        }
        if (!opener || !opener.pagePromise || this.type() !== "page") {
          return true;
        }
        const openerPage = await opener.pagePromise;
        if (!openerPage.listenerCount(
          "popup"
          /* PageEvent.Popup */
        )) {
          return true;
        }
        const popupPage = await this.page();
        openerPage.emit("popup", popupPage);
        return true;
      }).catch(debugError);
      this._checkIfInitialized();
    }
    async page() {
      if (!this.pagePromise) {
        const session = this._session();
        this.pagePromise = (session ? Promise.resolve(session) : this._sessionFactory()(
          /* isAutoAttachEmulated=*/
          false
        )).then((client) => {
          return CdpPage._create(client, this, this.#ignoreHTTPSErrors, this.#defaultViewport ?? null);
        });
      }
      return await this.pagePromise ?? null;
    }
    _checkIfInitialized() {
      if (this._initializedDeferred.resolved()) {
        return;
      }
      if (this._getTargetInfo().url !== "") {
        this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
      }
    }
  };
  var DevToolsTarget = class extends PageTarget {
  };
  var WorkerTarget = class extends CdpTarget {
    #workerPromise;
    async worker() {
      if (!this.#workerPromise) {
        const session = this._session();
        this.#workerPromise = (session ? Promise.resolve(session) : this._sessionFactory()(
          /* isAutoAttachEmulated=*/
          false
        )).then((client) => {
          return new CdpWebWorker(
            client,
            this._getTargetInfo().url,
            this._targetId,
            this.type(),
            () => {
            },
            () => {
            }
            /* exceptionThrown */
          );
        });
      }
      return await this.#workerPromise;
    }
  };
  var OtherTarget = class extends CdpTarget {
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ChromeTargetManager.js
  function isPageTargetBecomingPrimary(target, newTargetInfo) {
    return Boolean(target._subtype()) && !newTargetInfo.subtype;
  }
  var ChromeTargetManager = class extends EventEmitter2 {
    #connection;
    /**
     * Keeps track of the following events: 'Target.targetCreated',
     * 'Target.targetDestroyed', 'Target.targetInfoChanged'.
     *
     * A target becomes discovered when 'Target.targetCreated' is received.
     * A target is removed from this map once 'Target.targetDestroyed' is
     * received.
     *
     * `targetFilterCallback` has no effect on this map.
     */
    #discoveredTargetsByTargetId = /* @__PURE__ */ new Map();
    /**
     * A target is added to this map once ChromeTargetManager has created
     * a Target and attached at least once to it.
     */
    #attachedTargetsByTargetId = /* @__PURE__ */ new Map();
    /**
     * Tracks which sessions attach to which target.
     */
    #attachedTargetsBySessionId = /* @__PURE__ */ new Map();
    /**
     * If a target was filtered out by `targetFilterCallback`, we still receive
     * events about it from CDP, but we don't forward them to the rest of Puppeteer.
     */
    #ignoredTargets = /* @__PURE__ */ new Set();
    #targetFilterCallback;
    #targetFactory;
    #attachedToTargetListenersBySession = /* @__PURE__ */ new WeakMap();
    #detachedFromTargetListenersBySession = /* @__PURE__ */ new WeakMap();
    #initializeDeferred = Deferred.create();
    #targetsIdsForInit = /* @__PURE__ */ new Set();
    #waitForInitiallyDiscoveredTargets = true;
    #discoveryFilter = [{}];
    constructor(connection, targetFactory, targetFilterCallback, waitForInitiallyDiscoveredTargets = true) {
      super();
      this.#connection = connection;
      this.#targetFilterCallback = targetFilterCallback;
      this.#targetFactory = targetFactory;
      this.#waitForInitiallyDiscoveredTargets = waitForInitiallyDiscoveredTargets;
      this.#connection.on("Target.targetCreated", this.#onTargetCreated);
      this.#connection.on("Target.targetDestroyed", this.#onTargetDestroyed);
      this.#connection.on("Target.targetInfoChanged", this.#onTargetInfoChanged);
      this.#connection.on(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
      this.#setupAttachmentListeners(this.#connection);
    }
    #storeExistingTargetsForInit = () => {
      if (!this.#waitForInitiallyDiscoveredTargets) {
        return;
      }
      for (const [targetId, targetInfo] of this.#discoveredTargetsByTargetId.entries()) {
        const targetForFilter = new CdpTarget(targetInfo, void 0, void 0, this, void 0);
        if ((!this.#targetFilterCallback || this.#targetFilterCallback(targetForFilter)) && targetInfo.type !== "browser") {
          this.#targetsIdsForInit.add(targetId);
        }
      }
    };
    async initialize() {
      await this.#connection.send("Target.setDiscoverTargets", {
        discover: true,
        filter: this.#discoveryFilter
      });
      this.#storeExistingTargetsForInit();
      await this.#connection.send("Target.setAutoAttach", {
        waitForDebuggerOnStart: true,
        flatten: true,
        autoAttach: true,
        filter: [
          {
            type: "page",
            exclude: true
          },
          ...this.#discoveryFilter
        ]
      });
      this.#finishInitializationIfReady();
      await this.#initializeDeferred.valueOrThrow();
    }
    dispose() {
      this.#connection.off("Target.targetCreated", this.#onTargetCreated);
      this.#connection.off("Target.targetDestroyed", this.#onTargetDestroyed);
      this.#connection.off("Target.targetInfoChanged", this.#onTargetInfoChanged);
      this.#connection.off(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
      this.#removeAttachmentListeners(this.#connection);
    }
    getAvailableTargets() {
      return this.#attachedTargetsByTargetId;
    }
    #setupAttachmentListeners(session) {
      const listener = (event) => {
        void this.#onAttachedToTarget(session, event);
      };
      assert(!this.#attachedToTargetListenersBySession.has(session));
      this.#attachedToTargetListenersBySession.set(session, listener);
      session.on("Target.attachedToTarget", listener);
      const detachedListener = (event) => {
        return this.#onDetachedFromTarget(session, event);
      };
      assert(!this.#detachedFromTargetListenersBySession.has(session));
      this.#detachedFromTargetListenersBySession.set(session, detachedListener);
      session.on("Target.detachedFromTarget", detachedListener);
    }
    #removeAttachmentListeners(session) {
      const listener = this.#attachedToTargetListenersBySession.get(session);
      if (listener) {
        session.off("Target.attachedToTarget", listener);
        this.#attachedToTargetListenersBySession.delete(session);
      }
      if (this.#detachedFromTargetListenersBySession.has(session)) {
        session.off("Target.detachedFromTarget", this.#detachedFromTargetListenersBySession.get(session));
        this.#detachedFromTargetListenersBySession.delete(session);
      }
    }
    #onSessionDetached = (session) => {
      this.#removeAttachmentListeners(session);
    };
    #onTargetCreated = async (event) => {
      this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
      this.emit("targetDiscovered", event.targetInfo);
      if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
        if (this.#attachedTargetsByTargetId.has(event.targetInfo.targetId)) {
          return;
        }
        const target = this.#targetFactory(event.targetInfo, void 0);
        target._initialize();
        this.#attachedTargetsByTargetId.set(event.targetInfo.targetId, target);
      }
    };
    #onTargetDestroyed = (event) => {
      const targetInfo = this.#discoveredTargetsByTargetId.get(event.targetId);
      this.#discoveredTargetsByTargetId.delete(event.targetId);
      this.#finishInitializationIfReady(event.targetId);
      if (targetInfo?.type === "service_worker" && this.#attachedTargetsByTargetId.has(event.targetId)) {
        const target = this.#attachedTargetsByTargetId.get(event.targetId);
        if (target) {
          this.emit("targetGone", target);
          this.#attachedTargetsByTargetId.delete(event.targetId);
        }
      }
    };
    #onTargetInfoChanged = (event) => {
      this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
      if (this.#ignoredTargets.has(event.targetInfo.targetId) || !this.#attachedTargetsByTargetId.has(event.targetInfo.targetId) || !event.targetInfo.attached) {
        return;
      }
      const target = this.#attachedTargetsByTargetId.get(event.targetInfo.targetId);
      if (!target) {
        return;
      }
      const previousURL = target.url();
      const wasInitialized = target._initializedDeferred.value() === InitializationStatus.SUCCESS;
      if (isPageTargetBecomingPrimary(target, event.targetInfo)) {
        const session = target?._session();
        assert(session, "Target that is being activated is missing a CDPSession.");
        session.parentSession()?.emit(CDPSessionEvent.Swapped, session);
      }
      target._targetInfoChanged(event.targetInfo);
      if (wasInitialized && previousURL !== target.url()) {
        this.emit("targetChanged", {
          target,
          wasInitialized,
          previousURL
        });
      }
    };
    #onAttachedToTarget = async (parentSession, event) => {
      const targetInfo = event.targetInfo;
      const session = this.#connection.session(event.sessionId);
      if (!session) {
        throw new Error(`Session ${event.sessionId} was not created.`);
      }
      const silentDetach = async () => {
        await session.send("Runtime.runIfWaitingForDebugger").catch(debugError);
        await parentSession.send("Target.detachFromTarget", {
          sessionId: session.id()
        }).catch(debugError);
      };
      if (!this.#connection.isAutoAttached(targetInfo.targetId)) {
        return;
      }
      if (targetInfo.type === "service_worker") {
        this.#finishInitializationIfReady(targetInfo.targetId);
        await silentDetach();
        if (this.#attachedTargetsByTargetId.has(targetInfo.targetId)) {
          return;
        }
        const target2 = this.#targetFactory(targetInfo);
        target2._initialize();
        this.#attachedTargetsByTargetId.set(targetInfo.targetId, target2);
        this.emit("targetAvailable", target2);
        return;
      }
      const isExistingTarget = this.#attachedTargetsByTargetId.has(targetInfo.targetId);
      const target = isExistingTarget ? this.#attachedTargetsByTargetId.get(targetInfo.targetId) : this.#targetFactory(targetInfo, session, parentSession instanceof CDPSession ? parentSession : void 0);
      if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {
        this.#ignoredTargets.add(targetInfo.targetId);
        this.#finishInitializationIfReady(targetInfo.targetId);
        await silentDetach();
        return;
      }
      this.#setupAttachmentListeners(session);
      if (isExistingTarget) {
        session._setTarget(target);
        this.#attachedTargetsBySessionId.set(session.id(), this.#attachedTargetsByTargetId.get(targetInfo.targetId));
      } else {
        target._initialize();
        this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);
        this.#attachedTargetsBySessionId.set(session.id(), target);
      }
      parentSession.emit(CDPSessionEvent.Ready, session);
      this.#targetsIdsForInit.delete(target._targetId);
      if (!isExistingTarget) {
        this.emit("targetAvailable", target);
      }
      this.#finishInitializationIfReady();
      await Promise.all([
        session.send("Target.setAutoAttach", {
          waitForDebuggerOnStart: true,
          flatten: true,
          autoAttach: true,
          filter: this.#discoveryFilter
        }),
        session.send("Runtime.runIfWaitingForDebugger")
      ]).catch(debugError);
    };
    #finishInitializationIfReady(targetId) {
      targetId !== void 0 && this.#targetsIdsForInit.delete(targetId);
      if (this.#targetsIdsForInit.size === 0) {
        this.#initializeDeferred.resolve();
      }
    }
    #onDetachedFromTarget = (_parentSession, event) => {
      const target = this.#attachedTargetsBySessionId.get(event.sessionId);
      this.#attachedTargetsBySessionId.delete(event.sessionId);
      if (!target) {
        return;
      }
      this.#attachedTargetsByTargetId.delete(target._targetId);
      this.emit("targetGone", target);
    };
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Browser.js
  var CdpBrowser = class _CdpBrowser extends Browser {
    protocol = "cdp";
    static async _create(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process4, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true) {
      const browser = new _CdpBrowser(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process4, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets);
      await browser._attach();
      return browser;
    }
    #ignoreHTTPSErrors;
    #defaultViewport;
    #process;
    #connection;
    #closeCallback;
    #targetFilterCallback;
    #isPageTargetCallback;
    #defaultContext;
    #contexts = /* @__PURE__ */ new Map();
    #targetManager;
    constructor(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process4, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true) {
      super();
      product = product || "chrome";
      this.#ignoreHTTPSErrors = ignoreHTTPSErrors;
      this.#defaultViewport = defaultViewport;
      this.#process = process4;
      this.#connection = connection;
      this.#closeCallback = closeCallback || function() {
      };
      this.#targetFilterCallback = targetFilterCallback || (() => {
        return true;
      });
      this.#setIsPageTargetCallback(isPageTargetCallback);
      if (product === "firefox") {
        this.#targetManager = new FirefoxTargetManager(connection, this.#createTarget, this.#targetFilterCallback);
      } else {
        this.#targetManager = new ChromeTargetManager(connection, this.#createTarget, this.#targetFilterCallback, waitForInitiallyDiscoveredTargets);
      }
      this.#defaultContext = new CdpBrowserContext(this.#connection, this);
      for (const contextId of contextIds) {
        this.#contexts.set(contextId, new CdpBrowserContext(this.#connection, this, contextId));
      }
    }
    #emitDisconnected = () => {
      this.emit("disconnected", void 0);
    };
    async _attach() {
      this.#connection.on(CDPSessionEvent.Disconnected, this.#emitDisconnected);
      this.#targetManager.on("targetAvailable", this.#onAttachedToTarget);
      this.#targetManager.on("targetGone", this.#onDetachedFromTarget);
      this.#targetManager.on("targetChanged", this.#onTargetChanged);
      this.#targetManager.on("targetDiscovered", this.#onTargetDiscovered);
      await this.#targetManager.initialize();
    }
    _detach() {
      this.#connection.off(CDPSessionEvent.Disconnected, this.#emitDisconnected);
      this.#targetManager.off("targetAvailable", this.#onAttachedToTarget);
      this.#targetManager.off("targetGone", this.#onDetachedFromTarget);
      this.#targetManager.off("targetChanged", this.#onTargetChanged);
      this.#targetManager.off("targetDiscovered", this.#onTargetDiscovered);
    }
    process() {
      return this.#process ?? null;
    }
    _targetManager() {
      return this.#targetManager;
    }
    #setIsPageTargetCallback(isPageTargetCallback) {
      this.#isPageTargetCallback = isPageTargetCallback || ((target) => {
        return target.type() === "page" || target.type() === "background_page" || target.type() === "webview";
      });
    }
    _getIsPageTargetCallback() {
      return this.#isPageTargetCallback;
    }
    async createBrowserContext(options = {}) {
      const { proxyServer, proxyBypassList } = options;
      const { browserContextId } = await this.#connection.send("Target.createBrowserContext", {
        proxyServer,
        proxyBypassList: proxyBypassList && proxyBypassList.join(",")
      });
      const context2 = new CdpBrowserContext(this.#connection, this, browserContextId);
      this.#contexts.set(browserContextId, context2);
      return context2;
    }
    browserContexts() {
      return [this.#defaultContext, ...Array.from(this.#contexts.values())];
    }
    defaultBrowserContext() {
      return this.#defaultContext;
    }
    async _disposeContext(contextId) {
      if (!contextId) {
        return;
      }
      await this.#connection.send("Target.disposeBrowserContext", {
        browserContextId: contextId
      });
      this.#contexts.delete(contextId);
    }
    #createTarget = (targetInfo, session) => {
      const { browserContextId } = targetInfo;
      const context2 = browserContextId && this.#contexts.has(browserContextId) ? this.#contexts.get(browserContextId) : this.#defaultContext;
      if (!context2) {
        throw new Error("Missing browser context");
      }
      const createSession = (isAutoAttachEmulated) => {
        return this.#connection._createSession(targetInfo, isAutoAttachEmulated);
      };
      const otherTarget = new OtherTarget(targetInfo, session, context2, this.#targetManager, createSession);
      if (targetInfo.url?.startsWith("devtools://")) {
        return new DevToolsTarget(targetInfo, session, context2, this.#targetManager, createSession, this.#ignoreHTTPSErrors, this.#defaultViewport ?? null);
      }
      if (this.#isPageTargetCallback(otherTarget)) {
        return new PageTarget(targetInfo, session, context2, this.#targetManager, createSession, this.#ignoreHTTPSErrors, this.#defaultViewport ?? null);
      }
      if (targetInfo.type === "service_worker" || targetInfo.type === "shared_worker") {
        return new WorkerTarget(targetInfo, session, context2, this.#targetManager, createSession);
      }
      return otherTarget;
    };
    #onAttachedToTarget = async (target) => {
      if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
        this.emit("targetcreated", target);
        target.browserContext().emit("targetcreated", target);
      }
    };
    #onDetachedFromTarget = async (target) => {
      target._initializedDeferred.resolve(InitializationStatus.ABORTED);
      target._isClosedDeferred.resolve();
      if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
        this.emit("targetdestroyed", target);
        target.browserContext().emit("targetdestroyed", target);
      }
    };
    #onTargetChanged = ({ target }) => {
      this.emit("targetchanged", target);
      target.browserContext().emit("targetchanged", target);
    };
    #onTargetDiscovered = (targetInfo) => {
      this.emit("targetdiscovered", targetInfo);
    };
    wsEndpoint() {
      return this.#connection.url();
    }
    async newPage() {
      return await this.#defaultContext.newPage();
    }
    async _createPageInContext(contextId) {
      const { targetId } = await this.#connection.send("Target.createTarget", {
        url: "about:blank",
        browserContextId: contextId || void 0
      });
      const target = await this.waitForTarget((t8) => {
        return t8._targetId === targetId;
      });
      if (!target) {
        throw new Error(`Missing target for page (id = ${targetId})`);
      }
      const initialized = await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS;
      if (!initialized) {
        throw new Error(`Failed to create target for page (id = ${targetId})`);
      }
      const page = await target.page();
      if (!page) {
        throw new Error(`Failed to create a page for context (id = ${contextId})`);
      }
      return page;
    }
    targets() {
      return Array.from(this.#targetManager.getAvailableTargets().values()).filter((target) => {
        return target._isTargetExposed() && target._initializedDeferred.value() === InitializationStatus.SUCCESS;
      });
    }
    target() {
      const browserTarget = this.targets().find((target) => {
        return target.type() === "browser";
      });
      if (!browserTarget) {
        throw new Error("Browser target is not found");
      }
      return browserTarget;
    }
    async version() {
      const version = await this.#getVersion();
      return version.product;
    }
    async userAgent() {
      const version = await this.#getVersion();
      return version.userAgent;
    }
    async close() {
      await this.#closeCallback.call(null);
      await this.disconnect();
    }
    disconnect() {
      this.#targetManager.dispose();
      this.#connection.dispose();
      this._detach();
      return Promise.resolve();
    }
    get connected() {
      return !this.#connection._closed;
    }
    #getVersion() {
      return this.#connection.send("Browser.getVersion");
    }
    get debugInfo() {
      return {
        pendingProtocolErrors: this.#connection.getPendingProtocolErrors()
      };
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/BrowserConnector.js
  async function _connectToCdpBrowser(connectionTransport, url, options) {
    const { ignoreHTTPSErrors = false, defaultViewport = DEFAULT_VIEWPORT, targetFilter, _isPageTarget: isPageTarget, slowMo = 0, protocolTimeout } = options;
    const connection = new Connection(url, connectionTransport, slowMo, protocolTimeout);
    const version = await connection.send("Browser.getVersion");
    const product = version.product.toLowerCase().includes("firefox") ? "firefox" : "chrome";
    const { browserContextIds } = await connection.send("Target.getBrowserContexts");
    const browser = await CdpBrowser._create(product || "chrome", connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, void 0, () => {
      return connection.send("Browser.close").catch(debugError);
    }, targetFilter, isPageTarget);
    return browser;
  }

  // src/shared/utils/function/client.ts
  var FunctionRunner = class {
    browser;
    page;
    log = () => console.log.bind(console);
    async start(data) {
      console.log(`/function.js: Got endpoint: "${data.browserWSEndpoint}"`);
      const { browserWSEndpoint, code, context: context2, options } = data;
      const connectionTransport = await BrowserWebSocketTransport.create(browserWSEndpoint);
      const cdpOptions = {
        headers: {
          Host: "127.0.0.1"
        }
      };
      this.browser = await _connectToCdpBrowser(
        connectionTransport,
        browserWSEndpoint,
        cdpOptions
      );
      this.browser.once("disconnected", () => this.stop());
      this.page = await this.browser.newPage();
      if (options.downloadPath) {
        console.debug(
          `_browserless_function_client_: Setting downloads for page to "${options.downloadPath}"`
        );
        const client = this.page._client.call(this.page);
        await client.send("Page.setDownloadBehavior", {
          behavior: "allow",
          downloadPath: options.downloadPath
        });
      }
      const response = await code({ context: context2, page: this.page });
      console.debug(
        `_browserless_function_client_: Code is finished executing, closing page.`
      );
      this.page.close().catch(this.log);
      if (response instanceof Uint8Array) {
        return {
          contentType: "uint8array",
          payload: Array.from(response)
        };
      }
      if (typeof response === "string") {
        return {
          contentType: response.startsWith("<") ? "text/html" : "text/plain",
          payload: response
        };
      }
      if (typeof response === "object") {
        return {
          contentType: "application/json",
          payload: JSON.stringify(response, null, "  ")
        };
      }
      return {
        contentType: "text/plain",
        payload: response
      };
    }
    stop() {
      if (this.browser)
        this.browser.disconnect();
    }
  };
  Object.defineProperty(window, "BrowserlessFunctionRunner", {
    configurable: false,
    enumerable: false,
    value: FunctionRunner,
    writable: false
  });
})();
/*! Bundled license information:

@jspm/core/nodelibs/browser/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

puppeteer-core/lib/esm/puppeteer/util/assert.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/environment.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/Debug.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/Errors.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

@jspm/core/nodelibs/browser/chunk-44e51b61.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/assert.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

puppeteer-core/lib/esm/puppeteer/common/util.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/disposable.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/Deferred.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/Mutex.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/decorators.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/node/ScreenRecorder.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Browser.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/BrowserContext.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Target.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/CDPSession.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Page.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/FileChooser.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/NetworkManagerEvents.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/JSHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Binding.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Connection.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Dialog.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Dialog.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/LazyArg.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/Function.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/ElementHandleSymbol.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/HandleIterator.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/CustomQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PierceQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/TextQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/XPathQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/utils.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/JSHandle.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/ElementHandle.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/ExecutionContext.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/FirefoxTargetManager.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Frame.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/DeviceRequestPrompt.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/WaitTask.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Realm.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorld.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorlds.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/FrameManagerEvents.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/LifecycleWatcher.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Frame.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/FrameTree.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/NetworkEventManager.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/NetworkManager.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/FrameManager.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Input.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/USKeyboardLayout.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Input.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/WebWorker.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Page.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Target.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/ChromeTargetManager.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Browser.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/BrowserConnector.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)
*/

    </script>
  </head>
  <body>
  </body>
</html>
